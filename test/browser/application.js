/** Generated by SimQ **/
/** modules **/

// Generated by CoffeeScript 1.6.3
(function() {
  var SUPPORTED, arrayIndexOf, cache, creating, modules, require, resolve, stats;

  if (!this.require) {
    SUPPORTED = ['js', 'json', 'ts', 'coffee', 'eco'];
    modules = {};
    stats = {};
    cache = {};
    creating = [];
    require = function(name, parent) {
      var fullName, m;
      if (parent == null) {
        parent = null;
      }
      fullName = resolve(name, parent);
      if (fullName === null) {
        throw new Error('Module ' + name + ' was not found.');
      }
      if (typeof cache[fullName] === 'undefined') {
        m = {
          exports: {},
          id: fullName,
          filename: fullName,
          loaded: false,
          parent: null,
          children: null
        };
        if (arrayIndexOf(creating, fullName) === -1) {
          creating.push(fullName);
          modules[fullName].apply(window, [m.exports, m]);
          creating.splice(arrayIndexOf(creating, fullName));
          cache[fullName] = m;
        }
        m.loaded = true;
      } else {
        m = cache[fullName];
      }
      if (typeof stats[fullName] === 'undefined') {
        stats[fullName] = {
          atime: null,
          mtime: null,
          ctime: null
        };
      }
      stats[fullName].atime = new Date;
      return m.exports;
    };
    resolve = function(name, parent) {
      var ext, num, part, parts, prev, result, _i, _j, _k, _len, _len1, _len2;
      if (parent == null) {
        parent = null;
      }
      if (parent !== null && name[0] === '.') {
        num = parent.lastIndexOf('/');
        if (num !== -1) {
          parent = parent.substr(0, num);
        }
        name = parent + '/' + name;
        parts = name.split('/');
        result = [];
        prev = null;
        for (_i = 0, _len = parts.length; _i < _len; _i++) {
          part = parts[_i];
          if (part === '.' || part === '') {
            continue;
          } else if (part === '..' && prev) {
            result.pop();
          } else {
            result.push(part);
          }
          prev = part;
        }
        name = result.join('/');
        if (parent[0] === '/') {
          name = '/' + name;
        }
      }
      if (typeof modules[name] !== 'undefined') {
        return name;
      }
      for (_j = 0, _len1 = SUPPORTED.length; _j < _len1; _j++) {
        ext = SUPPORTED[_j];
        if (typeof modules[name + '.' + ext] !== 'undefined') {
          return name + '.' + ext;
        }
      }
      for (_k = 0, _len2 = SUPPORTED.length; _k < _len2; _k++) {
        ext = SUPPORTED[_k];
        if (typeof modules[name + '/index.' + ext] !== 'undefined') {
          return name + '/index.' + ext;
        }
      }
      return null;
    };
    arrayIndexOf = function(array, search) {
      var element, i, _i, _len;
      if (typeof Array.prototype.indexOf !== 'undefined') {
        return array.indexOf(search);
      }
      if (array.length === 0) {
        return -1;
      }
      for (i = _i = 0, _len = array.length; _i < _len; i = ++_i) {
        element = array[i];
        if (element === search) {
          return i;
        }
      }
      return -1;
    };
    this.require = function(name, parent) {
      if (parent == null) {
        parent = null;
      }
      return require(name, parent);
    };
    this.require.simq = true;
    this.require.version = 1;
    this.require.resolve = function(name, parent) {
      if (parent == null) {
        parent = null;
      }
      return resolve(name, parent);
    };
    this.require.define = function(bundleOrName, obj) {
      var m, name, _results;
      if (obj == null) {
        obj = null;
      }
      if (typeof bundleOrName === 'string') {
        return modules[bundleOrName] = obj;
      } else {
        _results = [];
        for (name in bundleOrName) {
          m = bundleOrName[name];
          _results.push(modules[name] = m);
        }
        return _results;
      }
    };
    this.require.release = function() {
      var name, _results;
      _results = [];
      for (name in cache) {
        _results.push(delete cache[name]);
      }
      return _results;
    };
    this.require.getStats = function(name, parent) {
      var fullName;
      if (parent == null) {
        parent = null;
      }
      fullName = resolve(name, parent);
      if (fullName === null) {
        throw new Error('Module ' + name + ' was not found.');
      }
      if (typeof stats[fullName] === 'undefined') {
        stats[fullName] = {
          atime: null,
          mtime: null,
          ctime: null
        };
      }
      return stats[fullName];
    };
    this.require.__setStats = function(bundle) {
      var data, name, _results;
      _results = [];
      for (name in bundle) {
        data = bundle[name];
        _results.push(stats[name] = {
          atime: new Date(data.atime),
          mtime: new Date(data.mtime),
          ctime: new Date(data.ctime)
        });
      }
      return _results;
    };
    this.require.cache = cache;
  }

  return this.require.define;

}).call(this)({
 '/lib/Storage/Sync/BrowserLocalStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Sync/BrowserLocalStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Sync/BrowserLocalStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Sync/BrowserLocalStorage.js';
	var __dirname = '/lib/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Sync/BrowserLocalStorage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var BrowserLocalStorage, Cache, Storage,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  Storage = require('./Storage');
	
	  Cache = require('../../Cache');
	
	  BrowserLocalStorage = (function(_super) {
	    __extends(BrowserLocalStorage, _super);
	
	    BrowserLocalStorage.TEST_VALUE = '__--cache-storage--__';
	
	    BrowserLocalStorage.prototype.allData = null;
	
	    BrowserLocalStorage.prototype.data = null;
	
	    BrowserLocalStorage.prototype.meta = null;
	
	    function BrowserLocalStorage() {
	      if (!BrowserLocalStorage.isSupported()) {
	        throw new Error('Cache storage: Local storage is not supported');
	      }
	    }
	
	    BrowserLocalStorage.isSupported = function() {
	      var e;
	      try {
	        localStorage.setItem(BrowserLocalStorage.TEST_VALUE, BrowserLocalStorage.TEST_VALUE);
	        localStorage.getItem(BrowserLocalStorage.TEST_VALUE);
	        return true;
	      } catch (_error) {
	        e = _error;
	        return false;
	      }
	    };
	
	    BrowserLocalStorage.prototype.getName = function() {
	      return '__' + this.cache.namespace;
	    };
	
	    BrowserLocalStorage.prototype.loadData = function() {
	      var data;
	      if (this.allData === null) {
	        data = localStorage.getItem(this.getName());
	        if (data === null) {
	          this.allData = {
	            data: {},
	            meta: {}
	          };
	        } else {
	          this.allData = JSON.parse(data);
	        }
	      }
	      return this.allData;
	    };
	
	    BrowserLocalStorage.prototype.getData = function() {
	      if (this.data === null) {
	        this.data = this.loadData().data;
	      }
	      return this.data;
	    };
	
	    BrowserLocalStorage.prototype.getMeta = function() {
	      if (this.meta === null) {
	        this.meta = this.loadData().meta;
	      }
	      return this.meta;
	    };
	
	    BrowserLocalStorage.prototype.writeData = function(data, meta) {
	      this.data = data;
	      this.meta = meta;
	      localStorage.setItem(this.getName(), JSON.stringify({
	        data: this.data,
	        meta: this.meta
	      }));
	      return this;
	    };
	
	    return BrowserLocalStorage;
	
	  })(Storage);
	
	  module.exports = BrowserLocalStorage;
	
	}).call(this);
	

}, '/lib/Storage/Sync/Storage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Sync/Storage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Sync/Storage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Sync/Storage.js';
	var __dirname = '/lib/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Sync/Storage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var BaseStorage, Cache, Storage, isWindow, moment, path, _ref,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  isWindow = typeof window === 'undefined' ? false : true;
	
	  if (!isWindow) {
	    path = require('path');
	  }
	
	  BaseStorage = require('../Storage');
	
	  moment = require('moment');
	
	  Cache = require('../../Cache');
	
	  Storage = (function(_super) {
	    __extends(Storage, _super);
	
	    function Storage() {
	      _ref = Storage.__super__.constructor.apply(this, arguments);
	      return _ref;
	    }
	
	    Storage.prototype.async = false;
	
	    Storage.prototype.read = function(key) {
	      var data;
	      data = this.getData();
	      if (typeof data[key] === 'undefined') {
	        return null;
	      } else {
	        if (this.verify(this.findMeta(key))) {
	          return data[key];
	        } else {
	          this.remove(key);
	          return null;
	        }
	      }
	    };
	
	    Storage.prototype.write = function(key, data, dependencies) {
	      var all, meta;
	      if (dependencies == null) {
	        dependencies = {};
	      }
	      all = this.getData();
	      all[key] = data;
	      meta = this.getMeta();
	      meta[key] = dependencies;
	      this.writeData(all, meta);
	      return this;
	    };
	
	    Storage.prototype.remove = function(key) {
	      var data, meta;
	      data = this.getData();
	      meta = this.getMeta();
	      if (typeof data[key] !== 'undefined') {
	        delete data[key];
	        delete meta[key];
	      }
	      this.writeData(data, meta);
	      return this;
	    };
	
	    Storage.prototype.clean = function(conditions) {
	      var key, tag, type, typeFn, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3;
	      typeFn = Object.prototype.toString;
	      type = typeFn.call(conditions);
	      if (conditions === Cache.ALL) {
	        this.writeData({}, {});
	      } else if (type === '[object Object]') {
	        if (typeof conditions[Cache.TAGS] !== 'undefined') {
	          if (typeFn(conditions[Cache.TAGS]) === '[object String]') {
	            conditions[Cache.TAGS] = [conditions[Cache.TAGS]];
	          }
	          _ref1 = conditions[Cache.TAGS];
	          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	            tag = _ref1[_i];
	            _ref2 = this.findKeysByTag(tag);
	            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
	              key = _ref2[_j];
	              this.remove(key);
	            }
	          }
	        }
	        if (typeof conditions[Cache.PRIORITY] !== 'undefined') {
	          _ref3 = this.findKeysByPriority(conditions[Cache.PRIORITY]);
	          for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
	            key = _ref3[_k];
	            this.remove(key);
	          }
	        }
	      }
	      return this;
	    };
	
	    Storage.prototype.findMeta = function(key) {
	      var meta;
	      meta = this.getMeta();
	      if (typeof meta[key] !== 'undefined') {
	        return meta[key];
	      } else {
	        return null;
	      }
	    };
	
	    Storage.prototype.findKeysByTag = function(tag) {
	      var key, meta, metas, result;
	      metas = this.getMeta();
	      result = [];
	      for (key in metas) {
	        meta = metas[key];
	        if (typeof meta[Cache.TAGS] !== 'undefined' && meta[Cache.TAGS].indexOf(tag) !== -1) {
	          result.push(key);
	        }
	      }
	      return result;
	    };
	
	    Storage.prototype.findKeysByPriority = function(priority) {
	      var key, meta, metas, result;
	      metas = this.getMeta();
	      result = [];
	      for (key in metas) {
	        meta = metas[key];
	        if (typeof meta[Cache.PRIORITY] !== 'undefined' && meta[Cache.PRIORITY] <= priority) {
	          result.push(key);
	        }
	      }
	      return result;
	    };
	
	    Storage.prototype.verify = function(meta) {
	      var file, item, mtime, time, typefn, _i, _len, _ref1, _ref2, _ref3;
	      typefn = Object.prototype.toString;
	      if (typefn.call(meta) === '[object Object]') {
	        if (typeof meta[Cache.FILES] !== 'undefined') {
	          this.checkFilesSupport();
	          if (isWindow) {
	            _ref1 = meta[Cache.FILES];
	            for (file in _ref1) {
	              time = _ref1[file];
	              mtime = window.require.getStats(file).mtime;
	              if (mtime === null) {
	                throw new Error('File stats are disabled in your simq configuration. Can not get stats for ' + file + '.');
	              }
	              if (window.require.getStats(file).mtime.getTime() !== time) {
	                return false;
	              }
	            }
	          } else {
	            _ref2 = meta[Cache.FILES];
	            for (file in _ref2) {
	              time = _ref2[file];
	              if ((new Date(Cache.getFs().statSync(file).mtime)).getTime() !== time) {
	                return false;
	              }
	            }
	          }
	        }
	        if (typeof meta[Cache.EXPIRE] !== 'undefined') {
	          if (moment().valueOf() >= meta[Cache.EXPIRE]) {
	            return false;
	          }
	        }
	        if (typeof meta[Cache.ITEMS] !== 'undefined') {
	          if (this.async) {
	            throw new Error('Expiration by items is currently not supported in async storages.');
	          }
	          _ref3 = meta[Cache.ITEMS];
	          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
	            item = _ref3[_i];
	            item = this.findMeta(item);
	            if ((item === null) || (item !== null && this.verify(item) === false)) {
	              return false;
	            }
	          }
	        }
	      }
	      return true;
	    };
	
	    Storage.prototype.parseDependencies = function(dependencies) {
	      var file, files, i, item, mtime, result, time, typefn, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3;
	      typefn = Object.prototype.toString;
	      result = {};
	      if (typefn.call(dependencies) === '[object Object]') {
	        if (typeof dependencies[Cache.FILES] !== 'undefined') {
	          this.checkFilesSupport();
	          files = {};
	          if (isWindow) {
	            _ref1 = dependencies[Cache.FILES];
	            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	              file = _ref1[_i];
	              mtime = window.require.getStats(file).mtime;
	              if (mtime === null) {
	                throw new Error('File stats are disabled in your simq configuration. Can not get stats for ' + file + '.');
	              }
	              file = window.require.resolve(file);
	              files[file] = mtime.getTime();
	            }
	          } else {
	            _ref2 = dependencies[Cache.FILES];
	            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
	              file = _ref2[_j];
	              file = path.resolve(file);
	              files[file] = (new Date(Cache.getFs().statSync(file).mtime)).getTime();
	            }
	          }
	          result[Cache.FILES] = files;
	        }
	        if (typeof dependencies[Cache.EXPIRE] !== 'undefined') {
	          switch (typefn.call(dependencies[Cache.EXPIRE])) {
	            case '[object String]':
	              time = moment(dependencies[Cache.EXPIRE], Cache.TIME_FORMAT);
	              break;
	            case '[object Object]':
	              time = moment().add(dependencies[Cache.EXPIRE]);
	              break;
	            default:
	              throw new Error('Expire format is not valid');
	          }
	          result[Cache.EXPIRE] = time.valueOf();
	        }
	        if (typeof dependencies[Cache.ITEMS] !== 'undefined') {
	          result[Cache.ITEMS] = [];
	          _ref3 = dependencies[Cache.ITEMS];
	          for (i = _k = 0, _len2 = _ref3.length; _k < _len2; i = ++_k) {
	            item = _ref3[i];
	            result[Cache.ITEMS].push(this.cache.generateKey(item));
	          }
	        }
	        if (typeof dependencies[Cache.PRIORITY] !== 'undefined') {
	          result[Cache.PRIORITY] = dependencies[Cache.PRIORITY];
	        }
	        if (typeof dependencies[Cache.TAGS] !== 'undefined') {
	          result[Cache.TAGS] = dependencies[Cache.TAGS];
	        }
	      }
	      return result;
	    };
	
	    return Storage;
	
	  })(BaseStorage);
	
	  module.exports = Storage;
	
	}).call(this);
	

}, '/lib/Storage/Storage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Storage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Storage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Storage.js';
	var __dirname = '/lib/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Storage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Storage;
	
	  Storage = (function() {
	    Storage.prototype.async = false;
	
	    Storage.prototype.cache = null;
	
	    function Storage() {
	      if (typeof this.getData === 'undefined' || typeof this.getMeta === 'undefined' || typeof this.writeData === 'undefined') {
	        throw new Error('Cache storage: you have to implement methods getData, getMeta and writeData.');
	      }
	    }
	
	    Storage.prototype.checkFilesSupport = function() {
	      var isWindow, version;
	      isWindow = typeof window === 'undefined' ? false : true;
	      if (isWindow && window.require.simq !== true) {
	        throw new Error('Files meta information can be used in browser only with simq.');
	      }
	      if (isWindow) {
	        version = window.require.version;
	        if (typeof version === 'undefined' || parseInt(version.replace(/\./g, '')) < 510) {
	          throw new Error('File method information is supported only with simq@5.1.0 and later.');
	        }
	      }
	    };
	
	    return Storage;
	
	  })();
	
	  module.exports = Storage;
	
	}).call(this);
	

}, 'moment/moment.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'moment/moment.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'moment/moment.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'moment/moment.js';
	var __dirname = 'moment';
	var process = {cwd: function() {return '/';}, argv: ['node', 'moment/moment.js'], env: {}};

	/** code **/
	//! moment.js
	//! version : 2.5.0
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com
	
	(function (undefined) {
	
	    /************************************
	        Constants
	    ************************************/
	
	    var moment,
	        VERSION = "2.5.0",
	        global = this,
	        round = Math.round,
	        i,
	
	        YEAR = 0,
	        MONTH = 1,
	        DATE = 2,
	        HOUR = 3,
	        MINUTE = 4,
	        SECOND = 5,
	        MILLISECOND = 6,
	
	        // internal storage for language config files
	        languages = {},
	
	        // check for nodeJS
	        hasModule = (typeof module !== 'undefined' && module.exports && typeof require !== 'undefined'),
	
	        // ASP.NET json date format regex
	        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
	        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,
	
	        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,
	
	        // format tokens
	        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
	        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,
	
	        // parsing token regexes
	        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
	        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
	        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
	        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
	        parseTokenDigits = /\d+/, // nonzero number of digits
	        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
	        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
	        parseTokenT = /T/i, // T (ISO separator)
	        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
	
	        //strict parsing regexes
	        parseTokenOneDigit = /\d/, // 0 - 9
	        parseTokenTwoDigits = /\d\d/, // 00 - 99
	        parseTokenThreeDigits = /\d{3}/, // 000 - 999
	        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
	        parseTokenSixDigits = /[+\-]?\d{6}/, // -999,999 - 999,999
	
	        // iso 8601 regex
	        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	        isoRegex = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
	
	        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',
	
	        isoDates = [
	            'YYYY-MM-DD',
	            'GGGG-[W]WW',
	            'GGGG-[W]WW-E',
	            'YYYY-DDD'
	        ],
	
	        // iso time formats and regexes
	        isoTimes = [
	            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d{1,3}/],
	            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
	            ['HH:mm', /(T| )\d\d:\d\d/],
	            ['HH', /(T| )\d\d/]
	        ],
	
	        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
	        parseTimezoneChunker = /([\+\-]|\d\d)/gi,
	
	        // getter and setter names
	        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
	        unitMillisecondFactors = {
	            'Milliseconds' : 1,
	            'Seconds' : 1e3,
	            'Minutes' : 6e4,
	            'Hours' : 36e5,
	            'Days' : 864e5,
	            'Months' : 2592e6,
	            'Years' : 31536e6
	        },
	
	        unitAliases = {
	            ms : 'millisecond',
	            s : 'second',
	            m : 'minute',
	            h : 'hour',
	            d : 'day',
	            D : 'date',
	            w : 'week',
	            W : 'isoWeek',
	            M : 'month',
	            y : 'year',
	            DDD : 'dayOfYear',
	            e : 'weekday',
	            E : 'isoWeekday',
	            gg: 'weekYear',
	            GG: 'isoWeekYear'
	        },
	
	        camelFunctions = {
	            dayofyear : 'dayOfYear',
	            isoweekday : 'isoWeekday',
	            isoweek : 'isoWeek',
	            weekyear : 'weekYear',
	            isoweekyear : 'isoWeekYear'
	        },
	
	        // format function strings
	        formatFunctions = {},
	
	        // tokens to ordinalize and pad
	        ordinalizeTokens = 'DDD w W M D d'.split(' '),
	        paddedTokens = 'M D H h m s w W'.split(' '),
	
	        formatTokenFunctions = {
	            M    : function () {
	                return this.month() + 1;
	            },
	            MMM  : function (format) {
	                return this.lang().monthsShort(this, format);
	            },
	            MMMM : function (format) {
	                return this.lang().months(this, format);
	            },
	            D    : function () {
	                return this.date();
	            },
	            DDD  : function () {
	                return this.dayOfYear();
	            },
	            d    : function () {
	                return this.day();
	            },
	            dd   : function (format) {
	                return this.lang().weekdaysMin(this, format);
	            },
	            ddd  : function (format) {
	                return this.lang().weekdaysShort(this, format);
	            },
	            dddd : function (format) {
	                return this.lang().weekdays(this, format);
	            },
	            w    : function () {
	                return this.week();
	            },
	            W    : function () {
	                return this.isoWeek();
	            },
	            YY   : function () {
	                return leftZeroFill(this.year() % 100, 2);
	            },
	            YYYY : function () {
	                return leftZeroFill(this.year(), 4);
	            },
	            YYYYY : function () {
	                return leftZeroFill(this.year(), 5);
	            },
	            YYYYYY : function () {
	                var y = this.year(), sign = y >= 0 ? '+' : '-';
	                return sign + leftZeroFill(Math.abs(y), 6);
	            },
	            gg   : function () {
	                return leftZeroFill(this.weekYear() % 100, 2);
	            },
	            gggg : function () {
	                return this.weekYear();
	            },
	            ggggg : function () {
	                return leftZeroFill(this.weekYear(), 5);
	            },
	            GG   : function () {
	                return leftZeroFill(this.isoWeekYear() % 100, 2);
	            },
	            GGGG : function () {
	                return this.isoWeekYear();
	            },
	            GGGGG : function () {
	                return leftZeroFill(this.isoWeekYear(), 5);
	            },
	            e : function () {
	                return this.weekday();
	            },
	            E : function () {
	                return this.isoWeekday();
	            },
	            a    : function () {
	                return this.lang().meridiem(this.hours(), this.minutes(), true);
	            },
	            A    : function () {
	                return this.lang().meridiem(this.hours(), this.minutes(), false);
	            },
	            H    : function () {
	                return this.hours();
	            },
	            h    : function () {
	                return this.hours() % 12 || 12;
	            },
	            m    : function () {
	                return this.minutes();
	            },
	            s    : function () {
	                return this.seconds();
	            },
	            S    : function () {
	                return toInt(this.milliseconds() / 100);
	            },
	            SS   : function () {
	                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
	            },
	            SSS  : function () {
	                return leftZeroFill(this.milliseconds(), 3);
	            },
	            SSSS : function () {
	                return leftZeroFill(this.milliseconds(), 3);
	            },
	            Z    : function () {
	                var a = -this.zone(),
	                    b = "+";
	                if (a < 0) {
	                    a = -a;
	                    b = "-";
	                }
	                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
	            },
	            ZZ   : function () {
	                var a = -this.zone(),
	                    b = "+";
	                if (a < 0) {
	                    a = -a;
	                    b = "-";
	                }
	                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
	            },
	            z : function () {
	                return this.zoneAbbr();
	            },
	            zz : function () {
	                return this.zoneName();
	            },
	            X    : function () {
	                return this.unix();
	            },
	            Q : function () {
	                return this.quarter();
	            }
	        },
	
	        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];
	
	    function padToken(func, count) {
	        return function (a) {
	            return leftZeroFill(func.call(this, a), count);
	        };
	    }
	    function ordinalizeToken(func, period) {
	        return function (a) {
	            return this.lang().ordinal(func.call(this, a), period);
	        };
	    }
	
	    while (ordinalizeTokens.length) {
	        i = ordinalizeTokens.pop();
	        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
	    }
	    while (paddedTokens.length) {
	        i = paddedTokens.pop();
	        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
	    }
	    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);
	
	
	    /************************************
	        Constructors
	    ************************************/
	
	    function Language() {
	
	    }
	
	    // Moment prototype object
	    function Moment(config) {
	        checkOverflow(config);
	        extend(this, config);
	    }
	
	    // Duration Constructor
	    function Duration(duration) {
	        var normalizedInput = normalizeObjectUnits(duration),
	            years = normalizedInput.year || 0,
	            months = normalizedInput.month || 0,
	            weeks = normalizedInput.week || 0,
	            days = normalizedInput.day || 0,
	            hours = normalizedInput.hour || 0,
	            minutes = normalizedInput.minute || 0,
	            seconds = normalizedInput.second || 0,
	            milliseconds = normalizedInput.millisecond || 0;
	
	        // representation for dateAddRemove
	        this._milliseconds = +milliseconds +
	            seconds * 1e3 + // 1000
	            minutes * 6e4 + // 1000 * 60
	            hours * 36e5; // 1000 * 60 * 60
	        // Because of dateAddRemove treats 24 hours as different from a
	        // day when working around DST, we need to store them separately
	        this._days = +days +
	            weeks * 7;
	        // It is impossible translate months into days without knowing
	        // which months you are are talking about, so we have to store
	        // it separately.
	        this._months = +months +
	            years * 12;
	
	        this._data = {};
	
	        this._bubble();
	    }
	
	    /************************************
	        Helpers
	    ************************************/
	
	
	    function extend(a, b) {
	        for (var i in b) {
	            if (b.hasOwnProperty(i)) {
	                a[i] = b[i];
	            }
	        }
	
	        if (b.hasOwnProperty("toString")) {
	            a.toString = b.toString;
	        }
	
	        if (b.hasOwnProperty("valueOf")) {
	            a.valueOf = b.valueOf;
	        }
	
	        return a;
	    }
	
	    function absRound(number) {
	        if (number < 0) {
	            return Math.ceil(number);
	        } else {
	            return Math.floor(number);
	        }
	    }
	
	    // left zero fill a number
	    // see http://jsperf.com/left-zero-filling for performance comparison
	    function leftZeroFill(number, targetLength, forceSign) {
	        var output = Math.abs(number) + '',
	            sign = number >= 0;
	
	        while (output.length < targetLength) {
	            output = '0' + output;
	        }
	        return (sign ? (forceSign ? '+' : '') : '-') + output;
	    }
	
	    // helper function for _.addTime and _.subtractTime
	    function addOrSubtractDurationFromMoment(mom, duration, isAdding, ignoreUpdateOffset) {
	        var milliseconds = duration._milliseconds,
	            days = duration._days,
	            months = duration._months,
	            minutes,
	            hours;
	
	        if (milliseconds) {
	            mom._d.setTime(+mom._d + milliseconds * isAdding);
	        }
	        // store the minutes and hours so we can restore them
	        if (days || months) {
	            minutes = mom.minute();
	            hours = mom.hour();
	        }
	        if (days) {
	            mom.date(mom.date() + days * isAdding);
	        }
	        if (months) {
	            mom.month(mom.month() + months * isAdding);
	        }
	        if (milliseconds && !ignoreUpdateOffset) {
	            moment.updateOffset(mom);
	        }
	        // restore the minutes and hours after possibly changing dst
	        if (days || months) {
	            mom.minute(minutes);
	            mom.hour(hours);
	        }
	    }
	
	    // check if is an array
	    function isArray(input) {
	        return Object.prototype.toString.call(input) === '[object Array]';
	    }
	
	    function isDate(input) {
	        return  Object.prototype.toString.call(input) === '[object Date]' ||
	                input instanceof Date;
	    }
	
	    // compare two arrays, return the number of differences
	    function compareArrays(array1, array2, dontConvert) {
	        var len = Math.min(array1.length, array2.length),
	            lengthDiff = Math.abs(array1.length - array2.length),
	            diffs = 0,
	            i;
	        for (i = 0; i < len; i++) {
	            if ((dontConvert && array1[i] !== array2[i]) ||
	                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	                diffs++;
	            }
	        }
	        return diffs + lengthDiff;
	    }
	
	    function normalizeUnits(units) {
	        if (units) {
	            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
	            units = unitAliases[units] || camelFunctions[lowered] || lowered;
	        }
	        return units;
	    }
	
	    function normalizeObjectUnits(inputObject) {
	        var normalizedInput = {},
	            normalizedProp,
	            prop;
	
	        for (prop in inputObject) {
	            if (inputObject.hasOwnProperty(prop)) {
	                normalizedProp = normalizeUnits(prop);
	                if (normalizedProp) {
	                    normalizedInput[normalizedProp] = inputObject[prop];
	                }
	            }
	        }
	
	        return normalizedInput;
	    }
	
	    function makeList(field) {
	        var count, setter;
	
	        if (field.indexOf('week') === 0) {
	            count = 7;
	            setter = 'day';
	        }
	        else if (field.indexOf('month') === 0) {
	            count = 12;
	            setter = 'month';
	        }
	        else {
	            return;
	        }
	
	        moment[field] = function (format, index) {
	            var i, getter,
	                method = moment.fn._lang[field],
	                results = [];
	
	            if (typeof format === 'number') {
	                index = format;
	                format = undefined;
	            }
	
	            getter = function (i) {
	                var m = moment().utc().set(setter, i);
	                return method.call(moment.fn._lang, m, format || '');
	            };
	
	            if (index != null) {
	                return getter(index);
	            }
	            else {
	                for (i = 0; i < count; i++) {
	                    results.push(getter(i));
	                }
	                return results;
	            }
	        };
	    }
	
	    function toInt(argumentForCoercion) {
	        var coercedNumber = +argumentForCoercion,
	            value = 0;
	
	        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	            if (coercedNumber >= 0) {
	                value = Math.floor(coercedNumber);
	            } else {
	                value = Math.ceil(coercedNumber);
	            }
	        }
	
	        return value;
	    }
	
	    function daysInMonth(year, month) {
	        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	    }
	
	    function daysInYear(year) {
	        return isLeapYear(year) ? 366 : 365;
	    }
	
	    function isLeapYear(year) {
	        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	    }
	
	    function checkOverflow(m) {
	        var overflow;
	        if (m._a && m._pf.overflow === -2) {
	            overflow =
	                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
	                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
	                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
	                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
	                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
	                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
	                -1;
	
	            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	                overflow = DATE;
	            }
	
	            m._pf.overflow = overflow;
	        }
	    }
	
	    function initializeParsingFlags(config) {
	        config._pf = {
	            empty : false,
	            unusedTokens : [],
	            unusedInput : [],
	            overflow : -2,
	            charsLeftOver : 0,
	            nullInput : false,
	            invalidMonth : null,
	            invalidFormat : false,
	            userInvalidated : false,
	            iso: false
	        };
	    }
	
	    function isValid(m) {
	        if (m._isValid == null) {
	            m._isValid = !isNaN(m._d.getTime()) &&
	                m._pf.overflow < 0 &&
	                !m._pf.empty &&
	                !m._pf.invalidMonth &&
	                !m._pf.nullInput &&
	                !m._pf.invalidFormat &&
	                !m._pf.userInvalidated;
	
	            if (m._strict) {
	                m._isValid = m._isValid &&
	                    m._pf.charsLeftOver === 0 &&
	                    m._pf.unusedTokens.length === 0;
	            }
	        }
	        return m._isValid;
	    }
	
	    function normalizeLanguage(key) {
	        return key ? key.toLowerCase().replace('_', '-') : key;
	    }
	
	    // Return a moment from input, that is local/utc/zone equivalent to model.
	    function makeAs(input, model) {
	        return model._isUTC ? moment(input).zone(model._offset || 0) :
	            moment(input).local();
	    }
	
	    /************************************
	        Languages
	    ************************************/
	
	
	    extend(Language.prototype, {
	
	        set : function (config) {
	            var prop, i;
	            for (i in config) {
	                prop = config[i];
	                if (typeof prop === 'function') {
	                    this[i] = prop;
	                } else {
	                    this['_' + i] = prop;
	                }
	            }
	        },
	
	        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
	        months : function (m) {
	            return this._months[m.month()];
	        },
	
	        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
	        monthsShort : function (m) {
	            return this._monthsShort[m.month()];
	        },
	
	        monthsParse : function (monthName) {
	            var i, mom, regex;
	
	            if (!this._monthsParse) {
	                this._monthsParse = [];
	            }
	
	            for (i = 0; i < 12; i++) {
	                // make the regex if we don't have it already
	                if (!this._monthsParse[i]) {
	                    mom = moment.utc([2000, i]);
	                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	                }
	                // test the regex
	                if (this._monthsParse[i].test(monthName)) {
	                    return i;
	                }
	            }
	        },
	
	        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
	        weekdays : function (m) {
	            return this._weekdays[m.day()];
	        },
	
	        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
	        weekdaysShort : function (m) {
	            return this._weekdaysShort[m.day()];
	        },
	
	        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
	        weekdaysMin : function (m) {
	            return this._weekdaysMin[m.day()];
	        },
	
	        weekdaysParse : function (weekdayName) {
	            var i, mom, regex;
	
	            if (!this._weekdaysParse) {
	                this._weekdaysParse = [];
	            }
	
	            for (i = 0; i < 7; i++) {
	                // make the regex if we don't have it already
	                if (!this._weekdaysParse[i]) {
	                    mom = moment([2000, 1]).day(i);
	                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	                }
	                // test the regex
	                if (this._weekdaysParse[i].test(weekdayName)) {
	                    return i;
	                }
	            }
	        },
	
	        _longDateFormat : {
	            LT : "h:mm A",
	            L : "MM/DD/YYYY",
	            LL : "MMMM D YYYY",
	            LLL : "MMMM D YYYY LT",
	            LLLL : "dddd, MMMM D YYYY LT"
	        },
	        longDateFormat : function (key) {
	            var output = this._longDateFormat[key];
	            if (!output && this._longDateFormat[key.toUpperCase()]) {
	                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
	                    return val.slice(1);
	                });
	                this._longDateFormat[key] = output;
	            }
	            return output;
	        },
	
	        isPM : function (input) {
	            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	            // Using charAt should be more compatible.
	            return ((input + '').toLowerCase().charAt(0) === 'p');
	        },
	
	        _meridiemParse : /[ap]\.?m?\.?/i,
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'pm' : 'PM';
	            } else {
	                return isLower ? 'am' : 'AM';
	            }
	        },
	
	        _calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        calendar : function (key, mom) {
	            var output = this._calendar[key];
	            return typeof output === 'function' ? output.apply(mom) : output;
	        },
	
	        _relativeTime : {
	            future : "in %s",
	            past : "%s ago",
	            s : "a few seconds",
	            m : "a minute",
	            mm : "%d minutes",
	            h : "an hour",
	            hh : "%d hours",
	            d : "a day",
	            dd : "%d days",
	            M : "a month",
	            MM : "%d months",
	            y : "a year",
	            yy : "%d years"
	        },
	        relativeTime : function (number, withoutSuffix, string, isFuture) {
	            var output = this._relativeTime[string];
	            return (typeof output === 'function') ?
	                output(number, withoutSuffix, string, isFuture) :
	                output.replace(/%d/i, number);
	        },
	        pastFuture : function (diff, output) {
	            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
	        },
	
	        ordinal : function (number) {
	            return this._ordinal.replace("%d", number);
	        },
	        _ordinal : "%d",
	
	        preparse : function (string) {
	            return string;
	        },
	
	        postformat : function (string) {
	            return string;
	        },
	
	        week : function (mom) {
	            return weekOfYear(mom, this._week.dow, this._week.doy).week;
	        },
	
	        _week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        },
	
	        _invalidDate: 'Invalid date',
	        invalidDate: function () {
	            return this._invalidDate;
	        }
	    });
	
	    // Loads a language definition into the `languages` cache.  The function
	    // takes a key and optionally values.  If not in the browser and no values
	    // are provided, it will load the language file module.  As a convenience,
	    // this function also returns the language values.
	    function loadLang(key, values) {
	        values.abbr = key;
	        if (!languages[key]) {
	            languages[key] = new Language();
	        }
	        languages[key].set(values);
	        return languages[key];
	    }
	
	    // Remove a language from the `languages` cache. Mostly useful in tests.
	    function unloadLang(key) {
	        delete languages[key];
	    }
	
	    // Determines which language definition to use and returns it.
	    //
	    // With no parameters, it will return the global language.  If you
	    // pass in a language key, such as 'en', it will return the
	    // definition for 'en', so long as 'en' has already been loaded using
	    // moment.lang.
	    function getLangDefinition(key) {
	        var i = 0, j, lang, next, split,
	            get = function (k) {
	                if (!languages[k] && hasModule) {
	                    try {
	                        require('./lang/' + k);
	                    } catch (e) { }
	                }
	                return languages[k];
	            };
	
	        if (!key) {
	            return moment.fn._lang;
	        }
	
	        if (!isArray(key)) {
	            //short-circuit everything else
	            lang = get(key);
	            if (lang) {
	                return lang;
	            }
	            key = [key];
	        }
	
	        //pick the language from the array
	        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	        while (i < key.length) {
	            split = normalizeLanguage(key[i]).split('-');
	            j = split.length;
	            next = normalizeLanguage(key[i + 1]);
	            next = next ? next.split('-') : null;
	            while (j > 0) {
	                lang = get(split.slice(0, j).join('-'));
	                if (lang) {
	                    return lang;
	                }
	                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                    //the next array item is better than a shallower substring of this one
	                    break;
	                }
	                j--;
	            }
	            i++;
	        }
	        return moment.fn._lang;
	    }
	
	    /************************************
	        Formatting
	    ************************************/
	
	
	    function removeFormattingTokens(input) {
	        if (input.match(/\[[\s\S]/)) {
	            return input.replace(/^\[|\]$/g, "");
	        }
	        return input.replace(/\\/g, "");
	    }
	
	    function makeFormatFunction(format) {
	        var array = format.match(formattingTokens), i, length;
	
	        for (i = 0, length = array.length; i < length; i++) {
	            if (formatTokenFunctions[array[i]]) {
	                array[i] = formatTokenFunctions[array[i]];
	            } else {
	                array[i] = removeFormattingTokens(array[i]);
	            }
	        }
	
	        return function (mom) {
	            var output = "";
	            for (i = 0; i < length; i++) {
	                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
	            }
	            return output;
	        };
	    }
	
	    // format date using native date object
	    function formatMoment(m, format) {
	
	        if (!m.isValid()) {
	            return m.lang().invalidDate();
	        }
	
	        format = expandFormat(format, m.lang());
	
	        if (!formatFunctions[format]) {
	            formatFunctions[format] = makeFormatFunction(format);
	        }
	
	        return formatFunctions[format](m);
	    }
	
	    function expandFormat(format, lang) {
	        var i = 5;
	
	        function replaceLongDateFormatTokens(input) {
	            return lang.longDateFormat(input) || input;
	        }
	
	        localFormattingTokens.lastIndex = 0;
	        while (i >= 0 && localFormattingTokens.test(format)) {
	            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	            localFormattingTokens.lastIndex = 0;
	            i -= 1;
	        }
	
	        return format;
	    }
	
	
	    /************************************
	        Parsing
	    ************************************/
	
	
	    // get the regex to find the next token
	    function getParseRegexForToken(token, config) {
	        var a, strict = config._strict;
	        switch (token) {
	        case 'DDDD':
	            return parseTokenThreeDigits;
	        case 'YYYY':
	        case 'GGGG':
	        case 'gggg':
	            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
	        case 'YYYYYY':
	        case 'YYYYY':
	        case 'GGGGG':
	        case 'ggggg':
	            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
	        case 'S':
	            if (strict) { return parseTokenOneDigit; }
	            /* falls through */
	        case 'SS':
	            if (strict) { return parseTokenTwoDigits; }
	            /* falls through */
	        case 'SSS':
	        case 'DDD':
	            return strict ? parseTokenThreeDigits : parseTokenOneToThreeDigits;
	        case 'MMM':
	        case 'MMMM':
	        case 'dd':
	        case 'ddd':
	        case 'dddd':
	            return parseTokenWord;
	        case 'a':
	        case 'A':
	            return getLangDefinition(config._l)._meridiemParse;
	        case 'X':
	            return parseTokenTimestampMs;
	        case 'Z':
	        case 'ZZ':
	            return parseTokenTimezone;
	        case 'T':
	            return parseTokenT;
	        case 'SSSS':
	            return parseTokenDigits;
	        case 'MM':
	        case 'DD':
	        case 'YY':
	        case 'GG':
	        case 'gg':
	        case 'HH':
	        case 'hh':
	        case 'mm':
	        case 'ss':
	        case 'ww':
	        case 'WW':
	            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
	        case 'M':
	        case 'D':
	        case 'd':
	        case 'H':
	        case 'h':
	        case 'm':
	        case 's':
	        case 'w':
	        case 'W':
	        case 'e':
	        case 'E':
	            return strict ? parseTokenOneDigit : parseTokenOneOrTwoDigits;
	        default :
	            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
	            return a;
	        }
	    }
	
	    function timezoneMinutesFromString(string) {
	        string = string || "";
	        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
	            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
	            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
	            minutes = +(parts[1] * 60) + toInt(parts[2]);
	
	        return parts[0] === '+' ? -minutes : minutes;
	    }
	
	    // function to convert string input to date
	    function addTimeToArrayFromToken(token, input, config) {
	        var a, datePartArray = config._a;
	
	        switch (token) {
	        // MONTH
	        case 'M' : // fall through to MM
	        case 'MM' :
	            if (input != null) {
	                datePartArray[MONTH] = toInt(input) - 1;
	            }
	            break;
	        case 'MMM' : // fall through to MMMM
	        case 'MMMM' :
	            a = getLangDefinition(config._l).monthsParse(input);
	            // if we didn't find a month name, mark the date as invalid.
	            if (a != null) {
	                datePartArray[MONTH] = a;
	            } else {
	                config._pf.invalidMonth = input;
	            }
	            break;
	        // DAY OF MONTH
	        case 'D' : // fall through to DD
	        case 'DD' :
	            if (input != null) {
	                datePartArray[DATE] = toInt(input);
	            }
	            break;
	        // DAY OF YEAR
	        case 'DDD' : // fall through to DDDD
	        case 'DDDD' :
	            if (input != null) {
	                config._dayOfYear = toInt(input);
	            }
	
	            break;
	        // YEAR
	        case 'YY' :
	            datePartArray[YEAR] = toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	            break;
	        case 'YYYY' :
	        case 'YYYYY' :
	        case 'YYYYYY' :
	            datePartArray[YEAR] = toInt(input);
	            break;
	        // AM / PM
	        case 'a' : // fall through to A
	        case 'A' :
	            config._isPm = getLangDefinition(config._l).isPM(input);
	            break;
	        // 24 HOUR
	        case 'H' : // fall through to hh
	        case 'HH' : // fall through to hh
	        case 'h' : // fall through to hh
	        case 'hh' :
	            datePartArray[HOUR] = toInt(input);
	            break;
	        // MINUTE
	        case 'm' : // fall through to mm
	        case 'mm' :
	            datePartArray[MINUTE] = toInt(input);
	            break;
	        // SECOND
	        case 's' : // fall through to ss
	        case 'ss' :
	            datePartArray[SECOND] = toInt(input);
	            break;
	        // MILLISECOND
	        case 'S' :
	        case 'SS' :
	        case 'SSS' :
	        case 'SSSS' :
	            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
	            break;
	        // UNIX TIMESTAMP WITH MS
	        case 'X':
	            config._d = new Date(parseFloat(input) * 1000);
	            break;
	        // TIMEZONE
	        case 'Z' : // fall through to ZZ
	        case 'ZZ' :
	            config._useUTC = true;
	            config._tzm = timezoneMinutesFromString(input);
	            break;
	        case 'w':
	        case 'ww':
	        case 'W':
	        case 'WW':
	        case 'd':
	        case 'dd':
	        case 'ddd':
	        case 'dddd':
	        case 'e':
	        case 'E':
	            token = token.substr(0, 1);
	            /* falls through */
	        case 'gg':
	        case 'gggg':
	        case 'GG':
	        case 'GGGG':
	        case 'GGGGG':
	            token = token.substr(0, 2);
	            if (input) {
	                config._w = config._w || {};
	                config._w[token] = input;
	            }
	            break;
	        }
	    }
	
	    // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]
	    function dateFromConfig(config) {
	        var i, date, input = [], currentDate,
	            yearToUse, fixYear, w, temp, lang, weekday, week;
	
	        if (config._d) {
	            return;
	        }
	
	        currentDate = currentDateArray(config);
	
	        //compute day of the year from weeks and weekdays
	        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	            fixYear = function (val) {
	                var int_val = parseInt(val, 10);
	                return val ?
	                  (val.length < 3 ? (int_val > 68 ? 1900 + int_val : 2000 + int_val) : int_val) :
	                  (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
	            };
	
	            w = config._w;
	            if (w.GG != null || w.W != null || w.E != null) {
	                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
	            }
	            else {
	                lang = getLangDefinition(config._l);
	                weekday = w.d != null ?  parseWeekday(w.d, lang) :
	                  (w.e != null ?  parseInt(w.e, 10) + lang._week.dow : 0);
	
	                week = parseInt(w.w, 10) || 1;
	
	                //if we're parsing 'd', then the low day numbers may be next week
	                if (w.d != null && weekday < lang._week.dow) {
	                    week++;
	                }
	
	                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
	            }
	
	            config._a[YEAR] = temp.year;
	            config._dayOfYear = temp.dayOfYear;
	        }
	
	        //if the day of the year is set, figure out what it is
	        if (config._dayOfYear) {
	            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];
	
	            if (config._dayOfYear > daysInYear(yearToUse)) {
	                config._pf._overflowDayOfYear = true;
	            }
	
	            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
	            config._a[MONTH] = date.getUTCMonth();
	            config._a[DATE] = date.getUTCDate();
	        }
	
	        // Default to current date.
	        // * if no year, month, day of month are given, default to today
	        // * if day of month is given, default month and year
	        // * if month is given, default only year
	        // * if year is given, don't default anything
	        for (i = 0; i < 3 && config._a[i] == null; ++i) {
	            config._a[i] = input[i] = currentDate[i];
	        }
	
	        // Zero out whatever was not defaulted, including time
	        for (; i < 7; i++) {
	            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	        }
	
	        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
	        input[HOUR] += toInt((config._tzm || 0) / 60);
	        input[MINUTE] += toInt((config._tzm || 0) % 60);
	
	        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
	    }
	
	    function dateFromObject(config) {
	        var normalizedInput;
	
	        if (config._d) {
	            return;
	        }
	
	        normalizedInput = normalizeObjectUnits(config._i);
	        config._a = [
	            normalizedInput.year,
	            normalizedInput.month,
	            normalizedInput.day,
	            normalizedInput.hour,
	            normalizedInput.minute,
	            normalizedInput.second,
	            normalizedInput.millisecond
	        ];
	
	        dateFromConfig(config);
	    }
	
	    function currentDateArray(config) {
	        var now = new Date();
	        if (config._useUTC) {
	            return [
	                now.getUTCFullYear(),
	                now.getUTCMonth(),
	                now.getUTCDate()
	            ];
	        } else {
	            return [now.getFullYear(), now.getMonth(), now.getDate()];
	        }
	    }
	
	    // date from string and format string
	    function makeDateFromStringAndFormat(config) {
	
	        config._a = [];
	        config._pf.empty = true;
	
	        // This array is used to make a Date, either with `new Date` or `Date.UTC`
	        var lang = getLangDefinition(config._l),
	            string = '' + config._i,
	            i, parsedInput, tokens, token, skipped,
	            stringLength = string.length,
	            totalParsedInputLength = 0;
	
	        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];
	
	        for (i = 0; i < tokens.length; i++) {
	            token = tokens[i];
	            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	            if (parsedInput) {
	                skipped = string.substr(0, string.indexOf(parsedInput));
	                if (skipped.length > 0) {
	                    config._pf.unusedInput.push(skipped);
	                }
	                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	                totalParsedInputLength += parsedInput.length;
	            }
	            // don't parse if it's not a known token
	            if (formatTokenFunctions[token]) {
	                if (parsedInput) {
	                    config._pf.empty = false;
	                }
	                else {
	                    config._pf.unusedTokens.push(token);
	                }
	                addTimeToArrayFromToken(token, parsedInput, config);
	            }
	            else if (config._strict && !parsedInput) {
	                config._pf.unusedTokens.push(token);
	            }
	        }
	
	        // add remaining unparsed input length to the string
	        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
	        if (string.length > 0) {
	            config._pf.unusedInput.push(string);
	        }
	
	        // handle am pm
	        if (config._isPm && config._a[HOUR] < 12) {
	            config._a[HOUR] += 12;
	        }
	        // if is 12 am, change hours to 0
	        if (config._isPm === false && config._a[HOUR] === 12) {
	            config._a[HOUR] = 0;
	        }
	
	        dateFromConfig(config);
	        checkOverflow(config);
	    }
	
	    function unescapeFormat(s) {
	        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	            return p1 || p2 || p3 || p4;
	        });
	    }
	
	    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	    function regexpEscape(s) {
	        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }
	
	    // date from string and array of format strings
	    function makeDateFromStringAndArray(config) {
	        var tempConfig,
	            bestMoment,
	
	            scoreToBeat,
	            i,
	            currentScore;
	
	        if (config._f.length === 0) {
	            config._pf.invalidFormat = true;
	            config._d = new Date(NaN);
	            return;
	        }
	
	        for (i = 0; i < config._f.length; i++) {
	            currentScore = 0;
	            tempConfig = extend({}, config);
	            initializeParsingFlags(tempConfig);
	            tempConfig._f = config._f[i];
	            makeDateFromStringAndFormat(tempConfig);
	
	            if (!isValid(tempConfig)) {
	                continue;
	            }
	
	            // if there is any input that was not parsed add a penalty for that format
	            currentScore += tempConfig._pf.charsLeftOver;
	
	            //or tokens
	            currentScore += tempConfig._pf.unusedTokens.length * 10;
	
	            tempConfig._pf.score = currentScore;
	
	            if (scoreToBeat == null || currentScore < scoreToBeat) {
	                scoreToBeat = currentScore;
	                bestMoment = tempConfig;
	            }
	        }
	
	        extend(config, bestMoment || tempConfig);
	    }
	
	    // date from iso format
	    function makeDateFromString(config) {
	        var i,
	            string = config._i,
	            match = isoRegex.exec(string);
	
	        if (match) {
	            config._pf.iso = true;
	            for (i = 4; i > 0; i--) {
	                if (match[i]) {
	                    // match[5] should be "T" or undefined
	                    config._f = isoDates[i - 1] + (match[6] || " ");
	                    break;
	                }
	            }
	            for (i = 0; i < 4; i++) {
	                if (isoTimes[i][1].exec(string)) {
	                    config._f += isoTimes[i][0];
	                    break;
	                }
	            }
	            if (string.match(parseTokenTimezone)) {
	                config._f += "Z";
	            }
	            makeDateFromStringAndFormat(config);
	        }
	        else {
	            config._d = new Date(string);
	        }
	    }
	
	    function makeDateFromInput(config) {
	        var input = config._i,
	            matched = aspNetJsonRegex.exec(input);
	
	        if (input === undefined) {
	            config._d = new Date();
	        } else if (matched) {
	            config._d = new Date(+matched[1]);
	        } else if (typeof input === 'string') {
	            makeDateFromString(config);
	        } else if (isArray(input)) {
	            config._a = input.slice(0);
	            dateFromConfig(config);
	        } else if (isDate(input)) {
	            config._d = new Date(+input);
	        } else if (typeof(input) === 'object') {
	            dateFromObject(config);
	        } else {
	            config._d = new Date(input);
	        }
	    }
	
	    function makeDate(y, m, d, h, M, s, ms) {
	        //can't just apply() to create a date:
	        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
	        var date = new Date(y, m, d, h, M, s, ms);
	
	        //the date constructor doesn't accept years < 1970
	        if (y < 1970) {
	            date.setFullYear(y);
	        }
	        return date;
	    }
	
	    function makeUTCDate(y) {
	        var date = new Date(Date.UTC.apply(null, arguments));
	        if (y < 1970) {
	            date.setUTCFullYear(y);
	        }
	        return date;
	    }
	
	    function parseWeekday(input, language) {
	        if (typeof input === 'string') {
	            if (!isNaN(input)) {
	                input = parseInt(input, 10);
	            }
	            else {
	                input = language.weekdaysParse(input);
	                if (typeof input !== 'number') {
	                    return null;
	                }
	            }
	        }
	        return input;
	    }
	
	    /************************************
	        Relative Time
	    ************************************/
	
	
	    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
	        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }
	
	    function relativeTime(milliseconds, withoutSuffix, lang) {
	        var seconds = round(Math.abs(milliseconds) / 1000),
	            minutes = round(seconds / 60),
	            hours = round(minutes / 60),
	            days = round(hours / 24),
	            years = round(days / 365),
	            args = seconds < 45 && ['s', seconds] ||
	                minutes === 1 && ['m'] ||
	                minutes < 45 && ['mm', minutes] ||
	                hours === 1 && ['h'] ||
	                hours < 22 && ['hh', hours] ||
	                days === 1 && ['d'] ||
	                days <= 25 && ['dd', days] ||
	                days <= 45 && ['M'] ||
	                days < 345 && ['MM', round(days / 30)] ||
	                years === 1 && ['y'] || ['yy', years];
	        args[2] = withoutSuffix;
	        args[3] = milliseconds > 0;
	        args[4] = lang;
	        return substituteTimeAgo.apply({}, args);
	    }
	
	
	    /************************************
	        Week of Year
	    ************************************/
	
	
	    // firstDayOfWeek       0 = sun, 6 = sat
	    //                      the day of the week that starts the week
	    //                      (usually sunday or monday)
	    // firstDayOfWeekOfYear 0 = sun, 6 = sat
	    //                      the first week is the week that contains the first
	    //                      of this day of the week
	    //                      (eg. ISO weeks use thursday (4))
	    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
	        var end = firstDayOfWeekOfYear - firstDayOfWeek,
	            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
	            adjustedMoment;
	
	
	        if (daysToDayOfWeek > end) {
	            daysToDayOfWeek -= 7;
	        }
	
	        if (daysToDayOfWeek < end - 7) {
	            daysToDayOfWeek += 7;
	        }
	
	        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
	        return {
	            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
	            year: adjustedMoment.year()
	        };
	    }
	
	    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
	        // The only solid way to create an iso date from year is to use
	        // a string format (Date.UTC handles only years > 1900). Don't ask why
	        // it doesn't need Z at the end.
	        var d = new Date(leftZeroFill(year, 6, true) + '-01-01').getUTCDay(),
	            daysToAdd, dayOfYear;
	
	        weekday = weekday != null ? weekday : firstDayOfWeek;
	        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0);
	        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
	
	        return {
	            year: dayOfYear > 0 ? year : year - 1,
	            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
	        };
	    }
	
	    /************************************
	        Top Level Functions
	    ************************************/
	
	    function makeMoment(config) {
	        var input = config._i,
	            format = config._f;
	
	        if (typeof config._pf === 'undefined') {
	            initializeParsingFlags(config);
	        }
	
	        if (input === null) {
	            return moment.invalid({nullInput: true});
	        }
	
	        if (typeof input === 'string') {
	            config._i = input = getLangDefinition().preparse(input);
	        }
	
	        if (moment.isMoment(input)) {
	            config = extend({}, input);
	
	            config._d = new Date(+input._d);
	        } else if (format) {
	            if (isArray(format)) {
	                makeDateFromStringAndArray(config);
	            } else {
	                makeDateFromStringAndFormat(config);
	            }
	        } else {
	            makeDateFromInput(config);
	        }
	
	        return new Moment(config);
	    }
	
	    moment = function (input, format, lang, strict) {
	        if (typeof(lang) === "boolean") {
	            strict = lang;
	            lang = undefined;
	        }
	        return makeMoment({
	            _i : input,
	            _f : format,
	            _l : lang,
	            _strict : strict,
	            _isUTC : false
	        });
	    };
	
	    // creating with utc
	    moment.utc = function (input, format, lang, strict) {
	        var m;
	
	        if (typeof(lang) === "boolean") {
	            strict = lang;
	            lang = undefined;
	        }
	        m = makeMoment({
	            _useUTC : true,
	            _isUTC : true,
	            _l : lang,
	            _i : input,
	            _f : format,
	            _strict : strict
	        }).utc();
	
	        return m;
	    };
	
	    // creating with unix timestamp (in seconds)
	    moment.unix = function (input) {
	        return moment(input * 1000);
	    };
	
	    // duration
	    moment.duration = function (input, key) {
	        var duration = input,
	            // matching against regexp is expensive, do it on demand
	            match = null,
	            sign,
	            ret,
	            parseIso;
	
	        if (moment.isDuration(input)) {
	            duration = {
	                ms: input._milliseconds,
	                d: input._days,
	                M: input._months
	            };
	        } else if (typeof input === 'number') {
	            duration = {};
	            if (key) {
	                duration[key] = input;
	            } else {
	                duration.milliseconds = input;
	            }
	        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
	            sign = (match[1] === "-") ? -1 : 1;
	            duration = {
	                y: 0,
	                d: toInt(match[DATE]) * sign,
	                h: toInt(match[HOUR]) * sign,
	                m: toInt(match[MINUTE]) * sign,
	                s: toInt(match[SECOND]) * sign,
	                ms: toInt(match[MILLISECOND]) * sign
	            };
	        } else if (!!(match = isoDurationRegex.exec(input))) {
	            sign = (match[1] === "-") ? -1 : 1;
	            parseIso = function (inp) {
	                // We'd normally use ~~inp for this, but unfortunately it also
	                // converts floats to ints.
	                // inp may be undefined, so careful calling replace on it.
	                var res = inp && parseFloat(inp.replace(',', '.'));
	                // apply sign while we're at it
	                return (isNaN(res) ? 0 : res) * sign;
	            };
	            duration = {
	                y: parseIso(match[2]),
	                M: parseIso(match[3]),
	                d: parseIso(match[4]),
	                h: parseIso(match[5]),
	                m: parseIso(match[6]),
	                s: parseIso(match[7]),
	                w: parseIso(match[8])
	            };
	        }
	
	        ret = new Duration(duration);
	
	        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
	            ret._lang = input._lang;
	        }
	
	        return ret;
	    };
	
	    // version number
	    moment.version = VERSION;
	
	    // default format
	    moment.defaultFormat = isoFormat;
	
	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.
	    moment.updateOffset = function () {};
	
	    // This function will load languages and then set the global language.  If
	    // no arguments are passed in, it will simply return the current global
	    // language key.
	    moment.lang = function (key, values) {
	        var r;
	        if (!key) {
	            return moment.fn._lang._abbr;
	        }
	        if (values) {
	            loadLang(normalizeLanguage(key), values);
	        } else if (values === null) {
	            unloadLang(key);
	            key = 'en';
	        } else if (!languages[key]) {
	            getLangDefinition(key);
	        }
	        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
	        return r._abbr;
	    };
	
	    // returns language data
	    moment.langData = function (key) {
	        if (key && key._lang && key._lang._abbr) {
	            key = key._lang._abbr;
	        }
	        return getLangDefinition(key);
	    };
	
	    // compare moment object
	    moment.isMoment = function (obj) {
	        return obj instanceof Moment;
	    };
	
	    // for typechecking Duration objects
	    moment.isDuration = function (obj) {
	        return obj instanceof Duration;
	    };
	
	    for (i = lists.length - 1; i >= 0; --i) {
	        makeList(lists[i]);
	    }
	
	    moment.normalizeUnits = function (units) {
	        return normalizeUnits(units);
	    };
	
	    moment.invalid = function (flags) {
	        var m = moment.utc(NaN);
	        if (flags != null) {
	            extend(m._pf, flags);
	        }
	        else {
	            m._pf.userInvalidated = true;
	        }
	
	        return m;
	    };
	
	    moment.parseZone = function (input) {
	        return moment(input).parseZone();
	    };
	
	    /************************************
	        Moment Prototype
	    ************************************/
	
	
	    extend(moment.fn = Moment.prototype, {
	
	        clone : function () {
	            return moment(this);
	        },
	
	        valueOf : function () {
	            return +this._d + ((this._offset || 0) * 60000);
	        },
	
	        unix : function () {
	            return Math.floor(+this / 1000);
	        },
	
	        toString : function () {
	            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
	        },
	
	        toDate : function () {
	            return this._offset ? new Date(+this) : this._d;
	        },
	
	        toISOString : function () {
	            var m = moment(this).utc();
	            if (0 < m.year() && m.year() <= 9999) {
	                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	            } else {
	                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	            }
	        },
	
	        toArray : function () {
	            var m = this;
	            return [
	                m.year(),
	                m.month(),
	                m.date(),
	                m.hours(),
	                m.minutes(),
	                m.seconds(),
	                m.milliseconds()
	            ];
	        },
	
	        isValid : function () {
	            return isValid(this);
	        },
	
	        isDSTShifted : function () {
	
	            if (this._a) {
	                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
	            }
	
	            return false;
	        },
	
	        parsingFlags : function () {
	            return extend({}, this._pf);
	        },
	
	        invalidAt: function () {
	            return this._pf.overflow;
	        },
	
	        utc : function () {
	            return this.zone(0);
	        },
	
	        local : function () {
	            this.zone(0);
	            this._isUTC = false;
	            return this;
	        },
	
	        format : function (inputString) {
	            var output = formatMoment(this, inputString || moment.defaultFormat);
	            return this.lang().postformat(output);
	        },
	
	        add : function (input, val) {
	            var dur;
	            // switch args to support add('s', 1) and add(1, 's')
	            if (typeof input === 'string') {
	                dur = moment.duration(+val, input);
	            } else {
	                dur = moment.duration(input, val);
	            }
	            addOrSubtractDurationFromMoment(this, dur, 1);
	            return this;
	        },
	
	        subtract : function (input, val) {
	            var dur;
	            // switch args to support subtract('s', 1) and subtract(1, 's')
	            if (typeof input === 'string') {
	                dur = moment.duration(+val, input);
	            } else {
	                dur = moment.duration(input, val);
	            }
	            addOrSubtractDurationFromMoment(this, dur, -1);
	            return this;
	        },
	
	        diff : function (input, units, asFloat) {
	            var that = makeAs(input, this),
	                zoneDiff = (this.zone() - that.zone()) * 6e4,
	                diff, output;
	
	            units = normalizeUnits(units);
	
	            if (units === 'year' || units === 'month') {
	                // average number of days in the months in the given dates
	                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
	                // difference in months
	                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
	                // adjust by taking difference in days, average number of days
	                // and dst in the given months.
	                output += ((this - moment(this).startOf('month')) -
	                        (that - moment(that).startOf('month'))) / diff;
	                // same as above but with zones, to negate all dst
	                output -= ((this.zone() - moment(this).startOf('month').zone()) -
	                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
	                if (units === 'year') {
	                    output = output / 12;
	                }
	            } else {
	                diff = (this - that);
	                output = units === 'second' ? diff / 1e3 : // 1000
	                    units === 'minute' ? diff / 6e4 : // 1000 * 60
	                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
	                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	                    diff;
	            }
	            return asFloat ? output : absRound(output);
	        },
	
	        from : function (time, withoutSuffix) {
	            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
	        },
	
	        fromNow : function (withoutSuffix) {
	            return this.from(moment(), withoutSuffix);
	        },
	
	        calendar : function () {
	            // We want to compare the start of today, vs this.
	            // Getting start-of-today depends on whether we're zone'd or not.
	            var sod = makeAs(moment(), this).startOf('day'),
	                diff = this.diff(sod, 'days', true),
	                format = diff < -6 ? 'sameElse' :
	                    diff < -1 ? 'lastWeek' :
	                    diff < 0 ? 'lastDay' :
	                    diff < 1 ? 'sameDay' :
	                    diff < 2 ? 'nextDay' :
	                    diff < 7 ? 'nextWeek' : 'sameElse';
	            return this.format(this.lang().calendar(format, this));
	        },
	
	        isLeapYear : function () {
	            return isLeapYear(this.year());
	        },
	
	        isDST : function () {
	            return (this.zone() < this.clone().month(0).zone() ||
	                this.zone() < this.clone().month(5).zone());
	        },
	
	        day : function (input) {
	            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	            if (input != null) {
	                input = parseWeekday(input, this.lang());
	                return this.add({ d : input - day });
	            } else {
	                return day;
	            }
	        },
	
	        month : function (input) {
	            var utc = this._isUTC ? 'UTC' : '',
	                dayOfMonth;
	
	            if (input != null) {
	                if (typeof input === 'string') {
	                    input = this.lang().monthsParse(input);
	                    if (typeof input !== 'number') {
	                        return this;
	                    }
	                }
	
	                dayOfMonth = this.date();
	                this.date(1);
	                this._d['set' + utc + 'Month'](input);
	                this.date(Math.min(dayOfMonth, this.daysInMonth()));
	
	                moment.updateOffset(this);
	                return this;
	            } else {
	                return this._d['get' + utc + 'Month']();
	            }
	        },
	
	        startOf: function (units) {
	            units = normalizeUnits(units);
	            // the following switch intentionally omits break keywords
	            // to utilize falling through the cases.
	            switch (units) {
	            case 'year':
	                this.month(0);
	                /* falls through */
	            case 'month':
	                this.date(1);
	                /* falls through */
	            case 'week':
	            case 'isoWeek':
	            case 'day':
	                this.hours(0);
	                /* falls through */
	            case 'hour':
	                this.minutes(0);
	                /* falls through */
	            case 'minute':
	                this.seconds(0);
	                /* falls through */
	            case 'second':
	                this.milliseconds(0);
	                /* falls through */
	            }
	
	            // weeks are a special case
	            if (units === 'week') {
	                this.weekday(0);
	            } else if (units === 'isoWeek') {
	                this.isoWeekday(1);
	            }
	
	            return this;
	        },
	
	        endOf: function (units) {
	            units = normalizeUnits(units);
	            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
	        },
	
	        isAfter: function (input, units) {
	            units = typeof units !== 'undefined' ? units : 'millisecond';
	            return +this.clone().startOf(units) > +moment(input).startOf(units);
	        },
	
	        isBefore: function (input, units) {
	            units = typeof units !== 'undefined' ? units : 'millisecond';
	            return +this.clone().startOf(units) < +moment(input).startOf(units);
	        },
	
	        isSame: function (input, units) {
	            units = units || 'ms';
	            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
	        },
	
	        min: function (other) {
	            other = moment.apply(null, arguments);
	            return other < this ? this : other;
	        },
	
	        max: function (other) {
	            other = moment.apply(null, arguments);
	            return other > this ? this : other;
	        },
	
	        zone : function (input) {
	            var offset = this._offset || 0;
	            if (input != null) {
	                if (typeof input === "string") {
	                    input = timezoneMinutesFromString(input);
	                }
	                if (Math.abs(input) < 16) {
	                    input = input * 60;
	                }
	                this._offset = input;
	                this._isUTC = true;
	                if (offset !== input) {
	                    addOrSubtractDurationFromMoment(this, moment.duration(offset - input, 'm'), 1, true);
	                }
	            } else {
	                return this._isUTC ? offset : this._d.getTimezoneOffset();
	            }
	            return this;
	        },
	
	        zoneAbbr : function () {
	            return this._isUTC ? "UTC" : "";
	        },
	
	        zoneName : function () {
	            return this._isUTC ? "Coordinated Universal Time" : "";
	        },
	
	        parseZone : function () {
	            if (this._tzm) {
	                this.zone(this._tzm);
	            } else if (typeof this._i === 'string') {
	                this.zone(this._i);
	            }
	            return this;
	        },
	
	        hasAlignedHourOffset : function (input) {
	            if (!input) {
	                input = 0;
	            }
	            else {
	                input = moment(input).zone();
	            }
	
	            return (this.zone() - input) % 60 === 0;
	        },
	
	        daysInMonth : function () {
	            return daysInMonth(this.year(), this.month());
	        },
	
	        dayOfYear : function (input) {
	            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
	            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
	        },
	
	        quarter : function () {
	            return Math.ceil((this.month() + 1.0) / 3.0);
	        },
	
	        weekYear : function (input) {
	            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
	            return input == null ? year : this.add("y", (input - year));
	        },
	
	        isoWeekYear : function (input) {
	            var year = weekOfYear(this, 1, 4).year;
	            return input == null ? year : this.add("y", (input - year));
	        },
	
	        week : function (input) {
	            var week = this.lang().week(this);
	            return input == null ? week : this.add("d", (input - week) * 7);
	        },
	
	        isoWeek : function (input) {
	            var week = weekOfYear(this, 1, 4).week;
	            return input == null ? week : this.add("d", (input - week) * 7);
	        },
	
	        weekday : function (input) {
	            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
	            return input == null ? weekday : this.add("d", input - weekday);
	        },
	
	        isoWeekday : function (input) {
	            // behaves the same as moment#day except
	            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	            // as a setter, sunday should belong to the previous week.
	            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
	        },
	
	        get : function (units) {
	            units = normalizeUnits(units);
	            return this[units]();
	        },
	
	        set : function (units, value) {
	            units = normalizeUnits(units);
	            if (typeof this[units] === 'function') {
	                this[units](value);
	            }
	            return this;
	        },
	
	        // If passed a language key, it will set the language for this
	        // instance.  Otherwise, it will return the language configuration
	        // variables for this instance.
	        lang : function (key) {
	            if (key === undefined) {
	                return this._lang;
	            } else {
	                this._lang = getLangDefinition(key);
	                return this;
	            }
	        }
	    });
	
	    // helper for adding shortcuts
	    function makeGetterAndSetter(name, key) {
	        moment.fn[name] = moment.fn[name + 's'] = function (input) {
	            var utc = this._isUTC ? 'UTC' : '';
	            if (input != null) {
	                this._d['set' + utc + key](input);
	                moment.updateOffset(this);
	                return this;
	            } else {
	                return this._d['get' + utc + key]();
	            }
	        };
	    }
	
	    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
	    for (i = 0; i < proxyGettersAndSetters.length; i ++) {
	        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ''), proxyGettersAndSetters[i]);
	    }
	
	    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
	    makeGetterAndSetter('year', 'FullYear');
	
	    // add plural methods
	    moment.fn.days = moment.fn.day;
	    moment.fn.months = moment.fn.month;
	    moment.fn.weeks = moment.fn.week;
	    moment.fn.isoWeeks = moment.fn.isoWeek;
	
	    // add aliased format methods
	    moment.fn.toJSON = moment.fn.toISOString;
	
	    /************************************
	        Duration Prototype
	    ************************************/
	
	
	    extend(moment.duration.fn = Duration.prototype, {
	
	        _bubble : function () {
	            var milliseconds = this._milliseconds,
	                days = this._days,
	                months = this._months,
	                data = this._data,
	                seconds, minutes, hours, years;
	
	            // The following code bubbles up values, see the tests for
	            // examples of what that means.
	            data.milliseconds = milliseconds % 1000;
	
	            seconds = absRound(milliseconds / 1000);
	            data.seconds = seconds % 60;
	
	            minutes = absRound(seconds / 60);
	            data.minutes = minutes % 60;
	
	            hours = absRound(minutes / 60);
	            data.hours = hours % 24;
	
	            days += absRound(hours / 24);
	            data.days = days % 30;
	
	            months += absRound(days / 30);
	            data.months = months % 12;
	
	            years = absRound(months / 12);
	            data.years = years;
	        },
	
	        weeks : function () {
	            return absRound(this.days() / 7);
	        },
	
	        valueOf : function () {
	            return this._milliseconds +
	              this._days * 864e5 +
	              (this._months % 12) * 2592e6 +
	              toInt(this._months / 12) * 31536e6;
	        },
	
	        humanize : function (withSuffix) {
	            var difference = +this,
	                output = relativeTime(difference, !withSuffix, this.lang());
	
	            if (withSuffix) {
	                output = this.lang().pastFuture(difference, output);
	            }
	
	            return this.lang().postformat(output);
	        },
	
	        add : function (input, val) {
	            // supports only 2.0-style add(1, 's') or add(moment)
	            var dur = moment.duration(input, val);
	
	            this._milliseconds += dur._milliseconds;
	            this._days += dur._days;
	            this._months += dur._months;
	
	            this._bubble();
	
	            return this;
	        },
	
	        subtract : function (input, val) {
	            var dur = moment.duration(input, val);
	
	            this._milliseconds -= dur._milliseconds;
	            this._days -= dur._days;
	            this._months -= dur._months;
	
	            this._bubble();
	
	            return this;
	        },
	
	        get : function (units) {
	            units = normalizeUnits(units);
	            return this[units.toLowerCase() + 's']();
	        },
	
	        as : function (units) {
	            units = normalizeUnits(units);
	            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
	        },
	
	        lang : moment.fn.lang,
	
	        toIsoString : function () {
	            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	            var years = Math.abs(this.years()),
	                months = Math.abs(this.months()),
	                days = Math.abs(this.days()),
	                hours = Math.abs(this.hours()),
	                minutes = Math.abs(this.minutes()),
	                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);
	
	            if (!this.asSeconds()) {
	                // this is the same as C#'s (Noda) and python (isodate)...
	                // but not other JS (goog.date)
	                return 'P0D';
	            }
	
	            return (this.asSeconds() < 0 ? '-' : '') +
	                'P' +
	                (years ? years + 'Y' : '') +
	                (months ? months + 'M' : '') +
	                (days ? days + 'D' : '') +
	                ((hours || minutes || seconds) ? 'T' : '') +
	                (hours ? hours + 'H' : '') +
	                (minutes ? minutes + 'M' : '') +
	                (seconds ? seconds + 'S' : '');
	        }
	    });
	
	    function makeDurationGetter(name) {
	        moment.duration.fn[name] = function () {
	            return this._data[name];
	        };
	    }
	
	    function makeDurationAsGetter(name, factor) {
	        moment.duration.fn['as' + name] = function () {
	            return +this / factor;
	        };
	    }
	
	    for (i in unitMillisecondFactors) {
	        if (unitMillisecondFactors.hasOwnProperty(i)) {
	            makeDurationAsGetter(i, unitMillisecondFactors[i]);
	            makeDurationGetter(i.toLowerCase());
	        }
	    }
	
	    makeDurationAsGetter('Weeks', 6048e5);
	    moment.duration.fn.asMonths = function () {
	        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
	    };
	
	
	    /************************************
	        Default Lang
	    ************************************/
	
	
	    // Set default language, other languages will inherit from English.
	    moment.lang('en', {
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (toInt(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });
	
	    /* EMBED_LANGUAGES */
	
	    /************************************
	        Exposing Moment
	    ************************************/
	
	    function makeGlobal(deprecate) {
	        var warned = false, local_moment = moment;
	        /*global ender:false */
	        if (typeof ender !== 'undefined') {
	            return;
	        }
	        // here, `this` means `window` in the browser, or `global` on the server
	        // add `moment` as a global object via a string identifier,
	        // for Closure Compiler "advanced" mode
	        if (deprecate) {
	            global.moment = function () {
	                if (!warned && console && console.warn) {
	                    warned = true;
	                    console.warn(
	                            "Accessing Moment through the global scope is " +
	                            "deprecated, and will be removed in an upcoming " +
	                            "release.");
	                }
	                return local_moment.apply(null, arguments);
	            };
	            extend(global.moment, local_moment);
	        } else {
	            global['moment'] = moment;
	        }
	    }
	
	    // CommonJS module is defined
	    if (hasModule) {
	        module.exports = moment;
	        makeGlobal(true);
	    } else if (typeof define === "function" && define.amd) {
	        define("moment", function (require, exports, module) {
	            if (module.config && module.config() && module.config().noGlobal !== true) {
	                // If user provided noGlobal, he is aware of global
	                makeGlobal(module.config().noGlobal === undefined);
	            }
	
	            return moment;
	        });
	    } else {
	        makeGlobal();
	    }
	}).call(this);
	

}, '/lib/Cache.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Cache.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Cache.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Cache.js';
	var __dirname = '/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Cache.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Cache, isFunction;
	
	  isFunction = function(obj) {
	    return Object.prototype.toString.call(obj) === '[object Function]';
	  };
	
	  Cache = (function() {
	    Cache.FILES = 'files';
	
	    Cache.TAGS = 'tags';
	
	    Cache.EXPIRE = 'expire';
	
	    Cache.ITEMS = 'items';
	
	    Cache.PRIORITY = 'priority';
	
	    Cache.ALL = 'all';
	
	    Cache.TIME_FORMAT = 'YYYY-MM-DD HH:mm';
	
	    Cache.fs = null;
	
	    Cache.prototype.storage = null;
	
	    Cache.prototype.async = null;
	
	    Cache.prototype.namespace = null;
	
	    function Cache(storage, namespace) {
	      this.storage = storage;
	      this.namespace = namespace;
	      if (!(this.storage instanceof require('./Storage/Storage'))) {
	        throw new Error('Cache: storage must be instance of cache-storage/Storage/Storage');
	      }
	      this.async = this.storage.async;
	      this.storage.cache = this;
	    }
	
	    Cache.mockFs = function(tree, info) {
	      var FS;
	      if (tree == null) {
	        tree = {};
	      }
	      if (info == null) {
	        info = {};
	      }
	      FS = require('fs-mock');
	      Cache.fs = new FS(tree, info);
	      return Cache.fs;
	    };
	
	    Cache.restoreFs = function() {
	      if (typeof window !== 'undefined') {
	        throw new Error('Testing with fs module is not allowed in browser.');
	      }
	      return Cache.fs = require('fs');
	    };
	
	    Cache.getFs = function() {
	      if (Cache.fs === null) {
	        Cache.restoreFs();
	      }
	      return Cache.fs;
	    };
	
	    Cache.prototype.generateKey = function(key) {
	      var ch, hash, i, max, _i;
	      hash = 0;
	      if (key.length === 0) {
	        return hash;
	      }
	      max = key.length - 1;
	      for (i = _i = 0; 0 <= max ? _i <= max : _i >= max; i = 0 <= max ? ++_i : --_i) {
	        ch = key.charCodeAt(i);
	        hash = ((hash << 5) - hash) + ch;
	        hash |= 0;
	      }
	      return hash;
	    };
	
	    Cache.prototype.load = function(key, fallback, fn) {
	      var data,
	        _this = this;
	      if (fallback == null) {
	        fallback = null;
	      }
	      if (fn == null) {
	        fn = null;
	      }
	      if (this.async && arguments.length === 2) {
	        fn = fallback;
	        fallback = null;
	      }
	      if (this.async) {
	        return this.storage.read(this.generateKey(key), function(data) {
	          if (data === null && fallback !== null) {
	            return _this.save(key, fallback, function(data) {
	              return fn(data);
	            });
	          } else {
	            return fn(data);
	          }
	        });
	      } else {
	        data = this.storage.read(this.generateKey(key));
	        if (data === null && fallback !== null) {
	          return this.save(key, fallback);
	        }
	        return data;
	      }
	    };
	
	    Cache.prototype.save = function(key, data, dependencies, fn) {
	      var _this = this;
	      if (dependencies == null) {
	        dependencies = {};
	      }
	      if (fn == null) {
	        fn = null;
	      }
	      if (isFunction(dependencies)) {
	        fn = dependencies;
	        dependencies = {};
	      }
	      key = this.generateKey(key);
	      if (isFunction(data)) {
	        data = data();
	      }
	      if (this.async) {
	        if (data === null) {
	          this.storage.remove(key, function() {
	            return fn(data);
	          });
	        } else {
	          this.storage.parseDependencies(dependencies, function(dependencies) {
	            return _this.storage.write(key, data, dependencies, function() {
	              return fn(data);
	            });
	          });
	        }
	      } else {
	        if (data === null) {
	          this.storage.remove(key);
	        } else {
	          this.storage.write(key, data, this.storage.parseDependencies(dependencies));
	        }
	      }
	      return data;
	    };
	
	    Cache.prototype.remove = function(key, fn) {
	      if (fn == null) {
	        fn = null;
	      }
	      return this.save(key, null, fn);
	    };
	
	    Cache.prototype.clean = function(conditions, fn) {
	      if (fn == null) {
	        fn = null;
	      }
	      this.storage.clean(conditions, fn);
	      return this;
	    };
	
	    return Cache;
	
	  })();
	
	  module.exports = Cache;
	
	}).call(this);
	

}, 'fs-mock/lib/fs.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'fs-mock/lib/fs.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'fs-mock/lib/fs.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'fs-mock/lib/fs.js';
	var __dirname = 'fs-mock/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'fs-mock/lib/fs.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Errors, FSWatcher, Readable, Stats, Writable, escape, fs, isAppendable, isCreatable, isFunction, isReadable, isWritable, toDate, _path;
	
	  Stats = require('./Stats');
	
	  Errors = require('./Errors');
	
	  FSWatcher = require('./FSWatcher');
	
	  escape = require('escape-regexp');
	
	  _path = require('path');
	
	  Readable = require('stream').Readable;
	
	  Writable = require('stream').Writable;
	
	  isFunction = function(obj) {
	    return Object.prototype.toString.call(obj) === '[object Function]';
	  };
	
	  isReadable = function(flags) {
	    return flags === 'r' || flags === 'r+' || flags === 'rs' || flags === 'rs+' || flags === 'w+' || flags === 'wx+' || flags === 'a+' || flags === 'ax+';
	  };
	
	  isWritable = function(flags) {
	    return flags === 'r+' || flags === 'rs+' || flags === 'w' || flags === 'wx' || flags === 'w+' || flags === 'wx+';
	  };
	
	  isAppendable = function(flags) {
	    return flags === 'a' || flags === 'ax' || flags === 'a+' || flags === 'ax+';
	  };
	
	  isCreatable = function(flags) {
	    return flags === 'w' || flags === 'w+' || flags === 'a' || flags === 'a+';
	  };
	
	  toDate = function(time) {
	    if (typeof time === 'number') {
	      return new Date(time * 1000);
	    }
	    if (time instanceof Date) {
	      return time;
	    }
	    throw new Error("Cannot parse time: " + time);
	  };
	
	  fs = (function() {
	    fs.prototype._data = null;
	
	    fs.prototype._fileDescriptors = null;
	
	    fs.prototype._fileDescriptorsCounter = 0;
	
	    function fs(tree, info) {
	      if (tree == null) {
	        tree = {};
	      }
	      if (info == null) {
	        info = {};
	      }
	      this._data = {};
	      this._fileDescriptors = [];
	      this._addPath('/', {});
	      this._setTree(tree, info);
	    }
	
	    fs.prototype._hasFd = function(fd) {
	      return typeof this._fileDescriptors[fd] !== 'undefined';
	    };
	
	    fs.prototype._hasSubPaths = function(path) {
	      var data, found, _ref;
	      _ref = this._data;
	      for (found in _ref) {
	        data = _ref[found];
	        if (path !== found && found.match(new RegExp('^' + escape(path))) !== null) {
	          return true;
	        }
	      }
	      return false;
	    };
	
	    fs.prototype._setAttributes = function(path, attributes) {
	      if (attributes == null) {
	        attributes = {};
	      }
	      return this._data[path].stats._setAttributes(attributes);
	    };
	
	    fs.prototype._addPath = function(path, data, info) {
	      var item, stats, subData, subPath, type, _ref, _results;
	      if (data == null) {
	        data = '';
	      }
	      if (info == null) {
	        info = {};
	      }
	      if (typeof info.stats === 'undefined') {
	        info.stats = {};
	      }
	      if (typeof info.mode === 'undefined') {
	        info.mode = 777;
	      }
	      if (typeof info.encoding === 'undefined') {
	        info.encoding = 'utf8';
	      }
	      if (typeof info.source === 'undefined') {
	        info.source = null;
	      }
	      if (path[0] === '@') {
	        return this.linkSync(data, path.substr(1));
	      }
	      if (path[0] === '%') {
	        type = 'symlink';
	        info = {
	          source: data
	        };
	        path = path.substr(1);
	      } else if (typeof data === 'string') {
	        type = 'file';
	        info = {
	          data: data
	        };
	      } else if (Object.prototype.toString.call(data) === '[object Object]') {
	        type = 'directory';
	        info = {
	          paths: data
	        };
	      } else {
	        throw new Error('Unknown type');
	      }
	      path = _path.join('/', path);
	      stats = new Stats(path, info.stats);
	      stats.mode = info.mode;
	      this._data[path] = {};
	      item = this._data[path];
	      item.stats = stats;
	      switch (type) {
	        case 'directory':
	          stats._isDirectory = true;
	          if (typeof info.paths !== 'undefined') {
	            _ref = info.paths;
	            _results = [];
	            for (subPath in _ref) {
	              subData = _ref[subPath];
	              _results.push(this._addPath(_path.join(path, subPath), subData));
	            }
	            return _results;
	          }
	          break;
	        case 'file':
	          stats._isFile = true;
	          if (typeof info.data === 'undefined') {
	            item.data = new Buffer('', info.encoding);
	          } else if (info.data instanceof Buffer) {
	            item.data = info.data;
	          } else {
	            item.data = new Buffer(info.data, info.encoding);
	          }
	          return stats.blksize = stats.size = item.data.length;
	        case 'symlink':
	          stats._isSymlink = true;
	          return item.source = info.source;
	        default:
	          throw new Error("Type must be directory, file or symlink, " + type + " given.");
	      }
	    };
	
	    fs.prototype._expandPaths = function() {
	      var data, path, _ref, _results;
	      _ref = this._data;
	      _results = [];
	      for (path in _ref) {
	        data = _ref[path];
	        _results.push(this._expandPath(path));
	      }
	      return _results;
	    };
	
	    fs.prototype._expandPath = function(path) {
	      var match, position, sub, _results;
	      match = path.match(/\//g);
	      if (match !== null && match.length > 1) {
	        sub = path;
	        _results = [];
	        while (sub !== null) {
	          position = sub.lastIndexOf('/');
	          if (position > 0) {
	            sub = sub.substring(0, sub.lastIndexOf('/'));
	            if (typeof this._data[sub] === 'undefined') {
	              _results.push(this._addPath(sub, {}));
	            } else {
	              _results.push(void 0);
	            }
	          } else {
	            _results.push(sub = null);
	          }
	        }
	        return _results;
	      }
	    };
	
	    fs.prototype._setTree = function(tree, info) {
	      var attributes, data, path;
	      if (info == null) {
	        info = {};
	      }
	      for (path in tree) {
	        data = tree[path];
	        this._addPath(path, data);
	      }
	      for (path in info) {
	        attributes = info[path];
	        this._setAttributes(path, attributes);
	      }
	      return this._expandPaths();
	    };
	
	    fs.prototype._realpath = function(path) {
	      if (path[0] === '.') {
	        path = _path.join('/', path);
	      }
	      return _path.normalize(path);
	    };
	
	    fs.prototype._getSourcePath = function(path) {
	      var _ref;
	      path = this._realpath(path);
	      if ((_ref = this._data[path]) != null ? _ref.stats.isSymbolicLink() : void 0) {
	        path = this._data[path].source;
	      }
	      return path;
	    };
	
	    fs.prototype.rename = function(oldPath, newPath, callback) {
	      var err;
	      try {
	        this.renameSync(oldPath, newPath);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.renameSync = function(oldPath, newPath) {
	      oldPath = this.realpathSync(oldPath);
	      newPath = this._realpath(newPath);
	      if (!this.existsSync(oldPath)) {
	        Errors.notFound(oldPath);
	      }
	      if (this.existsSync(newPath)) {
	        Errors.alreadyExists(newPath);
	      }
	      this._data[newPath] = this._data[oldPath];
	      delete this._data[oldPath];
	      this._data[newPath].stats._path = newPath;
	      return this._data[newPath].stats._modifiedAttributes('rename');
	    };
	
	    fs.prototype.ftruncate = function(fd, len, callback) {
	      var err;
	      try {
	        this.ftruncateSync(fd, len);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.ftruncateSync = function(fd, len) {
	      var data, item;
	      if (!this._hasFd(fd)) {
	        Errors.fdNotFound(fd);
	      }
	      item = this._data[this._fileDescriptors[fd].path];
	      data = item.data.toString('utf8');
	      if (item.data.length > len) {
	        data = data.substr(0, len);
	      }
	      return this.writeSync(fd, new Buffer(data), 0, data.length, null);
	    };
	
	    fs.prototype.truncate = function(path, len, callback) {
	      var err;
	      try {
	        this.truncateSync(path, len);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.truncateSync = function(path, len) {
	      var fd;
	      path = this._getSourcePath(path);
	      if (!this.existsSync(path)) {
	        Errors.notFound(path);
	      }
	      fd = this.openSync(path, 'w');
	      if (!this.fstatSync(fd).isFile()) {
	        Errors.notFile(path);
	      }
	      this.ftruncateSync(fd, len);
	      return this.closeSync(fd);
	    };
	
	    fs.prototype.chown = function(path, uid, gid, callback) {
	      var err;
	      try {
	        this.chownSync(path, uid, gid);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.chownSync = function(path, uid, gid) {
	      var fd;
	      path = this._getSourcePath(path);
	      fd = this.openSync(path, 'r');
	      this.fchownSync(fd, uid, gid);
	      return this.closeSync(fd);
	    };
	
	    fs.prototype.fchown = function(fd, uid, gid, callback) {
	      var err;
	      try {
	        this.fchownSync(fd, uid, gid);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.fchownSync = function(fd, uid, gid) {
	      if (!this._hasFd(fd)) {
	        Errors.fdNotFound(fd);
	      }
	      return this._setAttributes(this._fileDescriptors[fd].path, {
	        uid: uid,
	        gid: gid
	      });
	    };
	
	    fs.prototype.lchown = function(path, uid, gid, callback) {
	      var err;
	      try {
	        this.lchownSync(path, uid, gid);
	        return callback(null);
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.lchownSync = function(path, uid, gid) {
	      path = this.realpathSync(path);
	      if (!this.existsSync(path)) {
	        Errors.notFound(path);
	      }
	      if (!this.lstatSync(path).isSymbolicLink()) {
	        Errors.notSymlink(path);
	      }
	      return this._setAttributes(path, {
	        uid: uid,
	        gid: gid
	      });
	    };
	
	    fs.prototype.chmod = function(path, mode, callback) {
	      var err;
	      try {
	        this.chmodSync(path, mode);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.chmodSync = function(path, mode) {
	      var fd;
	      path = this._getSourcePath(path);
	      fd = this.openSync(path, 'r', mode);
	      this.fchmodSync(fd, mode);
	      return this.closeSync(fd);
	    };
	
	    fs.prototype.fchmod = function(fd, mode, callback) {
	      var err;
	      try {
	        this.fchmodSync(fd, mode);
	        return callback(null);
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.fchmodSync = function(fd, mode) {
	      if (!this._hasFd(fd)) {
	        Errors.fdNotFound(fd);
	      }
	      return this._setAttributes(this._fileDescriptors[fd].path, {
	        mode: mode
	      });
	    };
	
	    fs.prototype.lchmod = function(path, mode, callback) {
	      var err;
	      try {
	        this.lchmodSync(path, mode);
	        return callback(null);
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.lchmodSync = function(path, mode) {
	      path = this.realpathSync(path);
	      if (!this.existsSync(path)) {
	        Errors.notFound(path);
	      }
	      if (!this.lstatSync(path).isSymbolicLink()) {
	        Errors.notSymlink(path);
	      }
	      return this._setAttributes(path, {
	        mode: mode
	      });
	    };
	
	    fs.prototype.stat = function(path, callback) {
	      var err;
	      try {
	        return callback(null, this.statSync(path));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.statSync = function(path) {
	      var fd, result;
	      path = this._getSourcePath(path);
	      fd = this.openSync(path, 'r');
	      result = this.fstatSync(fd);
	      this.closeSync(fd);
	      return result;
	    };
	
	    fs.prototype.lstat = function(path, callback) {
	      var err;
	      try {
	        return callback(null, this.lstatSync(path));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.lstatSync = function(path) {
	      var stats;
	      path = this.realpathSync(path);
	      if (!this.existsSync(path)) {
	        Error.notFound(path);
	      }
	      stats = this._data[path].stats;
	      if (!stats.isSymbolicLink()) {
	        Errors.notSymlink(path);
	      }
	      return stats;
	    };
	
	    fs.prototype.fstat = function(fd, callback) {
	      var err;
	      try {
	        return callback(null, this.fstatSync(fd));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.fstatSync = function(fd) {
	      if (!this._hasFd(fd)) {
	        Errors.fdNotFound(fd);
	      }
	      return this._data[this._fileDescriptors[fd].path].stats;
	    };
	
	    fs.prototype.link = function(srcpath, dstpath, callback) {
	      var err;
	      try {
	        this.linkSync(srcpath, dstpath);
	        return callback(null);
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.linkSync = function(srcpath, dstpath) {
	      srcpath = this.realpathSync(srcpath);
	      dstpath = this._realpath(dstpath);
	      if (!this.existsSync(srcpath)) {
	        Errors.notFound(srcpath);
	      }
	      return this._data[dstpath] = this._data[srcpath];
	    };
	
	    fs.prototype.symlink = function(srcpath, dstpath, type, callback) {
	      var err;
	      if (type == null) {
	        type = null;
	      }
	      if (isFunction(type)) {
	        callback = type;
	        type = null;
	      }
	      try {
	        this.symlinkSync(srcpath, dstpath);
	        return callback(null);
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.symlinkSync = function(srcpath, dstpath, type) {
	      if (type == null) {
	        type = null;
	      }
	      srcpath = this.realpathSync(srcpath);
	      dstpath = this._realpath(dstpath);
	      if (!this.existsSync(srcpath)) {
	        Errors.notFound(srcpath);
	      }
	      return this._addPath('%' + dstpath, srcpath);
	    };
	
	    fs.prototype.readlink = function(path, callback) {
	      var err;
	      try {
	        return callback(null, this.readlinkSync(path));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.readlinkSync = function(path) {
	      path = this._getSourcePath(path);
	      if (!this.existsSync(path)) {
	        Errors.notFound(path);
	      }
	      return path;
	    };
	
	    fs.prototype.realpath = function(path, cache, callback) {
	      var err;
	      if (cache == null) {
	        cache = null;
	      }
	      if (isFunction(cache)) {
	        callback = cache;
	        cache = null;
	      }
	      try {
	        return callback(null, this.realpathSync(path, cache));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.realpathSync = function(path, cache) {
	      if (cache == null) {
	        cache = null;
	      }
	      if (cache !== null && typeof cache[path] !== 'undefined') {
	        return cache[path];
	      }
	      path = this._realpath(path);
	      if (!this.existsSync(path)) {
	        Errors.notFound(path);
	      }
	      return path;
	    };
	
	    fs.prototype.unlink = function(path, callback) {
	      var err;
	      try {
	        this.unlinkSync(path);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.unlinkSync = function(path) {
	      path = this.realpathSync(path);
	      if (!this.existsSync(path)) {
	        Errors.notFound(path);
	      }
	      if (!this.statSync(path).isFile()) {
	        Errors.notFile(path);
	      }
	      return delete this._data[path];
	    };
	
	    fs.prototype.rmdir = function(path, callback) {
	      var err;
	      try {
	        this.rmdirSync(path);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.rmdirSync = function(path) {
	      path = this.realpathSync(path);
	      if (!this.existsSync(path)) {
	        Errors.notFound(path);
	      }
	      if (!this.statSync(path).isDirectory()) {
	        Errors.notDirectory(path);
	      }
	      if (this._hasSubPaths(path)) {
	        Errors.directoryNotEmpty(path);
	      }
	      return delete this._data[path];
	    };
	
	    fs.prototype.mkdir = function(path, mode, callback) {
	      var err;
	      if (mode == null) {
	        mode = null;
	      }
	      if (isFunction(mode)) {
	        callback = mode;
	        mode = null;
	      }
	      try {
	        this.mkdirSync(path, mode);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.mkdirSync = function(path, mode) {
	      if (mode == null) {
	        mode = null;
	      }
	      path = this._realpath(path);
	      if (this.existsSync(path)) {
	        Errors.alreadyExists(path);
	      }
	      this._addPath(path, {}, {
	        mode: mode
	      });
	      return this._expandPath(path);
	    };
	
	    fs.prototype.readdir = function(path, callback) {
	      var err;
	      try {
	        return callback(null, this.readdirSync(path));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.readdirSync = function(path) {
	      var data, files, match, name, slashes, _ref;
	      path = this._getSourcePath(path);
	      if (!this.existsSync(path)) {
	        Errors.notFound(path);
	      }
	      if (!this.statSync(path).isDirectory()) {
	        Errors.notDirectory(path);
	      }
	      path = path === '/' ? '' : path;
	      path = escape(path);
	      files = [];
	      _ref = this._data;
	      for (name in _ref) {
	        data = _ref[name];
	        if (name !== path && name !== '/' && (match = name.match(new RegExp('^' + path + '(.+)$'))) !== null) {
	          slashes = match[1].match(/\//g);
	          slashes = slashes === null ? 0 : slashes.length;
	          if (slashes === 1) {
	            files.push(match[1].substr(1));
	          }
	        }
	      }
	      return files;
	    };
	
	    fs.prototype.close = function(fd, callback) {
	      var err;
	      try {
	        this.closeSync(fd);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.closeSync = function(fd) {
	      if (!this._hasFd(fd)) {
	        Errors.fdNotFound(fd);
	      }
	      return delete this._fileDescriptors[fd];
	    };
	
	    fs.prototype.open = function(path, flags, mode, callback) {
	      var err;
	      if (mode == null) {
	        mode = null;
	      }
	      if (isFunction(mode)) {
	        callback = mode;
	        mode = null;
	      }
	      try {
	        return callback(null, this.openSync(path, flags, mode));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.openSync = function(path, flags, mode) {
	      var exists;
	      if (mode == null) {
	        mode = null;
	      }
	      path = this._getSourcePath(path);
	      exists = this.existsSync(path);
	      if ((flags === 'r' || flags === 'r+') && !exists) {
	        Errors.notFound(path);
	      }
	      if ((flags === 'wx' || flags === 'wx+' || flags === 'ax' || flags === 'ax+') && exists) {
	        Errors.alreadyExists(path);
	      }
	      this._fileDescriptors[this._fileDescriptorsCounter] = {
	        path: path,
	        flags: flags
	      };
	      if (isCreatable(flags) && !exists) {
	        this._addPath(path, '', {
	          mode: mode
	        });
	      }
	      this._fileDescriptorsCounter++;
	      return this._fileDescriptorsCounter - 1;
	    };
	
	    fs.prototype.utimes = function(path, atime, mtime, callback) {
	      var err;
	      try {
	        this.utimesSync(path, atime, mtime);
	        return callback(null);
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.utimesSync = function(path, atime, mtime) {
	      var fd;
	      path = this.realpathSync(path);
	      fd = this.openSync(path, 'r');
	      this.futimesSync(fd, atime, mtime);
	      return this.closeSync(fd);
	    };
	
	    fs.prototype.futimes = function(fd, atime, mtime, callback) {
	      var err;
	      try {
	        this.futimesSync(fd, atime, mtime);
	        return callback(null);
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.futimesSync = function(fd, atime, mtime) {
	      if (!this._hasFd(fd)) {
	        Errors.fdNotFound(fd);
	      }
	      return this._setAttributes(this._fileDescriptors[fd].path, {
	        atime: toDate(atime),
	        mtime: toDate(mtime)
	      });
	    };
	
	    fs.prototype.fsync = function(fd, callback) {
	      var err;
	      try {
	        this.fsyncSync(fd);
	        return callback(null);
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.fsyncSync = function(fd) {
	      if (!this._hasFd(fd)) {
	        return Errors.fdNotFound(fd);
	      }
	    };
	
	    fs.prototype.write = function(fd, buffer, offset, length, position, callback) {
	      var err;
	      if (position == null) {
	        position = null;
	      }
	      if (callback == null) {
	        callback = null;
	      }
	      try {
	        this.writeSync(fd, buffer, offset, length, position);
	        if (callback !== null) {
	          return callback(null, length, buffer);
	        }
	      } catch (_error) {
	        err = _error;
	        if (callback !== null) {
	          return callback(err, null, buffer);
	        }
	      }
	    };
	
	    fs.prototype.writeSync = function(fd, buffer, offset, length, position) {
	      var data, fdData, item, oldData, oldFlags, path, stats;
	      if (position == null) {
	        position = null;
	      }
	      if (!this._hasFd(fd)) {
	        Errors.fdNotFound(fd);
	      }
	      fdData = this._fileDescriptors[fd];
	      path = fdData.path;
	      if (!isWritable(fdData.flags)) {
	        Errors.notWritable(path);
	      }
	      stats = this.fstatSync(fd);
	      if (!stats.isFile()) {
	        Errors.notFile(path);
	      }
	      item = this._data[path];
	      data = buffer.toString('utf8', offset).substr(0, length);
	      if (position !== null) {
	        buffer = new Buffer(stats.size);
	        oldFlags = fdData.flags;
	        fdData.flags = 'r';
	        this.readSync(fd, buffer, 0, stats.size, 0);
	        fdData.flags = oldFlags;
	        oldData = buffer.toString('utf8');
	        data = [oldData.slice(0, position), data, oldData.slice(position)].join('');
	      }
	      item.data = new Buffer(data);
	      item.stats.size = data.length;
	      item.stats.blksize = data.length;
	      return item.stats._modified();
	    };
	
	    fs.prototype.read = function(fd, buffer, offset, length, position, callback) {
	      var err;
	      if (position == null) {
	        position = 0;
	      }
	      if (callback == null) {
	        callback = null;
	      }
	      try {
	        this.readSync(fd, buffer, offset, length, position);
	        if (callback !== null) {
	          return callback(null, length, buffer);
	        }
	      } catch (_error) {
	        err = _error;
	        if (callback !== null) {
	          return callback(err, 0, buffer);
	        }
	      }
	    };
	
	    fs.prototype.readSync = function(fd, buffer, offset, length, position) {
	      var data, item, path;
	      if (position == null) {
	        position = 0;
	      }
	      if (!this._hasFd(fd)) {
	        Errors.fdNotFound(fd);
	      }
	      item = this._fileDescriptors[fd];
	      path = item.path;
	      if (!isReadable(item.flags)) {
	        Errors.notReadable(path);
	      }
	      if (!this.fstatSync(fd).isFile()) {
	        Errors.notFile(path);
	      }
	      item = this._data[path];
	      data = item.data.toString('utf8');
	      data = data.substr(position, length);
	      buffer.write(data, offset);
	      item.stats._accessed();
	      return length;
	    };
	
	    fs.prototype.readFile = function(filename, options, callback) {
	      var err;
	      if (options == null) {
	        options = {};
	      }
	      if (isFunction(options)) {
	        callback = options;
	        options = null;
	      }
	      try {
	        return callback(null, this.readFileSync(filename, options));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.readFileSync = function(filename, options) {
	      var buffer, data, fd, size;
	      if (options == null) {
	        options = {};
	      }
	      if (typeof options.encoding === 'undefined') {
	        options.encoding = null;
	      }
	      if (typeof options.flag === 'undefined') {
	        options.flag = 'r';
	      }
	      fd = this.openSync(filename, options.flag);
	      size = this.fstatSync(fd).size;
	      buffer = new Buffer(size);
	      this.readSync(fd, buffer, 0, size, null);
	      this.closeSync(fd);
	      data = buffer;
	      if (options.encoding !== null) {
	        data = buffer.toString(options.encoding);
	      }
	      return data;
	    };
	
	    fs.prototype.writeFile = function(filename, data, options, callback) {
	      var err;
	      if (options == null) {
	        options = {};
	      }
	      if (isFunction(options)) {
	        callback = options;
	        options = null;
	      }
	      try {
	        return callback(null, this.writeFileSync(filename, data, options));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.writeFileSync = function(filename, data, options) {
	      var fd;
	      if (options == null) {
	        options = {};
	      }
	      if (typeof options.encoding === 'undefined') {
	        options.encoding = 'utf8';
	      }
	      if (typeof options.mode === 'undefined') {
	        options.mode = 438;
	      }
	      if (typeof options.flag === 'undefined') {
	        options.flag = 'w';
	      }
	      filename = this._getSourcePath(filename);
	      fd = this.openSync(filename, options.flag, options.mode);
	      this.writeSync(fd, new Buffer(data, options.encoding), 0, data.length, null);
	      this.closeSync(fd);
	      return this._expandPath(filename);
	    };
	
	    fs.prototype.appendFile = function(filename, data, options, callback) {
	      var err;
	      if (options == null) {
	        options = {};
	      }
	      if (isFunction(options)) {
	        callback = options;
	        options = null;
	      }
	      try {
	        return callback(null, this.appendFileSync(filename, data, options));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.appendFileSync = function(filename, data, options) {
	      var fd, size;
	      if (options == null) {
	        options = {};
	      }
	      if (typeof options.encoding === 'undefined') {
	        options.encoding = 'utf8';
	      }
	      if (typeof options.mode === 'undefined') {
	        options.mode = 438;
	      }
	      if (typeof options.flag === 'undefined') {
	        options.flag = 'w';
	      }
	      if (typeof data === 'string') {
	        data = new Buffer(data, options.encoding);
	      }
	      fd = this.openSync(filename, options.flag, options.mode);
	      size = this.fstatSync(fd).size;
	      this.writeSync(fd, data, 0, data.length, size);
	      return this.closeSync(fd);
	    };
	
	    fs.prototype.watchFile = function(filename, options, listener) {
	      if (options == null) {
	        options = null;
	      }
	      if (listener == null) {
	        listener = null;
	      }
	      if (isFunction(options)) {
	        listener = options;
	        options = null;
	      }
	      return Errors.notImplemented('watchFile');
	    };
	
	    fs.prototype.unwatchFile = function(filename, listener) {
	      if (listener == null) {
	        listener = null;
	      }
	      return Errors.notImplemented('unwatchFile');
	    };
	
	    fs.prototype.watch = function(filename, options, listener) {
	      var stats, watcher;
	      if (options == null) {
	        options = null;
	      }
	      if (listener == null) {
	        listener = null;
	      }
	      if (isFunction(options)) {
	        listener = options;
	        options = null;
	      }
	      if (!this.existsSync(filename)) {
	        Errors.notFound(filename);
	      }
	      watcher = new FSWatcher(listener);
	      stats = this.statSync(filename);
	      stats.on('modified', function(stats) {
	        return watcher.emit('change', 'change', stats._path);
	      });
	      stats.on('modifiedAttributes', function(stats, event) {
	        return watcher.emit('change', event, stats._path);
	      });
	      return watcher;
	    };
	
	    fs.prototype.exists = function(path, callback) {
	      return callback(this.existsSync(path));
	    };
	
	    fs.prototype.existsSync = function(path) {
	      path = this._realpath(path);
	      return typeof this._data[path] !== 'undefined';
	    };
	
	    fs.prototype.createReadStream = function(path, options) {
	      var buffer, data, fd, rs, size;
	      if (options == null) {
	        options = {};
	      }
	      if (typeof options.flags === 'undefined') {
	        options.flags = 'r';
	      }
	      if (typeof options.encoding === 'undefined') {
	        options.encoding = null;
	      }
	      if (typeof options.fd === 'undefined') {
	        options.fd = null;
	      }
	      if (typeof options.mode === 'undefined') {
	        options.mode = 666;
	      }
	      if (typeof options.autoClose === 'undefined') {
	        options.autoClose = true;
	      }
	      if (typeof options.start === 'undefined') {
	        options.start = null;
	      }
	      if (typeof options.end === 'undefined') {
	        options.end = null;
	      }
	      if (options.fd === null) {
	        fd = this.openSync(path, options.flags, options.mode);
	      }
	      size = this.fstatSync(fd).size;
	      rs = new Readable;
	      buffer = new Buffer(size);
	      this.readSync(fd, buffer, 0, size, 0);
	      data = buffer.toString(options.encoding);
	      if (options.start !== null && options.end !== null) {
	        data = data.substring(options.start, options.end);
	      }
	      rs.push(data);
	      rs.push(null);
	      if (options.autoClose) {
	        this.closeSync(fd);
	      }
	      return rs;
	    };
	
	    fs.prototype.createWriteStream = function(path, options) {
	      var fd, position, ws,
	        _this = this;
	      if (options == null) {
	        options = {};
	      }
	      if (typeof options.flags === 'undefined') {
	        options.flags = 'w';
	      }
	      if (typeof options.encoding === 'undefined') {
	        options.encoding = null;
	      }
	      if (typeof options.mode === 'undefined') {
	        options.mode = 666;
	      }
	      if (typeof options.start === 'undefined') {
	        options.start = 0;
	      }
	      fd = this.openSync(path, options.flags, options.mode);
	      position = options.start;
	      ws = Writable();
	      ws._write = function(chunk, enc, next) {
	        if (typeof chunk === 'string') {
	          chunk = new Buffer(chunk);
	        }
	        return _this.write(fd, chunk, 0, chunk.length, position, function(err) {
	          if (err) {
	            throw err;
	          }
	          position += chunk.length;
	          return next();
	        });
	      };
	      ws.on('finish', function() {
	        return _this.closeSync(fd);
	      });
	      return ws;
	    };
	
	    return fs;
	
	  })();
	
	  module.exports = fs;
	
	}).call(this);
	

}, 'fs-mock/lib/Stats.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'fs-mock/lib/Stats.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'fs-mock/lib/Stats.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'fs-mock/lib/Stats.js';
	var __dirname = 'fs-mock/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'fs-mock/lib/Stats.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Errors, EventEmitter, Stats,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  Errors = require('./Errors');
	
	  EventEmitter = require('events').EventEmitter;
	
	  Stats = (function(_super) {
	    __extends(Stats, _super);
	
	    Stats.prototype._path = null;
	
	    Stats.prototype._isFile = false;
	
	    Stats.prototype._isDirectory = false;
	
	    Stats.prototype._isSymlink = false;
	
	    Stats.prototype.dev = 0;
	
	    Stats.prototype.ino = 0;
	
	    Stats.prototype.mode = 438;
	
	    Stats.prototype.nlink = 0;
	
	    Stats.prototype.uid = 100;
	
	    Stats.prototype.gid = 100;
	
	    Stats.prototype.rdev = 0;
	
	    Stats.prototype.size = 0;
	
	    Stats.prototype.blksize = 0;
	
	    Stats.prototype.blocks = 1;
	
	    Stats.prototype.atime = null;
	
	    Stats.prototype.mtime = null;
	
	    Stats.prototype.ctime = null;
	
	    function Stats(_path, data) {
	      var name, value;
	      this._path = _path;
	      if (data == null) {
	        data = {};
	      }
	      this.atime = new Date;
	      this.mtime = new Date;
	      this.ctime = new Date;
	      for (name in data) {
	        value = data[name];
	        if (typeof this[name] !== 'undefined' && Object.prototype.toString.call(this[name]) !== '[object Function]') {
	          this[name] = value;
	        }
	      }
	    }
	
	    Stats.prototype._modified = function() {
	      this.mtime = new Date;
	      this.ctime = new Date;
	      return this.emit('modified', this);
	    };
	
	    Stats.prototype._modifiedAttributes = function(event) {
	      if (event == null) {
	        event = 'change';
	      }
	      this.ctime = new Date;
	      return this.emit('modifiedAttributes', this, event);
	    };
	
	    Stats.prototype._accessed = function() {
	      this.atime = new Date;
	      return this.emit('accessed', this);
	    };
	
	    Stats.prototype._setAttributes = function(attributes) {
	      var name, value;
	      if (attributes == null) {
	        attributes = {};
	      }
	      for (name in attributes) {
	        value = attributes[name];
	        if (Object.prototype.toString.call(this[name]) !== '[object Function]') {
	          this[name] = value;
	        }
	      }
	      return this._modifiedAttributes();
	    };
	
	    Stats.prototype._clone = function() {
	      var name, stats, value;
	      stats = new Stats(this._path, {});
	      for (name in this) {
	        value = this[name];
	        if (Object.prototype.toString.call(this[name]) !== '[object Function]') {
	          stats[name] = this[name];
	        }
	      }
	      return stats;
	    };
	
	    Stats.prototype.isFile = function() {
	      return this._isFile;
	    };
	
	    Stats.prototype.isDirectory = function() {
	      return this._isDirectory;
	    };
	
	    Stats.prototype.isBlockDevice = function() {
	      return Errors.notImplemented('isBlockDevice');
	    };
	
	    Stats.prototype.isCharacterDevice = function() {
	      return Errors.notImplemented('isCharacterDevice');
	    };
	
	    Stats.prototype.isSymbolicLink = function() {
	      return this._isSymlink;
	    };
	
	    Stats.prototype.isFIFO = function() {
	      return Errors.notImplemented('isFIFO');
	    };
	
	    Stats.prototype.isSocket = function() {
	      return Errors.notImplemented('isSocket');
	    };
	
	    return Stats;
	
	  })(EventEmitter);
	
	  module.exports = Stats;
	
	}).call(this);
	

}, 'fs-mock/lib/Errors.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'fs-mock/lib/Errors.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'fs-mock/lib/Errors.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'fs-mock/lib/Errors.js';
	var __dirname = 'fs-mock/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'fs-mock/lib/Errors.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Errors;
	
	  Errors = (function() {
	    function Errors() {}
	
	    Errors.notImplemented = function(method) {
	      throw new Error("Method '" + method + "' is not implemented.");
	    };
	
	    Errors.notFound = function(path) {
	      throw new Error("File or directory '" + path + "' does not exists.");
	    };
	
	    Errors.alreadyExists = function(path) {
	      throw new Error("File or directory '" + path + "' already exists.");
	    };
	
	    Errors.directoryExists = function(path) {
	      throw new Error("Directory '" + path + "' already exists.");
	    };
	
	    Errors.notFile = function(path) {
	      throw new Error("Path '" + path + "' is not a file.");
	    };
	
	    Errors.notDirectory = function(path) {
	      throw new Error("Path '" + path + "' is not a directory.");
	    };
	
	    Errors.notSymlink = function(path) {
	      throw new Error("Path '" + path + "' is not a symbolic link.");
	    };
	
	    Errors.directoryNotEmpty = function(path) {
	      throw new Error("Directory '" + path + "' is not empty.");
	    };
	
	    Errors.fdNotFound = function(fd) {
	      throw new Error("File descriptor " + fd + " not exists.");
	    };
	
	    Errors.notWritable = function(path) {
	      throw new Error("File '" + path + "' is not open for writing.");
	    };
	
	    Errors.notReadable = function(path) {
	      throw new Error("File '" + path + "' is not open for reading.");
	    };
	
	    return Errors;
	
	  })();
	
	  module.exports = Errors;
	
	}).call(this);
	

}, 'fs-mock/lib/FSWatcher.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'fs-mock/lib/FSWatcher.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'fs-mock/lib/FSWatcher.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'fs-mock/lib/FSWatcher.js';
	var __dirname = 'fs-mock/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'fs-mock/lib/FSWatcher.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var EventEmitter, FSWatcher,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  EventEmitter = require('events').EventEmitter;
	
	  FSWatcher = (function(_super) {
	    __extends(FSWatcher, _super);
	
	    FSWatcher.prototype.listener = null;
	
	    function FSWatcher(listener) {
	      this.listener = listener;
	      FSWatcher.__super__.constructor.apply(this, arguments);
	      this.addListener('change', this.listener);
	    }
	
	    FSWatcher.prototype.close = function() {
	      return this.removeListener('change', this.listener);
	    };
	
	    return FSWatcher;
	
	  })(EventEmitter);
	
	  module.exports = FSWatcher;
	
	}).call(this);
	

}, 'escape-regexp/index.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'escape-regexp/index.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'escape-regexp/index.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'escape-regexp/index.js';
	var __dirname = 'escape-regexp';
	var process = {cwd: function() {return '/';}, argv: ['node', 'escape-regexp/index.js'], env: {}};

	/** code **/
	
	/**
	 * Escape regexp special characters in `str`.
	 *
	 * @param {String} str
	 * @return {String}
	 * @api public
	 */
	
	module.exports = function(str){
	  return String(str).replace(/([.*+?=^!:${}()|[\]\/\\])/g, '\\$1');
	};

}, '/lib/Storage/Async/DevNullStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Async/DevNullStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Async/DevNullStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Async/DevNullStorage.js';
	var __dirname = '/lib/Storage/Async';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Async/DevNullStorage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var DevNullStorage, Storage, _ref,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  Storage = require('./Storage');
	
	  DevNullStorage = (function(_super) {
	    __extends(DevNullStorage, _super);
	
	    function DevNullStorage() {
	      _ref = DevNullStorage.__super__.constructor.apply(this, arguments);
	      return _ref;
	    }
	
	    DevNullStorage.prototype.getData = function(fn) {
	      fn({});
	      return null;
	    };
	
	    DevNullStorage.prototype.getMeta = function(fn) {
	      fn({});
	      return null;
	    };
	
	    DevNullStorage.prototype.writeData = function(data, meta, fn) {
	      fn();
	      return this;
	    };
	
	    DevNullStorage.prototype.read = function(key, fn) {
	      fn(null);
	      return null;
	    };
	
	    DevNullStorage.prototype.write = function(key, data, dependencies, fn) {
	      if (dependencies == null) {
	        dependencies = {};
	      }
	      if (Object.prototype.toString.call(dependencies) === '[object Function]') {
	        fn = dependencies;
	        dependencies = {};
	      }
	      fn();
	      return this;
	    };
	
	    DevNullStorage.prototype.remove = function(key, fn) {
	      fn();
	      return this;
	    };
	
	    return DevNullStorage;
	
	  })(Storage);
	
	  module.exports = DevNullStorage;
	
	}).call(this);
	

}, '/lib/Storage/Async/Storage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Async/Storage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Async/Storage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Async/Storage.js';
	var __dirname = '/lib/Storage/Async';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Async/Storage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var BaseStorage, Cache, Storage, async, isWindow, moment, path, _ref,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  isWindow = typeof window === 'undefined' ? false : true;
	
	  if (!isWindow) {
	    path = require('path');
	  }
	
	  BaseStorage = require('../Storage');
	
	  moment = require('moment');
	
	  Cache = require('../../Cache');
	
	  async = require('async');
	
	  Storage = (function(_super) {
	    __extends(Storage, _super);
	
	    function Storage() {
	      _ref = Storage.__super__.constructor.apply(this, arguments);
	      return _ref;
	    }
	
	    Storage.prototype.async = true;
	
	    Storage.prototype.read = function(key, fn) {
	      var _this = this;
	      return this.getData(function(data) {
	        if (typeof data[key] === 'undefined') {
	          return fn(null);
	        } else {
	          return _this.findMeta(key, function(meta) {
	            return _this.verify(meta[key], function(state) {
	              if (state) {
	                return fn(data[key]);
	              } else {
	                return _this.remove(key, function() {
	                  return fn();
	                });
	              }
	            });
	          });
	        }
	      });
	    };
	
	    Storage.prototype.write = function(key, data, dependencies, fn) {
	      var _this = this;
	      if (dependencies == null) {
	        dependencies = {};
	      }
	      return this.getData(function(all) {
	        all[key] = data;
	        return _this.getMeta(function(meta) {
	          meta[key] = dependencies;
	          return _this.writeData(all, meta, function() {
	            return fn();
	          });
	        });
	      });
	    };
	
	    Storage.prototype.remove = function(key, fn) {
	      var _this = this;
	      return this.getData(function(data) {
	        return _this.getMeta(function(meta) {
	          if (typeof data[key] !== 'undefined') {
	            delete data[key];
	            delete meta[key];
	          }
	          return _this.writeData(data, meta, function() {
	            return fn();
	          });
	        });
	      });
	    };
	
	    Storage.prototype.clean = function(conditions, fn) {
	      var key, keys, tag, type, typeFn, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3,
	        _this = this;
	      typeFn = Object.prototype.toString;
	      type = typeFn.call(conditions);
	      if (conditions === Cache.ALL) {
	        this.writeData({}, {}, fn);
	      } else if (type === '[object Object]') {
	        keys = [];
	        if (typeof conditions[Cache.TAGS] !== 'undefined') {
	          if (typeFn(conditions[Cache.TAGS]) === '[object String]') {
	            conditions[Cache.TAGS] = [conditions[Cache.TAGS]];
	          }
	          _ref1 = conditions[Cache.TAGS];
	          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	            tag = _ref1[_i];
	            _ref2 = this.findKeysByTag(tag);
	            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
	              key = _ref2[_j];
	              keys.push(key);
	              this.remove(key);
	            }
	          }
	        }
	        if (typeof conditions[Cache.PRIORITY] !== 'undefined') {
	          _ref3 = this.findKeysByPriority(conditions[Cache.PRIORITY]);
	          for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
	            key = _ref3[_k];
	            keys.push(key);
	            this.remove(key);
	          }
	        }
	        async.each(keys, function(key, cb) {
	          return _this.remove(key, function() {
	            return cb();
	          });
	        }, function() {
	          return fn();
	        });
	      }
	      return this;
	    };
	
	    Storage.prototype.findMeta = function(key, fn) {
	      return this.getMeta(function(meta) {
	        if (typeof meta[key] !== 'undefined') {
	          return fn(meta[key]);
	        } else {
	          return fn(null);
	        }
	      });
	    };
	
	    Storage.prototype.findKeysByTag = function(tag, fn) {
	      return this.getMeta(function(metas) {
	        var key, meta, result;
	        result = [];
	        for (key in metas) {
	          meta = metas[key];
	          if (typeof meta[Cache.TAGS] !== 'undefined' && meta[Cache.TAGS].indexOf(tag) !== -1) {
	            result.push(key);
	          }
	        }
	        return fn(result);
	      });
	    };
	
	    Storage.prototype.findKeysByPriority = function(priority, fn) {
	      return this.getMeta(function(metas) {
	        var key, meta, result;
	        result = [];
	        for (key in metas) {
	          meta = metas[key];
	          if (typeof meta[Cache.PRIORITY] !== 'undefined' && meta[Cache.PRIORITY] <= priority) {
	            result.push(key);
	          }
	        }
	        return fn(result);
	      });
	    };
	
	    Storage.prototype.verify = function(meta, fn) {
	      var typefn,
	        _this = this;
	      typefn = Object.prototype.toString;
	      if (typefn.call(meta) === '[object Object]') {
	        if (typeof meta[Cache.EXPIRE] !== 'undefined') {
	          if (moment().valueOf() >= meta[Cache.EXPIRE]) {
	            fn(false);
	            return null;
	          }
	        }
	        if (typeof meta[Cache.ITEMS] === 'undefined') {
	          meta[Cache.ITEMS] = [];
	        }
	        async.each(meta[Cache.ITEMS], function(item, cb) {
	          return _this.findMeta(item, function(item) {
	            if (item === null) {
	              fn(false);
	              return cb(new Error('Fake error'));
	            } else if (item !== null) {
	              return this.verify(item, function(state) {
	                if (state === false) {
	                  fn(false);
	                  return cb(new Error('Fake error'));
	                } else {
	                  return cb();
	                }
	              });
	            } else {
	              return cb();
	            }
	          });
	        }, function(err) {
	          var file, files, mtime, time, _ref1, _ref2, _ref3, _results, _results1;
	          if (!err) {
	            if (typeof meta[Cache.FILES] === 'undefined') {
	              meta[Cache.FILES] = [];
	            }
	            _this.checkFilesSupport();
	            if (isWindow) {
	              _ref1 = meta[Cache.FILES];
	              _results = [];
	              for (file in _ref1) {
	                time = _ref1[file];
	                mtime = window.require.getStats(file).mtime;
	                if (mtime === null) {
	                  throw new Error('File stats are disabled in your simq configuration. Can not get stats for ' + file + '.');
	                }
	                if (window.require.getStats(file).mtime.getTime() !== time) {
	                  _results.push(fn(false));
	                } else {
	                  _results.push(void 0);
	                }
	              }
	              return _results;
	            } else {
	              _ref2 = meta[Cache.FILES];
	              _results1 = [];
	              for (file in _ref2) {
	                time = _ref2[file];
	                files = [];
	                _ref3 = meta[Cache.FILES];
	                for (file in _ref3) {
	                  time = _ref3[file];
	                  files.push({
	                    file: file,
	                    time: time
	                  });
	                }
	                _results1.push(async.each(files, function(item, cb) {
	                  return Cache.getFs().stat(file, function(err, stats) {
	                    if (err) {
	                      return cb(err);
	                    } else {
	                      if ((new Date(stats.mtime)).getTime() !== time) {
	                        fn(false);
	                        return cb(new Error('Fake error'));
	                      }
	                    }
	                  });
	                }, function(err) {
	                  if (err && err.message === 'Fake error') {
	
	                  } else if (err) {
	                    throw err;
	                  } else {
	                    return fn(true);
	                  }
	                }));
	              }
	              return _results1;
	            }
	          }
	        });
	      }
	      return fn(true);
	    };
	
	    Storage.prototype.parseDependencies = function(dependencies, fn) {
	      var file, files, i, item, mtime, result, time, typefn, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3;
	      typefn = Object.prototype.toString;
	      result = {};
	      if (typefn.call(dependencies) === '[object Object]') {
	        if (typeof dependencies[Cache.EXPIRE] !== 'undefined') {
	          switch (typefn.call(dependencies[Cache.EXPIRE])) {
	            case '[object String]':
	              time = moment(dependencies[Cache.EXPIRE], Cache.TIME_FORMAT);
	              break;
	            case '[object Object]':
	              time = moment().add(dependencies[Cache.EXPIRE]);
	              break;
	            default:
	              throw new Error('Expire format is not valid');
	          }
	          result[Cache.EXPIRE] = time.valueOf();
	        }
	        if (typeof dependencies[Cache.ITEMS] !== 'undefined') {
	          result[Cache.ITEMS] = [];
	          _ref1 = dependencies[Cache.ITEMS];
	          for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
	            item = _ref1[i];
	            result[Cache.ITEMS].push(this.cache.generateKey(item));
	          }
	        }
	        if (typeof dependencies[Cache.PRIORITY] !== 'undefined') {
	          result[Cache.PRIORITY] = dependencies[Cache.PRIORITY];
	        }
	        if (typeof dependencies[Cache.TAGS] !== 'undefined') {
	          result[Cache.TAGS] = dependencies[Cache.TAGS];
	        }
	        if (typeof dependencies[Cache.FILES] !== 'undefined') {
	          this.checkFilesSupport();
	          files = {};
	          if (isWindow) {
	            _ref2 = dependencies[Cache.FILES];
	            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
	              file = _ref2[_j];
	              mtime = window.require.getStats(file).mtime;
	              if (mtime === null) {
	                throw new Error('File stats are disabled in your simq configuration. Can not get stats for ' + file + '.');
	              }
	              file = window.require.resolve(file);
	              files[file] = mtime.getTime();
	            }
	          } else {
	            async.each(dependencies[Cache.FILES], function(file, cb) {
	              file = path.resolve(file);
	              return Cache.getFs().stat(file, function(err, stats) {
	                if (err) {
	                  return cb(err);
	                } else {
	                  files[file] = (new Date(stats.mtime)).getTime();
	                  return cb();
	                }
	              });
	            }, function(err) {
	              if (err) {
	                throw err;
	              } else {
	                result[Cache.FILES] = files;
	                return fn(result);
	              }
	            });
	            _ref3 = dependencies[Cache.FILES];
	            for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
	              file = _ref3[_k];
	              file = path.resolve(file);
	              files[file] = (new Date(Cache.getFs().statSync(file).mtime)).getTime();
	            }
	          }
	          return result[Cache.FILES] = files;
	        } else {
	          return fn(result);
	        }
	      } else {
	        return fn(result);
	      }
	    };
	
	    return Storage;
	
	  })(BaseStorage);
	
	  module.exports = Storage;
	
	}).call(this);
	

}, 'async/lib/async.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'async/lib/async.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'async/lib/async.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'async/lib/async.js';
	var __dirname = 'async/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'async/lib/async.js'], env: {}};

	/** code **/
	/*global setImmediate: false, setTimeout: false, console: false */
	(function () {
	
	    var async = {};
	
	    // global on the server, window in the browser
	    var root, previous_async;
	
	    root = this;
	    if (root != null) {
	      previous_async = root.async;
	    }
	
	    async.noConflict = function () {
	        root.async = previous_async;
	        return async;
	    };
	
	    function only_once(fn) {
	        var called = false;
	        return function() {
	            if (called) throw new Error("Callback was already called.");
	            called = true;
	            fn.apply(root, arguments);
	        }
	    }
	
	    //// cross-browser compatiblity functions ////
	
	    var _each = function (arr, iterator) {
	        if (arr.forEach) {
	            return arr.forEach(iterator);
	        }
	        for (var i = 0; i < arr.length; i += 1) {
	            iterator(arr[i], i, arr);
	        }
	    };
	
	    var _map = function (arr, iterator) {
	        if (arr.map) {
	            return arr.map(iterator);
	        }
	        var results = [];
	        _each(arr, function (x, i, a) {
	            results.push(iterator(x, i, a));
	        });
	        return results;
	    };
	
	    var _reduce = function (arr, iterator, memo) {
	        if (arr.reduce) {
	            return arr.reduce(iterator, memo);
	        }
	        _each(arr, function (x, i, a) {
	            memo = iterator(memo, x, i, a);
	        });
	        return memo;
	    };
	
	    var _keys = function (obj) {
	        if (Object.keys) {
	            return Object.keys(obj);
	        }
	        var keys = [];
	        for (var k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                keys.push(k);
	            }
	        }
	        return keys;
	    };
	
	    //// exported async module functions ////
	
	    //// nextTick implementation with browser-compatible fallback ////
	    if (typeof process === 'undefined' || !(process.nextTick)) {
	        if (typeof setImmediate === 'function') {
	            async.nextTick = function (fn) {
	                // not a direct alias for IE10 compatibility
	                setImmediate(fn);
	            };
	            async.setImmediate = async.nextTick;
	        }
	        else {
	            async.nextTick = function (fn) {
	                setTimeout(fn, 0);
	            };
	            async.setImmediate = async.nextTick;
	        }
	    }
	    else {
	        async.nextTick = process.nextTick;
	        if (typeof setImmediate !== 'undefined') {
	            async.setImmediate = setImmediate;
	        }
	        else {
	            async.setImmediate = async.nextTick;
	        }
	    }
	
	    async.each = function (arr, iterator, callback) {
	        callback = callback || function () {};
	        if (!arr.length) {
	            return callback();
	        }
	        var completed = 0;
	        _each(arr, function (x) {
	            iterator(x, only_once(function (err) {
	                if (err) {
	                    callback(err);
	                    callback = function () {};
	                }
	                else {
	                    completed += 1;
	                    if (completed >= arr.length) {
	                        callback(null);
	                    }
	                }
	            }));
	        });
	    };
	    async.forEach = async.each;
	
	    async.eachSeries = function (arr, iterator, callback) {
	        callback = callback || function () {};
	        if (!arr.length) {
	            return callback();
	        }
	        var completed = 0;
	        var iterate = function () {
	            iterator(arr[completed], function (err) {
	                if (err) {
	                    callback(err);
	                    callback = function () {};
	                }
	                else {
	                    completed += 1;
	                    if (completed >= arr.length) {
	                        callback(null);
	                    }
	                    else {
	                        iterate();
	                    }
	                }
	            });
	        };
	        iterate();
	    };
	    async.forEachSeries = async.eachSeries;
	
	    async.eachLimit = function (arr, limit, iterator, callback) {
	        var fn = _eachLimit(limit);
	        fn.apply(null, [arr, iterator, callback]);
	    };
	    async.forEachLimit = async.eachLimit;
	
	    var _eachLimit = function (limit) {
	
	        return function (arr, iterator, callback) {
	            callback = callback || function () {};
	            if (!arr.length || limit <= 0) {
	                return callback();
	            }
	            var completed = 0;
	            var started = 0;
	            var running = 0;
	
	            (function replenish () {
	                if (completed >= arr.length) {
	                    return callback();
	                }
	
	                while (running < limit && started < arr.length) {
	                    started += 1;
	                    running += 1;
	                    iterator(arr[started - 1], function (err) {
	                        if (err) {
	                            callback(err);
	                            callback = function () {};
	                        }
	                        else {
	                            completed += 1;
	                            running -= 1;
	                            if (completed >= arr.length) {
	                                callback();
	                            }
	                            else {
	                                replenish();
	                            }
	                        }
	                    });
	                }
	            })();
	        };
	    };
	
	
	    var doParallel = function (fn) {
	        return function () {
	            var args = Array.prototype.slice.call(arguments);
	            return fn.apply(null, [async.each].concat(args));
	        };
	    };
	    var doParallelLimit = function(limit, fn) {
	        return function () {
	            var args = Array.prototype.slice.call(arguments);
	            return fn.apply(null, [_eachLimit(limit)].concat(args));
	        };
	    };
	    var doSeries = function (fn) {
	        return function () {
	            var args = Array.prototype.slice.call(arguments);
	            return fn.apply(null, [async.eachSeries].concat(args));
	        };
	    };
	
	
	    var _asyncMap = function (eachfn, arr, iterator, callback) {
	        var results = [];
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        eachfn(arr, function (x, callback) {
	            iterator(x.value, function (err, v) {
	                results[x.index] = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, results);
	        });
	    };
	    async.map = doParallel(_asyncMap);
	    async.mapSeries = doSeries(_asyncMap);
	    async.mapLimit = function (arr, limit, iterator, callback) {
	        return _mapLimit(limit)(arr, iterator, callback);
	    };
	
	    var _mapLimit = function(limit) {
	        return doParallelLimit(limit, _asyncMap);
	    };
	
	    // reduce only has a series version, as doing reduce in parallel won't
	    // work in many situations.
	    async.reduce = function (arr, memo, iterator, callback) {
	        async.eachSeries(arr, function (x, callback) {
	            iterator(memo, x, function (err, v) {
	                memo = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, memo);
	        });
	    };
	    // inject alias
	    async.inject = async.reduce;
	    // foldl alias
	    async.foldl = async.reduce;
	
	    async.reduceRight = function (arr, memo, iterator, callback) {
	        var reversed = _map(arr, function (x) {
	            return x;
	        }).reverse();
	        async.reduce(reversed, memo, iterator, callback);
	    };
	    // foldr alias
	    async.foldr = async.reduceRight;
	
	    var _filter = function (eachfn, arr, iterator, callback) {
	        var results = [];
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        eachfn(arr, function (x, callback) {
	            iterator(x.value, function (v) {
	                if (v) {
	                    results.push(x);
	                }
	                callback();
	            });
	        }, function (err) {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    };
	    async.filter = doParallel(_filter);
	    async.filterSeries = doSeries(_filter);
	    // select alias
	    async.select = async.filter;
	    async.selectSeries = async.filterSeries;
	
	    var _reject = function (eachfn, arr, iterator, callback) {
	        var results = [];
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        eachfn(arr, function (x, callback) {
	            iterator(x.value, function (v) {
	                if (!v) {
	                    results.push(x);
	                }
	                callback();
	            });
	        }, function (err) {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    };
	    async.reject = doParallel(_reject);
	    async.rejectSeries = doSeries(_reject);
	
	    var _detect = function (eachfn, arr, iterator, main_callback) {
	        eachfn(arr, function (x, callback) {
	            iterator(x, function (result) {
	                if (result) {
	                    main_callback(x);
	                    main_callback = function () {};
	                }
	                else {
	                    callback();
	                }
	            });
	        }, function (err) {
	            main_callback();
	        });
	    };
	    async.detect = doParallel(_detect);
	    async.detectSeries = doSeries(_detect);
	
	    async.some = function (arr, iterator, main_callback) {
	        async.each(arr, function (x, callback) {
	            iterator(x, function (v) {
	                if (v) {
	                    main_callback(true);
	                    main_callback = function () {};
	                }
	                callback();
	            });
	        }, function (err) {
	            main_callback(false);
	        });
	    };
	    // any alias
	    async.any = async.some;
	
	    async.every = function (arr, iterator, main_callback) {
	        async.each(arr, function (x, callback) {
	            iterator(x, function (v) {
	                if (!v) {
	                    main_callback(false);
	                    main_callback = function () {};
	                }
	                callback();
	            });
	        }, function (err) {
	            main_callback(true);
	        });
	    };
	    // all alias
	    async.all = async.every;
	
	    async.sortBy = function (arr, iterator, callback) {
	        async.map(arr, function (x, callback) {
	            iterator(x, function (err, criteria) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    callback(null, {value: x, criteria: criteria});
	                }
	            });
	        }, function (err, results) {
	            if (err) {
	                return callback(err);
	            }
	            else {
	                var fn = function (left, right) {
	                    var a = left.criteria, b = right.criteria;
	                    return a < b ? -1 : a > b ? 1 : 0;
	                };
	                callback(null, _map(results.sort(fn), function (x) {
	                    return x.value;
	                }));
	            }
	        });
	    };
	
	    async.auto = function (tasks, callback) {
	        callback = callback || function () {};
	        var keys = _keys(tasks);
	        if (!keys.length) {
	            return callback(null);
	        }
	
	        var results = {};
	
	        var listeners = [];
	        var addListener = function (fn) {
	            listeners.unshift(fn);
	        };
	        var removeListener = function (fn) {
	            for (var i = 0; i < listeners.length; i += 1) {
	                if (listeners[i] === fn) {
	                    listeners.splice(i, 1);
	                    return;
	                }
	            }
	        };
	        var taskComplete = function () {
	            _each(listeners.slice(0), function (fn) {
	                fn();
	            });
	        };
	
	        addListener(function () {
	            if (_keys(results).length === keys.length) {
	                callback(null, results);
	                callback = function () {};
	            }
	        });
	
	        _each(keys, function (k) {
	            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
	            var taskCallback = function (err) {
	                var args = Array.prototype.slice.call(arguments, 1);
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                if (err) {
	                    var safeResults = {};
	                    _each(_keys(results), function(rkey) {
	                        safeResults[rkey] = results[rkey];
	                    });
	                    safeResults[k] = args;
	                    callback(err, safeResults);
	                    // stop subsequent errors hitting callback multiple times
	                    callback = function () {};
	                }
	                else {
	                    results[k] = args;
	                    async.setImmediate(taskComplete);
	                }
	            };
	            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
	            var ready = function () {
	                return _reduce(requires, function (a, x) {
	                    return (a && results.hasOwnProperty(x));
	                }, true) && !results.hasOwnProperty(k);
	            };
	            if (ready()) {
	                task[task.length - 1](taskCallback, results);
	            }
	            else {
	                var listener = function () {
	                    if (ready()) {
	                        removeListener(listener);
	                        task[task.length - 1](taskCallback, results);
	                    }
	                };
	                addListener(listener);
	            }
	        });
	    };
	
	    async.waterfall = function (tasks, callback) {
	        callback = callback || function () {};
	        if (tasks.constructor !== Array) {
	          var err = new Error('First argument to waterfall must be an array of functions');
	          return callback(err);
	        }
	        if (!tasks.length) {
	            return callback();
	        }
	        var wrapIterator = function (iterator) {
	            return function (err) {
	                if (err) {
	                    callback.apply(null, arguments);
	                    callback = function () {};
	                }
	                else {
	                    var args = Array.prototype.slice.call(arguments, 1);
	                    var next = iterator.next();
	                    if (next) {
	                        args.push(wrapIterator(next));
	                    }
	                    else {
	                        args.push(callback);
	                    }
	                    async.setImmediate(function () {
	                        iterator.apply(null, args);
	                    });
	                }
	            };
	        };
	        wrapIterator(async.iterator(tasks))();
	    };
	
	    var _parallel = function(eachfn, tasks, callback) {
	        callback = callback || function () {};
	        if (tasks.constructor === Array) {
	            eachfn.map(tasks, function (fn, callback) {
	                if (fn) {
	                    fn(function (err) {
	                        var args = Array.prototype.slice.call(arguments, 1);
	                        if (args.length <= 1) {
	                            args = args[0];
	                        }
	                        callback.call(null, err, args);
	                    });
	                }
	            }, callback);
	        }
	        else {
	            var results = {};
	            eachfn.each(_keys(tasks), function (k, callback) {
	                tasks[k](function (err) {
	                    var args = Array.prototype.slice.call(arguments, 1);
	                    if (args.length <= 1) {
	                        args = args[0];
	                    }
	                    results[k] = args;
	                    callback(err);
	                });
	            }, function (err) {
	                callback(err, results);
	            });
	        }
	    };
	
	    async.parallel = function (tasks, callback) {
	        _parallel({ map: async.map, each: async.each }, tasks, callback);
	    };
	
	    async.parallelLimit = function(tasks, limit, callback) {
	        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
	    };
	
	    async.series = function (tasks, callback) {
	        callback = callback || function () {};
	        if (tasks.constructor === Array) {
	            async.mapSeries(tasks, function (fn, callback) {
	                if (fn) {
	                    fn(function (err) {
	                        var args = Array.prototype.slice.call(arguments, 1);
	                        if (args.length <= 1) {
	                            args = args[0];
	                        }
	                        callback.call(null, err, args);
	                    });
	                }
	            }, callback);
	        }
	        else {
	            var results = {};
	            async.eachSeries(_keys(tasks), function (k, callback) {
	                tasks[k](function (err) {
	                    var args = Array.prototype.slice.call(arguments, 1);
	                    if (args.length <= 1) {
	                        args = args[0];
	                    }
	                    results[k] = args;
	                    callback(err);
	                });
	            }, function (err) {
	                callback(err, results);
	            });
	        }
	    };
	
	    async.iterator = function (tasks) {
	        var makeCallback = function (index) {
	            var fn = function () {
	                if (tasks.length) {
	                    tasks[index].apply(null, arguments);
	                }
	                return fn.next();
	            };
	            fn.next = function () {
	                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
	            };
	            return fn;
	        };
	        return makeCallback(0);
	    };
	
	    async.apply = function (fn) {
	        var args = Array.prototype.slice.call(arguments, 1);
	        return function () {
	            return fn.apply(
	                null, args.concat(Array.prototype.slice.call(arguments))
	            );
	        };
	    };
	
	    var _concat = function (eachfn, arr, fn, callback) {
	        var r = [];
	        eachfn(arr, function (x, cb) {
	            fn(x, function (err, y) {
	                r = r.concat(y || []);
	                cb(err);
	            });
	        }, function (err) {
	            callback(err, r);
	        });
	    };
	    async.concat = doParallel(_concat);
	    async.concatSeries = doSeries(_concat);
	
	    async.whilst = function (test, iterator, callback) {
	        if (test()) {
	            iterator(function (err) {
	                if (err) {
	                    return callback(err);
	                }
	                async.whilst(test, iterator, callback);
	            });
	        }
	        else {
	            callback();
	        }
	    };
	
	    async.doWhilst = function (iterator, test, callback) {
	        iterator(function (err) {
	            if (err) {
	                return callback(err);
	            }
	            if (test()) {
	                async.doWhilst(iterator, test, callback);
	            }
	            else {
	                callback();
	            }
	        });
	    };
	
	    async.until = function (test, iterator, callback) {
	        if (!test()) {
	            iterator(function (err) {
	                if (err) {
	                    return callback(err);
	                }
	                async.until(test, iterator, callback);
	            });
	        }
	        else {
	            callback();
	        }
	    };
	
	    async.doUntil = function (iterator, test, callback) {
	        iterator(function (err) {
	            if (err) {
	                return callback(err);
	            }
	            if (!test()) {
	                async.doUntil(iterator, test, callback);
	            }
	            else {
	                callback();
	            }
	        });
	    };
	
	    async.queue = function (worker, concurrency) {
	        if (concurrency === undefined) {
	            concurrency = 1;
	        }
	        function _insert(q, data, pos, callback) {
	          if(data.constructor !== Array) {
	              data = [data];
	          }
	          _each(data, function(task) {
	              var item = {
	                  data: task,
	                  callback: typeof callback === 'function' ? callback : null
	              };
	
	              if (pos) {
	                q.tasks.unshift(item);
	              } else {
	                q.tasks.push(item);
	              }
	
	              if (q.saturated && q.tasks.length === concurrency) {
	                  q.saturated();
	              }
	              async.setImmediate(q.process);
	          });
	        }
	
	        var workers = 0;
	        var q = {
	            tasks: [],
	            concurrency: concurrency,
	            saturated: null,
	            empty: null,
	            drain: null,
	            push: function (data, callback) {
	              _insert(q, data, false, callback);
	            },
	            unshift: function (data, callback) {
	              _insert(q, data, true, callback);
	            },
	            process: function () {
	                if (workers < q.concurrency && q.tasks.length) {
	                    var task = q.tasks.shift();
	                    if (q.empty && q.tasks.length === 0) {
	                        q.empty();
	                    }
	                    workers += 1;
	                    var next = function () {
	                        workers -= 1;
	                        if (task.callback) {
	                            task.callback.apply(task, arguments);
	                        }
	                        if (q.drain && q.tasks.length + workers === 0) {
	                            q.drain();
	                        }
	                        q.process();
	                    };
	                    var cb = only_once(next);
	                    worker(task.data, cb);
	                }
	            },
	            length: function () {
	                return q.tasks.length;
	            },
	            running: function () {
	                return workers;
	            }
	        };
	        return q;
	    };
	
	    async.cargo = function (worker, payload) {
	        var working     = false,
	            tasks       = [];
	
	        var cargo = {
	            tasks: tasks,
	            payload: payload,
	            saturated: null,
	            empty: null,
	            drain: null,
	            push: function (data, callback) {
	                if(data.constructor !== Array) {
	                    data = [data];
	                }
	                _each(data, function(task) {
	                    tasks.push({
	                        data: task,
	                        callback: typeof callback === 'function' ? callback : null
	                    });
	                    if (cargo.saturated && tasks.length === payload) {
	                        cargo.saturated();
	                    }
	                });
	                async.setImmediate(cargo.process);
	            },
	            process: function process() {
	                if (working) return;
	                if (tasks.length === 0) {
	                    if(cargo.drain) cargo.drain();
	                    return;
	                }
	
	                var ts = typeof payload === 'number'
	                            ? tasks.splice(0, payload)
	                            : tasks.splice(0);
	
	                var ds = _map(ts, function (task) {
	                    return task.data;
	                });
	
	                if(cargo.empty) cargo.empty();
	                working = true;
	                worker(ds, function () {
	                    working = false;
	
	                    var args = arguments;
	                    _each(ts, function (data) {
	                        if (data.callback) {
	                            data.callback.apply(null, args);
	                        }
	                    });
	
	                    process();
	                });
	            },
	            length: function () {
	                return tasks.length;
	            },
	            running: function () {
	                return working;
	            }
	        };
	        return cargo;
	    };
	
	    var _console_fn = function (name) {
	        return function (fn) {
	            var args = Array.prototype.slice.call(arguments, 1);
	            fn.apply(null, args.concat([function (err) {
	                var args = Array.prototype.slice.call(arguments, 1);
	                if (typeof console !== 'undefined') {
	                    if (err) {
	                        if (console.error) {
	                            console.error(err);
	                        }
	                    }
	                    else if (console[name]) {
	                        _each(args, function (x) {
	                            console[name](x);
	                        });
	                    }
	                }
	            }]));
	        };
	    };
	    async.log = _console_fn('log');
	    async.dir = _console_fn('dir');
	    /*async.info = _console_fn('info');
	    async.warn = _console_fn('warn');
	    async.error = _console_fn('error');*/
	
	    async.memoize = function (fn, hasher) {
	        var memo = {};
	        var queues = {};
	        hasher = hasher || function (x) {
	            return x;
	        };
	        var memoized = function () {
	            var args = Array.prototype.slice.call(arguments);
	            var callback = args.pop();
	            var key = hasher.apply(null, args);
	            if (key in memo) {
	                callback.apply(null, memo[key]);
	            }
	            else if (key in queues) {
	                queues[key].push(callback);
	            }
	            else {
	                queues[key] = [callback];
	                fn.apply(null, args.concat([function () {
	                    memo[key] = arguments;
	                    var q = queues[key];
	                    delete queues[key];
	                    for (var i = 0, l = q.length; i < l; i++) {
	                      q[i].apply(null, arguments);
	                    }
	                }]));
	            }
	        };
	        memoized.memo = memo;
	        memoized.unmemoized = fn;
	        return memoized;
	    };
	
	    async.unmemoize = function (fn) {
	      return function () {
	        return (fn.unmemoized || fn).apply(null, arguments);
	      };
	    };
	
	    async.times = function (count, iterator, callback) {
	        var counter = [];
	        for (var i = 0; i < count; i++) {
	            counter.push(i);
	        }
	        return async.map(counter, iterator, callback);
	    };
	
	    async.timesSeries = function (count, iterator, callback) {
	        var counter = [];
	        for (var i = 0; i < count; i++) {
	            counter.push(i);
	        }
	        return async.mapSeries(counter, iterator, callback);
	    };
	
	    async.compose = function (/* functions... */) {
	        var fns = Array.prototype.reverse.call(arguments);
	        return function () {
	            var that = this;
	            var args = Array.prototype.slice.call(arguments);
	            var callback = args.pop();
	            async.reduce(fns, args, function (newargs, fn, cb) {
	                fn.apply(that, newargs.concat([function () {
	                    var err = arguments[0];
	                    var nextargs = Array.prototype.slice.call(arguments, 1);
	                    cb(err, nextargs);
	                }]))
	            },
	            function (err, results) {
	                callback.apply(that, [err].concat(results));
	            });
	        };
	    };
	
	    var _applyEach = function (eachfn, fns /*args...*/) {
	        var go = function () {
	            var that = this;
	            var args = Array.prototype.slice.call(arguments);
	            var callback = args.pop();
	            return eachfn(fns, function (fn, cb) {
	                fn.apply(that, args.concat([cb]));
	            },
	            callback);
	        };
	        if (arguments.length > 2) {
	            var args = Array.prototype.slice.call(arguments, 2);
	            return go.apply(this, args);
	        }
	        else {
	            return go;
	        }
	    };
	    async.applyEach = doParallel(_applyEach);
	    async.applyEachSeries = doSeries(_applyEach);
	
	    async.forever = function (fn, callback) {
	        function next(err) {
	            if (err) {
	                if (callback) {
	                    return callback(err);
	                }
	                throw err;
	            }
	            fn(next);
	        }
	        next();
	    };
	
	    // AMD / RequireJS
	    if (typeof define !== 'undefined' && define.amd) {
	        define([], function () {
	            return async;
	        });
	    }
	    // Node.js
	    else if (typeof module !== 'undefined' && module.exports) {
	        module.exports = async;
	    }
	    // included directly via <script> tag
	    else {
	        root.async = async;
	    }
	
	}());
	

}, '/lib/Storage/Sync/DevNullStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Sync/DevNullStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Sync/DevNullStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Sync/DevNullStorage.js';
	var __dirname = '/lib/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Sync/DevNullStorage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var DevNullStorage, Storage, _ref,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  Storage = require('./Storage');
	
	  DevNullStorage = (function(_super) {
	    __extends(DevNullStorage, _super);
	
	    function DevNullStorage() {
	      _ref = DevNullStorage.__super__.constructor.apply(this, arguments);
	      return _ref;
	    }
	
	    DevNullStorage.prototype.getData = function() {
	      return {};
	    };
	
	    DevNullStorage.prototype.getMeta = function() {
	      return {};
	    };
	
	    DevNullStorage.prototype.writeData = function(data, meta) {
	      return this;
	    };
	
	    DevNullStorage.prototype.read = function(key) {
	      return null;
	    };
	
	    DevNullStorage.prototype.write = function(key, data, dependencies) {
	      if (dependencies == null) {
	        dependencies = {};
	      }
	      return this;
	    };
	
	    DevNullStorage.prototype.remove = function(key) {
	      return this;
	    };
	
	    return DevNullStorage;
	
	  })(Storage);
	
	  module.exports = DevNullStorage;
	
	}).call(this);
	

}, '/lib/Storage/Sync/FileStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Sync/FileStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Sync/FileStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Sync/FileStorage.js';
	var __dirname = '/lib/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Sync/FileStorage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Cache, FileStorage, Storage, fs, path,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  Storage = require('./Storage');
	
	  Cache = require('../../Cache');
	
	  fs = null;
	
	  path = null;
	
	  FileStorage = (function(_super) {
	    __extends(FileStorage, _super);
	
	    FileStorage.prototype.directory = null;
	
	    FileStorage.prototype.allData = null;
	
	    FileStorage.prototype.data = null;
	
	    FileStorage.prototype.meta = null;
	
	    function FileStorage(directory) {
	      this.directory = directory;
	      if (typeof window !== 'undefined') {
	        throw new Error('FileStorage: Can not use this storage in browser');
	      }
	      fs = require('fs');
	      path = require('path');
	      this.directory = path.resolve(this.directory);
	      if (!Cache.getFs().existsSync(this.directory)) {
	        throw new Error('FileStorage: directory ' + this.directory + ' does not exists');
	      }
	      if (!Cache.getFs().statSync(this.directory).isDirectory()) {
	        throw new Error('FileStorage: path ' + this.directory + ' must be directory');
	      }
	    }
	
	    FileStorage.prototype.getFileName = function() {
	      return this.directory + '/__' + this.cache.namespace + '.json';
	    };
	
	    FileStorage.prototype.loadData = function() {
	      var file;
	      if (this.allData === null) {
	        file = this.getFileName();
	        if (Cache.getFs().existsSync(file)) {
	          this.allData = JSON.parse(Cache.getFs().readFileSync(file, {
	            encoding: 'utf8'
	          }));
	        } else {
	          this.allData = {
	            data: {},
	            meta: {}
	          };
	        }
	      }
	      return this.allData;
	    };
	
	    FileStorage.prototype.getData = function() {
	      if (this.data === null) {
	        this.data = this.loadData().data;
	      }
	      return this.data;
	    };
	
	    FileStorage.prototype.getMeta = function() {
	      if (this.meta === null) {
	        this.meta = this.loadData().meta;
	      }
	      return this.meta;
	    };
	
	    FileStorage.prototype.writeData = function(data, meta) {
	      var file;
	      this.data = data;
	      this.meta = meta;
	      file = this.getFileName();
	      Cache.getFs().writeFileSync(file, JSON.stringify({
	        data: this.data,
	        meta: this.meta
	      }));
	      return this;
	    };
	
	    return FileStorage;
	
	  })(Storage);
	
	  module.exports = FileStorage;
	
	}).call(this);
	

}, '/lib/Storage/Sync/MemoryStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Sync/MemoryStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Sync/MemoryStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Sync/MemoryStorage.js';
	var __dirname = '/lib/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Sync/MemoryStorage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var MemoryStorage, Storage, _ref,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  Storage = require('./Storage');
	
	  MemoryStorage = (function(_super) {
	    __extends(MemoryStorage, _super);
	
	    function MemoryStorage() {
	      _ref = MemoryStorage.__super__.constructor.apply(this, arguments);
	      return _ref;
	    }
	
	    MemoryStorage.prototype.data = null;
	
	    MemoryStorage.prototype.meta = null;
	
	    MemoryStorage.prototype.getData = function() {
	      if (this.data === null) {
	        this.data = {};
	      }
	      return this.data;
	    };
	
	    MemoryStorage.prototype.getMeta = function() {
	      if (this.meta === null) {
	        this.meta = {};
	      }
	      return this.meta;
	    };
	
	    MemoryStorage.prototype.writeData = function(data, meta) {
	      this.data = data;
	      this.meta = meta;
	      return this;
	    };
	
	    return MemoryStorage;
	
	  })(Storage);
	
	  module.exports = MemoryStorage;
	
	}).call(this);
	

}, '/Storage/BrowserLocalStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/Storage/BrowserLocalStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/Storage/BrowserLocalStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/Storage/BrowserLocalStorage.js';
	var __dirname = '/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/Storage/BrowserLocalStorage.js'], env: {}};

	/** code **/
	module.exports = require('../lib/Storage/Sync/BrowserLocalStorage');

}, '/Storage/DevNullAsyncStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/Storage/DevNullAsyncStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/Storage/DevNullAsyncStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/Storage/DevNullAsyncStorage.js';
	var __dirname = '/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/Storage/DevNullAsyncStorage.js'], env: {}};

	/** code **/
	module.exports = require('../lib/Storage/Async/DevNullStorage');

}, '/Storage/DevNullStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/Storage/DevNullStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/Storage/DevNullStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/Storage/DevNullStorage.js';
	var __dirname = '/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/Storage/DevNullStorage.js'], env: {}};

	/** code **/
	console.log('DevNullStorage is deprecated, use DevNullSyncStorage instead.');
	
	module.exports = require('../lib/Storage/Sync/DevNullStorage');

}, '/Storage/DevNullSyncStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/Storage/DevNullSyncStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/Storage/DevNullSyncStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/Storage/DevNullSyncStorage.js';
	var __dirname = '/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/Storage/DevNullSyncStorage.js'], env: {}};

	/** code **/
	module.exports = require('../lib/Storage/Sync/DevNullStorage');

}, '/Storage/FileStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/Storage/FileStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/Storage/FileStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/Storage/FileStorage.js';
	var __dirname = '/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/Storage/FileStorage.js'], env: {}};

	/** code **/
	module.exports = require('../lib/Storage/Sync/FileStorage');

}, '/Storage/MemoryStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/Storage/MemoryStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/Storage/MemoryStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/Storage/MemoryStorage.js';
	var __dirname = '/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/Storage/MemoryStorage.js'], env: {}};

	/** code **/
	module.exports = require('../lib/Storage/Sync/MemoryStorage');

}, '/test/browser/tests/Cache.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/browser/tests/Cache.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/browser/tests/Cache.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/browser/tests/Cache.coffee';
	var __dirname = '/test/browser/tests';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/browser/tests/Cache.coffee'], env: {}};

	/** code **/
	(function() {
	  var Cache;
	
	  Cache = require('cache-storage');
	
	  describe('Cache', function() {
	    return describe('#constructor()', function() {
	      return it('should throw an error if storage is not an instance of Cache Storage', function() {
	        return expect(function() {
	          return new Cache(new Array);
	        }).to["throw"](Error);
	      });
	    });
	  });
	
	}).call(this);
	

}, '/test/browser/tests/Storage/Sync/BrowserLocalStorage.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/browser/tests/Storage/Sync/BrowserLocalStorage.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/browser/tests/Storage/Sync/BrowserLocalStorage.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/browser/tests/Storage/Sync/BrowserLocalStorage.coffee';
	var __dirname = '/test/browser/tests/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/browser/tests/Storage/Sync/BrowserLocalStorage.coffee'], env: {}};

	/** code **/
	(function() {
	  var BrowserLocalStorage, Cache, cache, originalSimqVersion;
	
	  Cache = require('cache-storage');
	
	  BrowserLocalStorage = require('cache-storage/Storage/BrowserLocalStorage');
	
	  cache = null;
	
	  originalSimqVersion = window.require.version;
	
	  describe('BrowserLocalStorage', function() {
	    beforeEach(function() {
	      return cache = new Cache(new BrowserLocalStorage);
	    });
	    afterEach(function() {
	      return localStorage.clear();
	    });
	    describe('saving/loading', function() {
	      it('should save true and load it', function() {
	        cache.save('true', true);
	        return expect(cache.load('true')).to.be["true"];
	      });
	      it('should return null if item not exists', function() {
	        return expect(cache.load('true')).to.be["null"];
	      });
	      it('should save true and delete it', function() {
	        cache.save('true', true);
	        cache.remove('true');
	        return expect(cache.load('true')).to.be["null"];
	      });
	      return it('should save true to cache from fallback function in load', function() {
	        var val;
	        val = cache.load('true', function() {
	          return true;
	        });
	        return expect(val).to.be["true"];
	      });
	    });
	    return describe('expiration', function() {
	      it('should remove all items with tag "article"', function() {
	        cache.save('one', 'one', {
	          tags: ['article']
	        });
	        cache.save('two', 'two', {
	          tags: ['category']
	        });
	        cache.save('three', 'three', {
	          tags: ['article']
	        });
	        cache.clean({
	          tags: ['article']
	        });
	        expect(cache.load('one')).to.be["null"];
	        expect(cache.load('two')).to.be.equal('two');
	        return expect(cache.load('three')).to.be["null"];
	      });
	      it('should expire "true" value after 1 second"', function(done) {
	        cache.save('true', true, {
	          expire: {
	            seconds: 1
	          }
	        });
	        return setTimeout(function() {
	          expect(cache.load('true')).to.be["null"];
	          return done();
	        }, 1100);
	      });
	      it('should expire "true" value after "first" value expire', function() {
	        cache.save('first', 'first');
	        cache.save('true', true, {
	          items: ['first']
	        });
	        cache.remove('first');
	        return expect(cache.load('true')).to.be["null"];
	      });
	      it('should expire all items with priority bellow 50', function() {
	        cache.save('one', 'one', {
	          priority: 100
	        });
	        cache.save('two', 'two', {
	          priority: 10
	        });
	        cache.clean({
	          priority: 50
	        });
	        expect(cache.load('one')).to.be.equal('one');
	        return expect(cache.load('two')).to.be["null"];
	      });
	      it('should remove all items from cache', function() {
	        cache.save('one', 'one');
	        cache.save('two', 'two');
	        cache.clean('all');
	        expect(cache.load('one')).to.be["null"];
	        return expect(cache.load('two')).to.be["null"];
	      });
	      return describe('files', function() {
	        afterEach(function() {
	          window.require.simq = true;
	          return window.require.version = originalSimqVersion;
	        });
	        it('should throw an error for environments other than simq', function() {
	          delete window.require.simq;
	          return expect(function() {
	            return cache.save('true', true, {
	              files: []
	            });
	          }).to["throw"](Error, 'Files meta information can be used in browser only with simq.');
	        });
	        it('should throw an error if simq is old', function() {
	          window.require.version = '5.0.4';
	          return expect(function() {
	            return cache.save('true', true, {
	              files: []
	            });
	          }).to["throw"](Error, 'File method information is supported only with simq@5.1.0 and later.');
	        });
	        it('should throw an error if simq is really very old', function() {
	          delete window.require.version;
	          return expect(function() {
	            return cache.save('true', true, {
	              files: []
	            });
	          }).to["throw"](Error, 'File method information is supported only with simq@5.1.0 and later.');
	        });
	        return it('should expire data after file is changed', function() {
	          var newStats, oldStats, stats;
	          cache.save('true', true, {
	            files: [__filename]
	          });
	          stats = window.require.getStats(__filename);
	          oldStats = {};
	          oldStats[__filename] = stats;
	          newStats = {};
	          newStats[window.require.resolve(__filename)] = {
	            atime: stats.atime.getTime(),
	            mtime: (new Date(stats.mtime.getTime())).setHours(stats.mtime.getHours() + 1),
	            ctime: stats.ctime.getTime()
	          };
	          window.require.__setStats(newStats);
	          expect(cache.load('true')).to.be["null"];
	          return window.require.__setStats(oldStats);
	        });
	      });
	    });
	  });
	
	}).call(this);
	

}, '/test/browser/tests/Storage/Sync/DevNullStorage.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/browser/tests/Storage/Sync/DevNullStorage.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/browser/tests/Storage/Sync/DevNullStorage.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/browser/tests/Storage/Sync/DevNullStorage.coffee';
	var __dirname = '/test/browser/tests/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/browser/tests/Storage/Sync/DevNullStorage.coffee'], env: {}};

	/** code **/
	(function() {
	  var Cache, DevNullStorage, cache;
	
	  Cache = require('cache-storage');
	
	  DevNullStorage = require('cache-storage/Storage/DevNullSyncStorage');
	
	  cache = null;
	
	  describe('DevNullSyncStorage', function() {
	    beforeEach(function() {
	      return cache = new Cache(new DevNullStorage);
	    });
	    return describe('saving/loading', function() {
	      it('should not save true', function() {
	        cache.save('true', true);
	        return expect(cache.load('true')).to.be["null"];
	      });
	      it('should always return null', function() {
	        return expect(cache.load('true')).to.be["null"];
	      });
	      it('should not save true and try to delete it', function() {
	        cache.save('true', true);
	        cache.remove('true');
	        return expect(cache.load('true')).to.be["null"];
	      });
	      return it('should not save true to cache from fallback function in load', function() {
	        var val;
	        val = cache.load('true', function() {
	          return true;
	        });
	        expect(val).to.be["true"];
	        return expect(cache.load('true')).to.be["null"];
	      });
	    });
	  });
	
	}).call(this);
	

}, '/test/browser/tests/Storage/Sync/FileStorage.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/browser/tests/Storage/Sync/FileStorage.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/browser/tests/Storage/Sync/FileStorage.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/browser/tests/Storage/Sync/FileStorage.coffee';
	var __dirname = '/test/browser/tests/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/browser/tests/Storage/Sync/FileStorage.coffee'], env: {}};

	/** code **/
	(function() {
	  var FileStorage;
	
	  FileStorage = require('cache-storage/Storage/FileStorage');
	
	  describe('FileStorage', function() {
	    return describe('#constructor()', function() {
	      return it('should throw an error on browser', function() {
	        return expect(function() {
	          return new FileStorage;
	        }).to["throw"](Error);
	      });
	    });
	  });
	
	}).call(this);
	

}, '/test/browser/tests/Storage/Sync/MemoryStorage.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/browser/tests/Storage/Sync/MemoryStorage.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/browser/tests/Storage/Sync/MemoryStorage.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/browser/tests/Storage/Sync/MemoryStorage.coffee';
	var __dirname = '/test/browser/tests/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/browser/tests/Storage/Sync/MemoryStorage.coffee'], env: {}};

	/** code **/
	(function() {
	  var Cache, MemoryStorage, cache;
	
	  Cache = require('cache-storage');
	
	  MemoryStorage = require('cache-storage/Storage/MemoryStorage');
	
	  cache = null;
	
	  describe('MemoryStorage', function() {
	    beforeEach(function() {
	      return cache = new Cache(new MemoryStorage, 'test');
	    });
	    describe('saving/loading', function() {
	      it('should save true and load it', function() {
	        cache.save('true', true);
	        return expect(cache.load('true')).to.be["true"];
	      });
	      it('should return null if item not exists', function() {
	        return expect(cache.load('true')).to.be["null"];
	      });
	      it('should save true and delete it', function() {
	        cache.save('true', true);
	        cache.remove('true');
	        return expect(cache.load('true')).to.be["null"];
	      });
	      return it('should save true to cache from fallback function in load', function() {
	        var val;
	        val = cache.load('true', function() {
	          return true;
	        });
	        return expect(val).to.be["true"];
	      });
	    });
	    return describe('expiration', function() {
	      it('should remove all items with tag "article"', function() {
	        cache.save('one', 'one', {
	          tags: ['article']
	        });
	        cache.save('two', 'two', {
	          tags: ['category']
	        });
	        cache.save('three', 'three', {
	          tags: ['article']
	        });
	        cache.clean({
	          tags: ['article']
	        });
	        expect(cache.load('one')).to.be["null"];
	        expect(cache.load('two')).to.be.equal('two');
	        return expect(cache.load('three')).to.be["null"];
	      });
	      it('should expire "true" value after 1 second"', function(done) {
	        cache.save('true', true, {
	          expire: {
	            seconds: 1
	          }
	        });
	        return setTimeout(function() {
	          expect(cache.load('true')).to.be["null"];
	          return done();
	        }, 1100);
	      });
	      it('should expire "true" value after "first" value expire', function() {
	        cache.save('first', 'first');
	        cache.save('true', true, {
	          items: ['first']
	        });
	        cache.remove('first');
	        return expect(cache.load('true')).to.be["null"];
	      });
	      it('should expire all items with priority bellow 50', function() {
	        cache.save('one', 'one', {
	          priority: 100
	        });
	        cache.save('two', 'two', {
	          priority: 10
	        });
	        cache.clean({
	          priority: 50
	        });
	        expect(cache.load('one')).to.be.equal('one');
	        return expect(cache.load('two')).to.be["null"];
	      });
	      return it('should remove all items from cache', function() {
	        cache.save('one', 'one');
	        cache.save('two', 'two');
	        cache.clean('all');
	        expect(cache.load('one')).to.be["null"];
	        return expect(cache.load('two')).to.be["null"];
	      });
	    });
	  });
	
	}).call(this);
	

}, '/package.json': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/package.json');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/package.json';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/package.json';
	var __dirname = '/';
	var process = {cwd: function() {return '/';}, argv: ['node', '/package.json'], env: {}};

	/** code **/
	module.exports = (function() {
	return {
		"name": "cache-storage",
		"description": "Advanced cache storage for node js",
		"version": "1.4.1",
		"author": {
			"name": "David Kudera",
			"email": "sakren@gmail.com"
		},
		"keywords": [
			"cache",
			"caching",
			"storage",
			"memory"
		],
		"repository": {
			"type": "git",
			"url": "git@github.com:sakren/node-cache-storage.git"
		},
		"license": "MIT",
		"engines": {
			"node": ">=0.9"
		},
		"main": "./lib/Cache.js",
		"dependencies": {
			"moment": "~2.5.0",
			"async": "~0.2.9"
		},
		"devDependencies": {
			"chai": "~1.8.1",
			"mocha": "~1.17.0",
			"mocha-phantomjs": "~3.3.1",
			"phantomjs": "~1.9.2-6",
			"fs-mock": "~1.0.1"
		},
		"scripts": {
			"test": "npm run test-node && npm run test-browser",
			"build-and-test": "npm run build-tests && npm run test",
			"build-tests": "coffee -co ./test/node/lib ./test/node/src; cd ./test/browser; simq build;",
			"test-node": "mocha ./test/node/index.js --reporter spec",
			"test-browser": "mocha-phantomjs ./test/browser/index.html"
		}
	}
	
	}).call(this);
	

}, 'moment/package.json': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'moment/package.json');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'moment/package.json';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'moment/package.json';
	var __dirname = 'moment';
	var process = {cwd: function() {return '/';}, argv: ['node', 'moment/package.json'], env: {}};

	/** code **/
	module.exports = (function() {
	return {
	  "name": "moment",
	  "version": "2.5.0",
	  "description": "Parse, manipulate, and display dates.",
	  "homepage": "http://momentjs.com",
	  "author": {
	    "name": "Iskren Ivov Chernev",
	    "email": "iskren.chernev@gmail.com",
	    "url": "https://github.com/ichernev"
	  },
	  "contributors": [
	    {
	      "name": "Tim Wood",
	      "email": "washwithcare@gmail.com",
	      "url": "http://timwoodcreates.com/"
	    },
	    {
	      "name": "Rocky Meza",
	      "url": "http://rockymeza.com"
	    },
	    {
	      "name": "Matt Johnson",
	      "email": "mj1856@hotmail.com",
	      "url": "http://codeofmatt.com"
	    },
	    {
	      "name": "Isaac Cambron",
	      "email": "isaac@isaaccambron.com",
	      "url": "http://drunkencoder.net/"
	    }
	  ],
	  "keywords": [
	    "moment",
	    "date",
	    "time",
	    "parse",
	    "format",
	    "validate",
	    "i18n",
	    "l10n",
	    "ender"
	  ],
	  "main": "./moment.js",
	  "engines": {
	    "node": "*"
	  },
	  "repository": {
	    "type": "git",
	    "url": "https://github.com/moment/moment.git"
	  },
	  "bugs": {
	    "url": "https://github.com/moment/moment/issues"
	  },
	  "licenses": [
	    {
	      "type": "MIT"
	    }
	  ],
	  "devDependencies": {
	    "uglify-js": "latest",
	    "grunt": "latest",
	    "nodeunit": "latest",
	    "grunt-contrib-jshint": "latest",
	    "grunt-contrib-nodeunit": "latest",
	    "grunt-contrib-concat": "latest",
	    "grunt-contrib-uglify": "latest",
	    "grunt-contrib-watch": "latest",
	    "grunt-lib-legacyhelpers": "latest"
	  },
	  "scripts": {
	    "test": "grunt"
	  },
	  "ender": "./ender.js",
	  "dojoBuild": "package.js",
	  "jspm": {
	    "files": [
	      "moment.js",
	      "lang"
	    ],
	    "map": {
	      "moment": "./moment"
	    },
	    "buildConfig": {
	      "uglify": true
	    }
	  },
	  "readme": "A lightweight javascript date library for parsing, validating, manipulating, and formatting dates.\n\n# [Documentation](http://momentjs.com/docs/)\n\nUpgrading to 2.0.0\n==================\n\nThere are a number of small backwards incompatible changes with version 2.0.0.\n\n[See them and their descriptions here](https://gist.github.com/timrwood/e72f2eef320ed9e37c51#backwards-incompatible-changes)\n\nChanged language ordinal method to return the number + ordinal instead of just the ordinal.\n\nChanged two digit year parsing cutoff to match strptime.\n\nRemoved `moment#sod` and `moment#eod` in favor of `moment#startOf` and `moment#endOf`.\n\nRemoved `moment.humanizeDuration()` in favor of `moment.duration().humanize()`.\n\nRemoved the lang data objects from the top level namespace.\n\nDuplicate `Date` passed to `moment()` instead of referencing it.\n\nTravis Build Status\n===================\n\nDevelop [![Build Status](https://travis-ci.org/moment/moment.png?branch=develop)](https://travis-ci.org/moment/moment)\n\nMaster [![Build Status](https://travis-ci.org/moment/moment.png?branch=master)](https://travis-ci.org/moment/moment)\n\nChangelog\n=========\n\n### 2.5.0 [See changelog](https://gist.github.com/ichernev/8104451)\n\n* New languages\n  * Luxemburish (lb) [1247](https://github.com/moment/moment/issues/1247)\n  * Serbian (rs) [1319](https://github.com/moment/moment/issues/1319)\n  * Tamil (ta) [1324](https://github.com/moment/moment/issues/1324)\n  * Macedonian (mk) [1337](https://github.com/moment/moment/issues/1337)\n\n* Features\n  * [1311](https://github.com/moment/moment/issues/1311) Add quarter getter and format token `Q`\n  * [1303](https://github.com/moment/moment/issues/1303) strict parsing now respects number of digits per token (fix [1196](https://github.com/moment/moment/issues/1196))\n  * 0d30bb7 add jspm support\n  * [1347](https://github.com/moment/moment/issues/1347) improve zone parsing\n  * [1362](https://github.com/moment/moment/issues/1362) support merideam parsing in Korean\n\n* 22 bugfixes\n\n### 2.4.0\n\n* **Deprecate** globally exported moment, will be removed in next major\n* New languages\n  * Farose (fo) [#1206](https://github.com/moment/moment/issues/1206)\n  * Tagalog/Filipino (tl-ph) [#1197](https://github.com/moment/moment/issues/1197)\n  * Welsh (cy) [#1215](https://github.com/moment/moment/issues/1215)\n* Bugfixes\n  * properly handle Z at the end of iso RegExp [#1187](https://github.com/moment/moment/issues/1187)\n  * chinese meridian time improvements [#1076](https://github.com/moment/moment/issues/1076)\n  * fix language tests [#1177](https://github.com/moment/moment/issues/1177)\n  * remove some failing tests (that should have never existed :))\n    [#1185](https://github.com/moment/moment/issues/1185)\n    [#1183](https://github.com/moment/moment/issues/1183)\n  * handle russian noun cases in weird cases [#1195](https://github.com/moment/moment/issues/1195)\n\n### 2.3.1\n\nRemoved a trailing comma [1169] and fixed a bug with `months`, `weekdays` getters [1171].\n\n### 2.3.0 [See changelog](https://gist.github.com/ichernev/6864354)\n\nChanged isValid, added strict parsing.\nWeek tokens parsing.\n\n### 2.2.1\n\nFixed bug in string prototype test.\nUpdated authors and contributors.\n\n### 2.2.0 [See changelog](https://gist.github.com/ichernev/00f837a9baf46a3565e4)\n\nAdded bower support.\n\nLanguage files now use UMD.\n\nCreating moment defaults to current date/month/year.\n\nAdded a bundle of moment and all language files.\n\n### 2.1.0 [See changelog](https://gist.github.com/timrwood/b8c2d90d528eddb53ab5)\n\nAdded better week support.\n\nAdded ability to set offset with `moment#zone`.\n\nAdded ability to set month or weekday from a string.\n\nAdded `moment#min` and `moment#max`\n\n### 2.0.0 [See changelog](https://gist.github.com/timrwood/e72f2eef320ed9e37c51)\n\nAdded short form localized tokens.\n\nAdded ability to define language a string should be parsed in.\n\nAdded support for reversed add/subtract arguments.\n\nAdded support for `endOf('week')` and `startOf('week')`.\n\nFixed the logic for `moment#diff(Moment, 'months')` and `moment#diff(Moment, 'years')`\n\n`moment#diff` now floors instead of rounds.\n\nNormalized `moment#toString`.\n\nAdded `isSame`, `isAfter`, and `isBefore` methods.\n\nAdded better week support.\n\nAdded `moment#toJSON`\n\nBugfix: Fixed parsing of first century dates\n\nBugfix: Parsing 10Sep2001 should work as expected\n\nBugfix: Fixed wierdness with `moment.utc()` parsing.\n\nChanged language ordinal method to return the number + ordinal instead of just the ordinal.\n\nChanged two digit year parsing cutoff to match strptime.\n\nRemoved `moment#sod` and `moment#eod` in favor of `moment#startOf` and `moment#endOf`.\n\nRemoved `moment.humanizeDuration()` in favor of `moment.duration().humanize()`.\n\nRemoved the lang data objects from the top level namespace.\n\nDuplicate `Date` passed to `moment()` instead of referencing it.\n\n### 1.7.2 [See discussion](https://github.com/timrwood/moment/issues/456)\n\nBugfixes\n\n### 1.7.1 [See discussion](https://github.com/timrwood/moment/issues/384)\n\nBugfixes\n\n### 1.7.0 [See discussion](https://github.com/timrwood/moment/issues/288)\n\nAdded `moment.fn.endOf()` and `moment.fn.startOf()`.\n\nAdded validation via `moment.fn.isValid()`.\n\nMade formatting method 3x faster. http://jsperf.com/momentjs-cached-format-functions\n\nAdd support for month/weekday callbacks in `moment.fn.format()`\n\nAdded instance specific languages.\n\nAdded two letter weekday abbreviations with the formatting token `dd`.\n\nVarious language updates.\n\nVarious bugfixes.\n\n### 1.6.0 [See discussion](https://github.com/timrwood/moment/pull/268)\n\nAdded Durations.\n\nRevamped parser to support parsing non-separated strings (YYYYMMDD vs YYYY-MM-DD).\n\nAdded support for millisecond parsing and formatting tokens (S SS SSS)\n\nAdded a getter for `moment.lang()`\n\nVarious bugfixes.\n\nThere are a few things deprecated in the 1.6.0 release.\n\n1. The format tokens `z` and `zz` (timezone abbreviations like EST CST MST etc) will no longer be supported. Due to inconsistent browser support, we are unable to consistently produce this value. See [this issue](https://github.com/timrwood/moment/issues/162) for more background.\n\n2. The method `moment.fn.native` is deprecated in favor of `moment.fn.toDate`. There continue to be issues with Google Closure Compiler throwing errors when using `native`, even in valid instances.\n\n3. The way to customize am/pm strings is being changed. This would only affect you if you created a custom language file. For more information, see [this issue](https://github.com/timrwood/moment/pull/222).\n\n### 1.5.0 [See milestone](https://github.com/timrwood/moment/issues?milestone=10&page=1&state=closed)\n\nAdded UTC mode.\n\nAdded automatic ISO8601 parsing.\n\nVarious bugfixes.\n\n### 1.4.0 [See milestone](https://github.com/timrwood/moment/issues?milestone=8&state=closed)\n\nAdded `moment.fn.toDate` as a replacement for `moment.fn.native`.\n\nAdded `moment.fn.sod` and `moment.fn.eod` to get the start and end of day.\n\nVarious bugfixes.\n\n### 1.3.0 [See milestone](https://github.com/timrwood/moment/issues?milestone=7&state=closed)\n\nAdded support for parsing month names in the current language.\n\nAdded escape blocks for parsing tokens.\n\nAdded `moment.fn.calendar` to format strings like 'Today 2:30 PM', 'Tomorrow 1:25 AM', and 'Last Sunday 4:30 AM'.\n\nAdded `moment.fn.day` as a setter.\n\nVarious bugfixes\n\n### 1.2.0 [See milestone](https://github.com/timrwood/moment/issues?milestone=4&state=closed)\n\nAdded timezones to parser and formatter.\n\nAdded `moment.fn.isDST`.\n\nAdded `moment.fn.zone` to get the timezone offset in minutes.\n\n### 1.1.2 [See milestone](https://github.com/timrwood/moment/issues?milestone=6&state=closed)\n\nVarious bugfixes\n\n### 1.1.1 [See milestone](https://github.com/timrwood/moment/issues?milestone=5&state=closed)\n\nAdded time specific diffs (months, days, hours, etc)\n\n### 1.1.0\n\nAdded `moment.fn.format` localized masks. 'L LL LLL LLLL' [issue 29](https://github.com/timrwood/moment/pull/29)\n\nFixed [issue 31](https://github.com/timrwood/moment/pull/31).\n\n### 1.0.1\n\nAdded `moment.version` to get the current version.\n\nRemoved `window !== undefined` when checking if module exists to support browserify. [issue 25](https://github.com/timrwood/moment/pull/25)\n\n### 1.0.0\n\nAdded convenience methods for getting and setting date parts.\n\nAdded better support for `moment.add()`.\n\nAdded better lang support in NodeJS.\n\nRenamed library from underscore.date to Moment.js\n\n### 0.6.1\n\nAdded Portuguese, Italian, and French language support\n\n### 0.6.0\n\nAdded _date.lang() support.\nAdded support for passing multiple formats to try to parse a date. _date(\"07-10-1986\", [\"MM-DD-YYYY\", \"YYYY-MM-DD\"]);\nMade parse from string and single format 25% faster.\n\n### 0.5.2\n\nBugfix for [issue 8](https://github.com/timrwood/underscore.date/pull/8) and [issue 9](https://github.com/timrwood/underscore.date/pull/9).\n\n### 0.5.1\n\nBugfix for [issue 5](https://github.com/timrwood/underscore.date/pull/5).\n\n### 0.5.0\n\nDropped the redundant `_date.date()` in favor of `_date()`.\nRemoved `_date.now()`, as it is a duplicate of `_date()` with no parameters.\nRemoved `_date.isLeapYear(yearNumber)`. Use `_date([yearNumber]).isLeapYear()` instead.\nExposed customization options through the `_date.relativeTime`, `_date.weekdays`, `_date.weekdaysShort`, `_date.months`, `_date.monthsShort`, and `_date.ordinal` variables instead of the `_date.customize()` function.\n\n### 0.4.1\n\nAdded date input formats for input strings.\n\n### 0.4.0\n\nAdded underscore.date to npm. Removed dependencies on underscore.\n\n### 0.3.2\n\nAdded `'z'` and `'zz'` to `_.date().format()`. Cleaned up some redundant code to trim off some bytes.\n\n### 0.3.1\n\nCleaned up the namespace. Moved all date manipulation and display functions to the _.date() object.\n\n### 0.3.0\n\nSwitched to the Underscore methodology of not mucking with the native objects' prototypes.\nMade chaining possible.\n\n### 0.2.1\n\nChanged date names to be a more pseudo standardized 'dddd, MMMM Do YYYY, h:mm:ss a'.\nAdded `Date.prototype` functions `add`, `subtract`, `isdst`, and `isleapyear`.\n\n### 0.2.0\n\nChanged function names to be more concise.\nChanged date format from php date format to custom format.\n\n### 0.1.0\n\nInitial release\n\nLicense\n=======\n\nMoment.js is freely distributable under the terms of the MIT license.\n",
	  "readmeFilename": "readme.md",
	  "_id": "moment@2.5.0",
	  "dist": {
	    "shasum": "d3d6346eb8144969a23f01727ec4c06578ec145a"
	  },
	  "_from": "moment@~2.5.0",
	  "_resolved": "https://registry.npmjs.org/moment/-/moment-2.5.0.tgz"
	}
	
	}).call(this);
	

}, 'async/package.json': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'async/package.json');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'async/package.json';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'async/package.json';
	var __dirname = 'async';
	var process = {cwd: function() {return '/';}, argv: ['node', 'async/package.json'], env: {}};

	/** code **/
	module.exports = (function() {
	return {
	  "name": "async",
	  "description": "Higher-order functions and common patterns for asynchronous code",
	  "main": "./lib/async",
	  "author": {
	    "name": "Caolan McMahon"
	  },
	  "version": "0.2.9",
	  "repository": {
	    "type": "git",
	    "url": "https://github.com/caolan/async.git"
	  },
	  "bugs": {
	    "url": "https://github.com/caolan/async/issues"
	  },
	  "licenses": [
	    {
	      "type": "MIT",
	      "url": "https://github.com/caolan/async/raw/master/LICENSE"
	    }
	  ],
	  "devDependencies": {
	    "nodeunit": ">0.0.0",
	    "uglify-js": "1.2.x",
	    "nodelint": ">0.0.0"
	  },
	  "jam": {
	    "main": "lib/async.js",
	    "include": [
	      "lib/async.js",
	      "README.md",
	      "LICENSE"
	    ]
	  },
	  "scripts": {
	    "test": "nodeunit test/test-async.js"
	  },
	  "readme": "# Async.js\n\nAsync is a utility module which provides straight-forward, powerful functions\nfor working with asynchronous JavaScript. Although originally designed for\nuse with [node.js](http://nodejs.org), it can also be used directly in the\nbrowser. Also supports [component](https://github.com/component/component).\n\nAsync provides around 20 functions that include the usual 'functional'\nsuspects (map, reduce, filter, each) as well as some common patterns\nfor asynchronous control flow (parallel, series, waterfall). All these\nfunctions assume you follow the node.js convention of providing a single\ncallback as the last argument of your async function.\n\n\n## Quick Examples\n\n```javascript\nasync.map(['file1','file2','file3'], fs.stat, function(err, results){\n    // results is now an array of stats for each file\n});\n\nasync.filter(['file1','file2','file3'], fs.exists, function(results){\n    // results now equals an array of the existing files\n});\n\nasync.parallel([\n    function(){ ... },\n    function(){ ... }\n], callback);\n\nasync.series([\n    function(){ ... },\n    function(){ ... }\n]);\n```\n\nThere are many more functions available so take a look at the docs below for a\nfull list. This module aims to be comprehensive, so if you feel anything is\nmissing please create a GitHub issue for it.\n\n## Common Pitfalls\n\n### Binding a context to an iterator\n\nThis section is really about bind, not about async. If you are wondering how to\nmake async execute your iterators in a given context, or are confused as to why\na method of another library isn't working as an iterator, study this example:\n\n```js\n// Here is a simple object with an (unnecessarily roundabout) squaring method\nvar AsyncSquaringLibrary = {\n  squareExponent: 2,\n  square: function(number, callback){ \n    var result = Math.pow(number, this.squareExponent);\n    setTimeout(function(){\n      callback(null, result);\n    }, 200);\n  }\n};\n\nasync.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){\n  // result is [NaN, NaN, NaN]\n  // This fails because the `this.squareExponent` expression in the square\n  // function is not evaluated in the context of AsyncSquaringLibrary, and is\n  // therefore undefined.\n});\n\nasync.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){\n  // result is [1, 4, 9]\n  // With the help of bind we can attach a context to the iterator before\n  // passing it to async. Now the square function will be executed in its \n  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`\n  // will be as expected.\n});\n```\n\n## Download\n\nThe source is available for download from\n[GitHub](http://github.com/caolan/async).\nAlternatively, you can install using Node Package Manager (npm):\n\n    npm install async\n\n__Development:__ [async.js](https://github.com/caolan/async/raw/master/lib/async.js) - 29.6kb Uncompressed\n\n## In the Browser\n\nSo far it's been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. Usage:\n\n```html\n<script type=\"text/javascript\" src=\"async.js\"></script>\n<script type=\"text/javascript\">\n\n    async.map(data, asyncProcess, function(err, results){\n        alert(results);\n    });\n\n</script>\n```\n\n## Documentation\n\n### Collections\n\n* [each](#each)\n* [map](#map)\n* [filter](#filter)\n* [reject](#reject)\n* [reduce](#reduce)\n* [detect](#detect)\n* [sortBy](#sortBy)\n* [some](#some)\n* [every](#every)\n* [concat](#concat)\n\n### Control Flow\n\n* [series](#series)\n* [parallel](#parallel)\n* [whilst](#whilst)\n* [doWhilst](#doWhilst)\n* [until](#until)\n* [doUntil](#doUntil)\n* [forever](#forever)\n* [waterfall](#waterfall)\n* [compose](#compose)\n* [applyEach](#applyEach)\n* [queue](#queue)\n* [cargo](#cargo)\n* [auto](#auto)\n* [iterator](#iterator)\n* [apply](#apply)\n* [nextTick](#nextTick)\n* [times](#times)\n* [timesSeries](#timesSeries)\n\n### Utils\n\n* [memoize](#memoize)\n* [unmemoize](#unmemoize)\n* [log](#log)\n* [dir](#dir)\n* [noConflict](#noConflict)\n\n\n## Collections\n\n<a name=\"forEach\" />\n<a name=\"each\" />\n### each(arr, iterator, callback)\n\nApplies an iterator function to each item in an array, in parallel.\nThe iterator is called with an item from the list and a callback for when it\nhas finished. If the iterator passes an error to this callback, the main\ncallback for the each function is immediately called with the error.\n\nNote, that since this function applies the iterator to each item in parallel\nthere is no guarantee that the iterator functions will complete in order.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* iterator(item, callback) - A function to apply to each item in the array.\n  The iterator is passed a callback(err) which must be called once it has \n  completed. If no error has occured, the callback should be run without \n  arguments or with an explicit null argument.\n* callback(err) - A callback which is called after all the iterator functions\n  have finished, or an error has occurred.\n\n__Example__\n\n```js\n// assuming openFiles is an array of file names and saveFile is a function\n// to save the modified contents of that file:\n\nasync.each(openFiles, saveFile, function(err){\n    // if any of the saves produced an error, err would equal that error\n});\n```\n\n---------------------------------------\n\n<a name=\"forEachSeries\" />\n<a name=\"eachSeries\" />\n### eachSeries(arr, iterator, callback)\n\nThe same as each only the iterator is applied to each item in the array in\nseries. The next iterator is only called once the current one has completed\nprocessing. This means the iterator functions will complete in order.\n\n\n---------------------------------------\n\n<a name=\"forEachLimit\" />\n<a name=\"eachLimit\" />\n### eachLimit(arr, limit, iterator, callback)\n\nThe same as each only no more than \"limit\" iterators will be simultaneously \nrunning at any time.\n\nNote that the items are not processed in batches, so there is no guarantee that\n the first \"limit\" iterator functions will complete before any others are \nstarted.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* limit - The maximum number of iterators to run at any time.\n* iterator(item, callback) - A function to apply to each item in the array.\n  The iterator is passed a callback(err) which must be called once it has \n  completed. If no error has occured, the callback should be run without \n  arguments or with an explicit null argument.\n* callback(err) - A callback which is called after all the iterator functions\n  have finished, or an error has occurred.\n\n__Example__\n\n```js\n// Assume documents is an array of JSON objects and requestApi is a\n// function that interacts with a rate-limited REST api.\n\nasync.eachLimit(documents, 20, requestApi, function(err){\n    // if any of the saves produced an error, err would equal that error\n});\n```\n\n---------------------------------------\n\n<a name=\"map\" />\n### map(arr, iterator, callback)\n\nProduces a new array of values by mapping each value in the given array through\nthe iterator function. The iterator is called with an item from the array and a\ncallback for when it has finished processing. The callback takes 2 arguments, \nan error and the transformed item from the array. If the iterator passes an\nerror to this callback, the main callback for the map function is immediately\ncalled with the error.\n\nNote, that since this function applies the iterator to each item in parallel\nthere is no guarantee that the iterator functions will complete in order, however\nthe results array will be in the same order as the original array.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* iterator(item, callback) - A function to apply to each item in the array.\n  The iterator is passed a callback(err, transformed) which must be called once \n  it has completed with an error (which can be null) and a transformed item.\n* callback(err, results) - A callback which is called after all the iterator\n  functions have finished, or an error has occurred. Results is an array of the\n  transformed items from the original array.\n\n__Example__\n\n```js\nasync.map(['file1','file2','file3'], fs.stat, function(err, results){\n    // results is now an array of stats for each file\n});\n```\n\n---------------------------------------\n\n<a name=\"mapSeries\" />\n### mapSeries(arr, iterator, callback)\n\nThe same as map only the iterator is applied to each item in the array in\nseries. The next iterator is only called once the current one has completed\nprocessing. The results array will be in the same order as the original.\n\n\n---------------------------------------\n\n<a name=\"mapLimit\" />\n### mapLimit(arr, limit, iterator, callback)\n\nThe same as map only no more than \"limit\" iterators will be simultaneously \nrunning at any time.\n\nNote that the items are not processed in batches, so there is no guarantee that\n the first \"limit\" iterator functions will complete before any others are \nstarted.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* limit - The maximum number of iterators to run at any time.\n* iterator(item, callback) - A function to apply to each item in the array.\n  The iterator is passed a callback(err, transformed) which must be called once \n  it has completed with an error (which can be null) and a transformed item.\n* callback(err, results) - A callback which is called after all the iterator\n  functions have finished, or an error has occurred. Results is an array of the\n  transformed items from the original array.\n\n__Example__\n\n```js\nasync.map(['file1','file2','file3'], 1, fs.stat, function(err, results){\n    // results is now an array of stats for each file\n});\n```\n\n---------------------------------------\n\n<a name=\"filter\" />\n### filter(arr, iterator, callback)\n\n__Alias:__ select\n\nReturns a new array of all the values which pass an async truth test.\n_The callback for each iterator call only accepts a single argument of true or\nfalse, it does not accept an error argument first!_ This is in-line with the\nway node libraries work with truth tests like fs.exists. This operation is\nperformed in parallel, but the results array will be in the same order as the\noriginal.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* iterator(item, callback) - A truth test to apply to each item in the array.\n  The iterator is passed a callback(truthValue) which must be called with a \n  boolean argument once it has completed.\n* callback(results) - A callback which is called after all the iterator\n  functions have finished.\n\n__Example__\n\n```js\nasync.filter(['file1','file2','file3'], fs.exists, function(results){\n    // results now equals an array of the existing files\n});\n```\n\n---------------------------------------\n\n<a name=\"filterSeries\" />\n### filterSeries(arr, iterator, callback)\n\n__alias:__ selectSeries\n\nThe same as filter only the iterator is applied to each item in the array in\nseries. The next iterator is only called once the current one has completed\nprocessing. The results array will be in the same order as the original.\n\n---------------------------------------\n\n<a name=\"reject\" />\n### reject(arr, iterator, callback)\n\nThe opposite of filter. Removes values that pass an async truth test.\n\n---------------------------------------\n\n<a name=\"rejectSeries\" />\n### rejectSeries(arr, iterator, callback)\n\nThe same as reject, only the iterator is applied to each item in the array\nin series.\n\n\n---------------------------------------\n\n<a name=\"reduce\" />\n### reduce(arr, memo, iterator, callback)\n\n__aliases:__ inject, foldl\n\nReduces a list of values into a single value using an async iterator to return\neach successive step. Memo is the initial state of the reduction. This\nfunction only operates in series. For performance reasons, it may make sense to\nsplit a call to this function into a parallel map, then use the normal\nArray.prototype.reduce on the results. This function is for situations where\neach step in the reduction needs to be async, if you can get the data before\nreducing it then it's probably a good idea to do so.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* memo - The initial state of the reduction.\n* iterator(memo, item, callback) - A function applied to each item in the\n  array to produce the next step in the reduction. The iterator is passed a\n  callback(err, reduction) which accepts an optional error as its first \n  argument, and the state of the reduction as the second. If an error is \n  passed to the callback, the reduction is stopped and the main callback is \n  immediately called with the error.\n* callback(err, result) - A callback which is called after all the iterator\n  functions have finished. Result is the reduced value.\n\n__Example__\n\n```js\nasync.reduce([1,2,3], 0, function(memo, item, callback){\n    // pointless async:\n    process.nextTick(function(){\n        callback(null, memo + item)\n    });\n}, function(err, result){\n    // result is now equal to the last value of memo, which is 6\n});\n```\n\n---------------------------------------\n\n<a name=\"reduceRight\" />\n### reduceRight(arr, memo, iterator, callback)\n\n__Alias:__ foldr\n\nSame as reduce, only operates on the items in the array in reverse order.\n\n\n---------------------------------------\n\n<a name=\"detect\" />\n### detect(arr, iterator, callback)\n\nReturns the first value in a list that passes an async truth test. The\niterator is applied in parallel, meaning the first iterator to return true will\nfire the detect callback with that result. That means the result might not be\nthe first item in the original array (in terms of order) that passes the test.\n\nIf order within the original array is important then look at detectSeries.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* iterator(item, callback) - A truth test to apply to each item in the array.\n  The iterator is passed a callback(truthValue) which must be called with a \n  boolean argument once it has completed.\n* callback(result) - A callback which is called as soon as any iterator returns\n  true, or after all the iterator functions have finished. Result will be\n  the first item in the array that passes the truth test (iterator) or the\n  value undefined if none passed.\n\n__Example__\n\n```js\nasync.detect(['file1','file2','file3'], fs.exists, function(result){\n    // result now equals the first file in the list that exists\n});\n```\n\n---------------------------------------\n\n<a name=\"detectSeries\" />\n### detectSeries(arr, iterator, callback)\n\nThe same as detect, only the iterator is applied to each item in the array\nin series. This means the result is always the first in the original array (in\nterms of array order) that passes the truth test.\n\n\n---------------------------------------\n\n<a name=\"sortBy\" />\n### sortBy(arr, iterator, callback)\n\nSorts a list by the results of running each value through an async iterator.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* iterator(item, callback) - A function to apply to each item in the array.\n  The iterator is passed a callback(err, sortValue) which must be called once it\n  has completed with an error (which can be null) and a value to use as the sort\n  criteria.\n* callback(err, results) - A callback which is called after all the iterator\n  functions have finished, or an error has occurred. Results is the items from\n  the original array sorted by the values returned by the iterator calls.\n\n__Example__\n\n```js\nasync.sortBy(['file1','file2','file3'], function(file, callback){\n    fs.stat(file, function(err, stats){\n        callback(err, stats.mtime);\n    });\n}, function(err, results){\n    // results is now the original array of files sorted by\n    // modified date\n});\n```\n\n---------------------------------------\n\n<a name=\"some\" />\n### some(arr, iterator, callback)\n\n__Alias:__ any\n\nReturns true if at least one element in the array satisfies an async test.\n_The callback for each iterator call only accepts a single argument of true or\nfalse, it does not accept an error argument first!_ This is in-line with the\nway node libraries work with truth tests like fs.exists. Once any iterator\ncall returns true, the main callback is immediately called.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* iterator(item, callback) - A truth test to apply to each item in the array.\n  The iterator is passed a callback(truthValue) which must be called with a \n  boolean argument once it has completed.\n* callback(result) - A callback which is called as soon as any iterator returns\n  true, or after all the iterator functions have finished. Result will be\n  either true or false depending on the values of the async tests.\n\n__Example__\n\n```js\nasync.some(['file1','file2','file3'], fs.exists, function(result){\n    // if result is true then at least one of the files exists\n});\n```\n\n---------------------------------------\n\n<a name=\"every\" />\n### every(arr, iterator, callback)\n\n__Alias:__ all\n\nReturns true if every element in the array satisfies an async test.\n_The callback for each iterator call only accepts a single argument of true or\nfalse, it does not accept an error argument first!_ This is in-line with the\nway node libraries work with truth tests like fs.exists.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* iterator(item, callback) - A truth test to apply to each item in the array.\n  The iterator is passed a callback(truthValue) which must be called with a \n  boolean argument once it has completed.\n* callback(result) - A callback which is called after all the iterator\n  functions have finished. Result will be either true or false depending on\n  the values of the async tests.\n\n__Example__\n\n```js\nasync.every(['file1','file2','file3'], fs.exists, function(result){\n    // if result is true then every file exists\n});\n```\n\n---------------------------------------\n\n<a name=\"concat\" />\n### concat(arr, iterator, callback)\n\nApplies an iterator to each item in a list, concatenating the results. Returns the\nconcatenated list. The iterators are called in parallel, and the results are\nconcatenated as they return. There is no guarantee that the results array will\nbe returned in the original order of the arguments passed to the iterator function.\n\n__Arguments__\n\n* arr - An array to iterate over\n* iterator(item, callback) - A function to apply to each item in the array.\n  The iterator is passed a callback(err, results) which must be called once it \n  has completed with an error (which can be null) and an array of results.\n* callback(err, results) - A callback which is called after all the iterator\n  functions have finished, or an error has occurred. Results is an array containing\n  the concatenated results of the iterator function.\n\n__Example__\n\n```js\nasync.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){\n    // files is now a list of filenames that exist in the 3 directories\n});\n```\n\n---------------------------------------\n\n<a name=\"concatSeries\" />\n### concatSeries(arr, iterator, callback)\n\nSame as async.concat, but executes in series instead of parallel.\n\n\n## Control Flow\n\n<a name=\"series\" />\n### series(tasks, [callback])\n\nRun an array of functions in series, each one running once the previous\nfunction has completed. If any functions in the series pass an error to its\ncallback, no more functions are run and the callback for the series is\nimmediately called with the value of the error. Once the tasks have completed,\nthe results are passed to the final callback as an array.\n\nIt is also possible to use an object instead of an array. Each property will be\nrun as a function and the results will be passed to the final callback as an object\ninstead of an array. This can be a more readable way of handling results from\nasync.series.\n\n\n__Arguments__\n\n* tasks - An array or object containing functions to run, each function is passed\n  a callback(err, result) it must call on completion with an error (which can\n  be null) and an optional result value.\n* callback(err, results) - An optional callback to run once all the functions\n  have completed. This function gets a results array (or object) containing all \n  the result arguments passed to the task callbacks.\n\n__Example__\n\n```js\nasync.series([\n    function(callback){\n        // do some stuff ...\n        callback(null, 'one');\n    },\n    function(callback){\n        // do some more stuff ...\n        callback(null, 'two');\n    }\n],\n// optional callback\nfunction(err, results){\n    // results is now equal to ['one', 'two']\n});\n\n\n// an example using an object instead of an array\nasync.series({\n    one: function(callback){\n        setTimeout(function(){\n            callback(null, 1);\n        }, 200);\n    },\n    two: function(callback){\n        setTimeout(function(){\n            callback(null, 2);\n        }, 100);\n    }\n},\nfunction(err, results) {\n    // results is now equal to: {one: 1, two: 2}\n});\n```\n\n---------------------------------------\n\n<a name=\"parallel\" />\n### parallel(tasks, [callback])\n\nRun an array of functions in parallel, without waiting until the previous\nfunction has completed. If any of the functions pass an error to its\ncallback, the main callback is immediately called with the value of the error.\nOnce the tasks have completed, the results are passed to the final callback as an\narray.\n\nIt is also possible to use an object instead of an array. Each property will be\nrun as a function and the results will be passed to the final callback as an object\ninstead of an array. This can be a more readable way of handling results from\nasync.parallel.\n\n\n__Arguments__\n\n* tasks - An array or object containing functions to run, each function is passed \n  a callback(err, result) it must call on completion with an error (which can\n  be null) and an optional result value.\n* callback(err, results) - An optional callback to run once all the functions\n  have completed. This function gets a results array (or object) containing all \n  the result arguments passed to the task callbacks.\n\n__Example__\n\n```js\nasync.parallel([\n    function(callback){\n        setTimeout(function(){\n            callback(null, 'one');\n        }, 200);\n    },\n    function(callback){\n        setTimeout(function(){\n            callback(null, 'two');\n        }, 100);\n    }\n],\n// optional callback\nfunction(err, results){\n    // the results array will equal ['one','two'] even though\n    // the second function had a shorter timeout.\n});\n\n\n// an example using an object instead of an array\nasync.parallel({\n    one: function(callback){\n        setTimeout(function(){\n            callback(null, 1);\n        }, 200);\n    },\n    two: function(callback){\n        setTimeout(function(){\n            callback(null, 2);\n        }, 100);\n    }\n},\nfunction(err, results) {\n    // results is now equals to: {one: 1, two: 2}\n});\n```\n\n---------------------------------------\n\n<a name=\"parallel\" />\n### parallelLimit(tasks, limit, [callback])\n\nThe same as parallel only the tasks are executed in parallel with a maximum of \"limit\" \ntasks executing at any time.\n\nNote that the tasks are not executed in batches, so there is no guarantee that \nthe first \"limit\" tasks will complete before any others are started.\n\n__Arguments__\n\n* tasks - An array or object containing functions to run, each function is passed \n  a callback(err, result) it must call on completion with an error (which can\n  be null) and an optional result value.\n* limit - The maximum number of tasks to run at any time.\n* callback(err, results) - An optional callback to run once all the functions\n  have completed. This function gets a results array (or object) containing all \n  the result arguments passed to the task callbacks.\n\n---------------------------------------\n\n<a name=\"whilst\" />\n### whilst(test, fn, callback)\n\nRepeatedly call fn, while test returns true. Calls the callback when stopped,\nor an error occurs.\n\n__Arguments__\n\n* test() - synchronous truth test to perform before each execution of fn.\n* fn(callback) - A function to call each time the test passes. The function is\n  passed a callback(err) which must be called once it has completed with an \n  optional error argument.\n* callback(err) - A callback which is called after the test fails and repeated\n  execution of fn has stopped.\n\n__Example__\n\n```js\nvar count = 0;\n\nasync.whilst(\n    function () { return count < 5; },\n    function (callback) {\n        count++;\n        setTimeout(callback, 1000);\n    },\n    function (err) {\n        // 5 seconds have passed\n    }\n);\n```\n\n---------------------------------------\n\n<a name=\"doWhilst\" />\n### doWhilst(fn, test, callback)\n\nThe post check version of whilst. To reflect the difference in the order of operations `test` and `fn` arguments are switched. `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n\n---------------------------------------\n\n<a name=\"until\" />\n### until(test, fn, callback)\n\nRepeatedly call fn, until test returns true. Calls the callback when stopped,\nor an error occurs.\n\nThe inverse of async.whilst.\n\n---------------------------------------\n\n<a name=\"doUntil\" />\n### doUntil(fn, test, callback)\n\nLike doWhilst except the test is inverted. Note the argument ordering differs from `until`.\n\n---------------------------------------\n\n<a name=\"forever\" />\n### forever(fn, callback)\n\nCalls the asynchronous function 'fn' repeatedly, in series, indefinitely.\nIf an error is passed to fn's callback then 'callback' is called with the\nerror, otherwise it will never be called.\n\n---------------------------------------\n\n<a name=\"waterfall\" />\n### waterfall(tasks, [callback])\n\nRuns an array of functions in series, each passing their results to the next in\nthe array. However, if any of the functions pass an error to the callback, the\nnext function is not executed and the main callback is immediately called with\nthe error.\n\n__Arguments__\n\n* tasks - An array of functions to run, each function is passed a \n  callback(err, result1, result2, ...) it must call on completion. The first\n  argument is an error (which can be null) and any further arguments will be \n  passed as arguments in order to the next task.\n* callback(err, [results]) - An optional callback to run once all the functions\n  have completed. This will be passed the results of the last task's callback.\n\n\n\n__Example__\n\n```js\nasync.waterfall([\n    function(callback){\n        callback(null, 'one', 'two');\n    },\n    function(arg1, arg2, callback){\n        callback(null, 'three');\n    },\n    function(arg1, callback){\n        // arg1 now equals 'three'\n        callback(null, 'done');\n    }\n], function (err, result) {\n   // result now equals 'done'    \n});\n```\n\n---------------------------------------\n<a name=\"compose\" />\n### compose(fn1, fn2...)\n\nCreates a function which is a composition of the passed asynchronous\nfunctions. Each function consumes the return value of the function that\nfollows. Composing functions f(), g() and h() would produce the result of\nf(g(h())), only this version uses callbacks to obtain the return values.\n\nEach function is executed with the `this` binding of the composed function.\n\n__Arguments__\n\n* functions... - the asynchronous functions to compose\n\n\n__Example__\n\n```js\nfunction add1(n, callback) {\n    setTimeout(function () {\n        callback(null, n + 1);\n    }, 10);\n}\n\nfunction mul3(n, callback) {\n    setTimeout(function () {\n        callback(null, n * 3);\n    }, 10);\n}\n\nvar add1mul3 = async.compose(mul3, add1);\n\nadd1mul3(4, function (err, result) {\n   // result now equals 15\n});\n```\n\n---------------------------------------\n<a name=\"applyEach\" />\n### applyEach(fns, args..., callback)\n\nApplies the provided arguments to each function in the array, calling the\ncallback after all functions have completed. If you only provide the first\nargument then it will return a function which lets you pass in the\narguments as if it were a single function call.\n\n__Arguments__\n\n* fns - the asynchronous functions to all call with the same arguments\n* args... - any number of separate arguments to pass to the function\n* callback - the final argument should be the callback, called when all\n  functions have completed processing\n\n\n__Example__\n\n```js\nasync.applyEach([enableSearch, updateSchema], 'bucket', callback);\n\n// partial application example:\nasync.each(\n    buckets,\n    async.applyEach([enableSearch, updateSchema]),\n    callback\n);\n```\n\n---------------------------------------\n\n<a name=\"applyEachSeries\" />\n### applyEachSeries(arr, iterator, callback)\n\nThe same as applyEach only the functions are applied in series.\n\n---------------------------------------\n\n<a name=\"queue\" />\n### queue(worker, concurrency)\n\nCreates a queue object with the specified concurrency. Tasks added to the\nqueue will be processed in parallel (up to the concurrency limit). If all\nworkers are in progress, the task is queued until one is available. Once\na worker has completed a task, the task's callback is called.\n\n__Arguments__\n\n* worker(task, callback) - An asynchronous function for processing a queued\n  task, which must call its callback(err) argument when finished, with an \n  optional error as an argument.\n* concurrency - An integer for determining how many worker functions should be\n  run in parallel.\n\n__Queue objects__\n\nThe queue object returned by this function has the following properties and\nmethods:\n\n* length() - a function returning the number of items waiting to be processed.\n* concurrency - an integer for determining how many worker functions should be\n  run in parallel. This property can be changed after a queue is created to\n  alter the concurrency on-the-fly.\n* push(task, [callback]) - add a new task to the queue, the callback is called\n  once the worker has finished processing the task.\n  instead of a single task, an array of tasks can be submitted. the respective callback is used for every task in the list.\n* unshift(task, [callback]) - add a new task to the front of the queue.\n* saturated - a callback that is called when the queue length hits the concurrency and further tasks will be queued\n* empty - a callback that is called when the last item from the queue is given to a worker\n* drain - a callback that is called when the last item from the queue has returned from the worker\n\n__Example__\n\n```js\n// create a queue object with concurrency 2\n\nvar q = async.queue(function (task, callback) {\n    console.log('hello ' + task.name);\n    callback();\n}, 2);\n\n\n// assign a callback\nq.drain = function() {\n    console.log('all items have been processed');\n}\n\n// add some items to the queue\n\nq.push({name: 'foo'}, function (err) {\n    console.log('finished processing foo');\n});\nq.push({name: 'bar'}, function (err) {\n    console.log('finished processing bar');\n});\n\n// add some items to the queue (batch-wise)\n\nq.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {\n    console.log('finished processing bar');\n});\n\n// add some items to the front of the queue\n\nq.unshift({name: 'bar'}, function (err) {\n    console.log('finished processing bar');\n});\n```\n\n---------------------------------------\n\n<a name=\"cargo\" />\n### cargo(worker, [payload])\n\nCreates a cargo object with the specified payload. Tasks added to the\ncargo will be processed altogether (up to the payload limit). If the\nworker is in progress, the task is queued until it is available. Once\nthe worker has completed some tasks, each callback of those tasks is called.\n\n__Arguments__\n\n* worker(tasks, callback) - An asynchronous function for processing an array of\n  queued tasks, which must call its callback(err) argument when finished, with \n  an optional error as an argument.\n* payload - An optional integer for determining how many tasks should be\n  processed per round; if omitted, the default is unlimited.\n\n__Cargo objects__\n\nThe cargo object returned by this function has the following properties and\nmethods:\n\n* length() - a function returning the number of items waiting to be processed.\n* payload - an integer for determining how many tasks should be\n  process per round. This property can be changed after a cargo is created to\n  alter the payload on-the-fly.\n* push(task, [callback]) - add a new task to the queue, the callback is called\n  once the worker has finished processing the task.\n  instead of a single task, an array of tasks can be submitted. the respective callback is used for every task in the list.\n* saturated - a callback that is called when the queue length hits the concurrency and further tasks will be queued\n* empty - a callback that is called when the last item from the queue is given to a worker\n* drain - a callback that is called when the last item from the queue has returned from the worker\n\n__Example__\n\n```js\n// create a cargo object with payload 2\n\nvar cargo = async.cargo(function (tasks, callback) {\n    for(var i=0; i<tasks.length; i++){\n      console.log('hello ' + tasks[i].name);\n    }\n    callback();\n}, 2);\n\n\n// add some items\n\ncargo.push({name: 'foo'}, function (err) {\n    console.log('finished processing foo');\n});\ncargo.push({name: 'bar'}, function (err) {\n    console.log('finished processing bar');\n});\ncargo.push({name: 'baz'}, function (err) {\n    console.log('finished processing baz');\n});\n```\n\n---------------------------------------\n\n<a name=\"auto\" />\n### auto(tasks, [callback])\n\nDetermines the best order for running functions based on their requirements.\nEach function can optionally depend on other functions being completed first,\nand each function is run as soon as its requirements are satisfied. If any of\nthe functions pass an error to their callback, that function will not complete\n(so any other functions depending on it will not run) and the main callback\nwill be called immediately with the error. Functions also receive an object\ncontaining the results of functions which have completed so far.\n\nNote, all functions are called with a results object as a second argument, \nso it is unsafe to pass functions in the tasks object which cannot handle the\nextra argument. For example, this snippet of code:\n\n```js\nasync.auto({\n  readData: async.apply(fs.readFile, 'data.txt', 'utf-8');\n}, callback);\n```\n\nwill have the effect of calling readFile with the results object as the last\nargument, which will fail:\n\n```js\nfs.readFile('data.txt', 'utf-8', cb, {});\n```\n\nInstead, wrap the call to readFile in a function which does not forward the \nresults object:\n\n```js\nasync.auto({\n  readData: function(cb, results){\n    fs.readFile('data.txt', 'utf-8', cb);\n  }\n}, callback);\n```\n\n__Arguments__\n\n* tasks - An object literal containing named functions or an array of\n  requirements, with the function itself the last item in the array. The key\n  used for each function or array is used when specifying requirements. The \n  function receives two arguments: (1) a callback(err, result) which must be \n  called when finished, passing an error (which can be null) and the result of \n  the function's execution, and (2) a results object, containing the results of\n  the previously executed functions.\n* callback(err, results) - An optional callback which is called when all the\n  tasks have been completed. The callback will receive an error as an argument\n  if any tasks pass an error to their callback. Results will always be passed\n\tbut if an error occurred, no other tasks will be performed, and the results\n\tobject will only contain partial results.\n  \n\n__Example__\n\n```js\nasync.auto({\n    get_data: function(callback){\n        // async code to get some data\n    },\n    make_folder: function(callback){\n        // async code to create a directory to store a file in\n        // this is run at the same time as getting the data\n    },\n    write_file: ['get_data', 'make_folder', function(callback){\n        // once there is some data and the directory exists,\n        // write the data to a file in the directory\n        callback(null, filename);\n    }],\n    email_link: ['write_file', function(callback, results){\n        // once the file is written let's email a link to it...\n        // results.write_file contains the filename returned by write_file.\n    }]\n});\n```\n\nThis is a fairly trivial example, but to do this using the basic parallel and\nseries functions would look like this:\n\n```js\nasync.parallel([\n    function(callback){\n        // async code to get some data\n    },\n    function(callback){\n        // async code to create a directory to store a file in\n        // this is run at the same time as getting the data\n    }\n],\nfunction(err, results){\n    async.series([\n        function(callback){\n            // once there is some data and the directory exists,\n            // write the data to a file in the directory\n        },\n        function(callback){\n            // once the file is written let's email a link to it...\n        }\n    ]);\n});\n```\n\nFor a complicated series of async tasks using the auto function makes adding\nnew tasks much easier and makes the code more readable.\n\n\n---------------------------------------\n\n<a name=\"iterator\" />\n### iterator(tasks)\n\nCreates an iterator function which calls the next function in the array,\nreturning a continuation to call the next one after that. It's also possible to\n'peek' the next iterator by doing iterator.next().\n\nThis function is used internally by the async module but can be useful when\nyou want to manually control the flow of functions in series.\n\n__Arguments__\n\n* tasks - An array of functions to run.\n\n__Example__\n\n```js\nvar iterator = async.iterator([\n    function(){ sys.p('one'); },\n    function(){ sys.p('two'); },\n    function(){ sys.p('three'); }\n]);\n\nnode> var iterator2 = iterator();\n'one'\nnode> var iterator3 = iterator2();\n'two'\nnode> iterator3();\n'three'\nnode> var nextfn = iterator2.next();\nnode> nextfn();\n'three'\n```\n\n---------------------------------------\n\n<a name=\"apply\" />\n### apply(function, arguments..)\n\nCreates a continuation function with some arguments already applied, a useful\nshorthand when combined with other control flow functions. Any arguments\npassed to the returned function are added to the arguments originally passed\nto apply.\n\n__Arguments__\n\n* function - The function you want to eventually apply all arguments to.\n* arguments... - Any number of arguments to automatically apply when the\n  continuation is called.\n\n__Example__\n\n```js\n// using apply\n\nasync.parallel([\n    async.apply(fs.writeFile, 'testfile1', 'test1'),\n    async.apply(fs.writeFile, 'testfile2', 'test2'),\n]);\n\n\n// the same process without using apply\n\nasync.parallel([\n    function(callback){\n        fs.writeFile('testfile1', 'test1', callback);\n    },\n    function(callback){\n        fs.writeFile('testfile2', 'test2', callback);\n    }\n]);\n```\n\nIt's possible to pass any number of additional arguments when calling the\ncontinuation:\n\n```js\nnode> var fn = async.apply(sys.puts, 'one');\nnode> fn('two', 'three');\none\ntwo\nthree\n```\n\n---------------------------------------\n\n<a name=\"nextTick\" />\n### nextTick(callback)\n\nCalls the callback on a later loop around the event loop. In node.js this just\ncalls process.nextTick, in the browser it falls back to setImmediate(callback)\nif available, otherwise setTimeout(callback, 0), which means other higher priority\nevents may precede the execution of the callback.\n\nThis is used internally for browser-compatibility purposes.\n\n__Arguments__\n\n* callback - The function to call on a later loop around the event loop.\n\n__Example__\n\n```js\nvar call_order = [];\nasync.nextTick(function(){\n    call_order.push('two');\n    // call_order now equals ['one','two']\n});\ncall_order.push('one')\n```\n\n<a name=\"times\" />\n### times(n, callback)\n\nCalls the callback n times and accumulates results in the same manner\nyou would use with async.map.\n\n__Arguments__\n\n* n - The number of times to run the function.\n* callback - The function to call n times.\n\n__Example__\n\n```js\n// Pretend this is some complicated async factory\nvar createUser = function(id, callback) {\n  callback(null, {\n    id: 'user' + id\n  })\n}\n// generate 5 users\nasync.times(5, function(n, next){\n    createUser(n, function(err, user) {\n      next(err, user)\n    })\n}, function(err, users) {\n  // we should now have 5 users\n});\n```\n\n<a name=\"timesSeries\" />\n### timesSeries(n, callback)\n\nThe same as times only the iterator is applied to each item in the array in\nseries. The next iterator is only called once the current one has completed\nprocessing. The results array will be in the same order as the original.\n\n\n## Utils\n\n<a name=\"memoize\" />\n### memoize(fn, [hasher])\n\nCaches the results of an async function. When creating a hash to store function\nresults against, the callback is omitted from the hash and an optional hash\nfunction can be used.\n\nThe cache of results is exposed as the `memo` property of the function returned\nby `memoize`.\n\n__Arguments__\n\n* fn - the function you to proxy and cache results from.\n* hasher - an optional function for generating a custom hash for storing\n  results, it has all the arguments applied to it apart from the callback, and\n  must be synchronous.\n\n__Example__\n\n```js\nvar slow_fn = function (name, callback) {\n    // do something\n    callback(null, result);\n};\nvar fn = async.memoize(slow_fn);\n\n// fn can now be used as if it were slow_fn\nfn('some name', function () {\n    // callback\n});\n```\n\n<a name=\"unmemoize\" />\n### unmemoize(fn)\n\nUndoes a memoized function, reverting it to the original, unmemoized\nform. Comes handy in tests.\n\n__Arguments__\n\n* fn - the memoized function\n\n<a name=\"log\" />\n### log(function, arguments)\n\nLogs the result of an async function to the console. Only works in node.js or\nin browsers that support console.log and console.error (such as FF and Chrome).\nIf multiple arguments are returned from the async function, console.log is\ncalled on each argument in order.\n\n__Arguments__\n\n* function - The function you want to eventually apply all arguments to.\n* arguments... - Any number of arguments to apply to the function.\n\n__Example__\n\n```js\nvar hello = function(name, callback){\n    setTimeout(function(){\n        callback(null, 'hello ' + name);\n    }, 1000);\n};\n```\n```js\nnode> async.log(hello, 'world');\n'hello world'\n```\n\n---------------------------------------\n\n<a name=\"dir\" />\n### dir(function, arguments)\n\nLogs the result of an async function to the console using console.dir to\ndisplay the properties of the resulting object. Only works in node.js or\nin browsers that support console.dir and console.error (such as FF and Chrome).\nIf multiple arguments are returned from the async function, console.dir is\ncalled on each argument in order.\n\n__Arguments__\n\n* function - The function you want to eventually apply all arguments to.\n* arguments... - Any number of arguments to apply to the function.\n\n__Example__\n\n```js\nvar hello = function(name, callback){\n    setTimeout(function(){\n        callback(null, {hello: name});\n    }, 1000);\n};\n```\n```js\nnode> async.dir(hello, 'world');\n{hello: 'world'}\n```\n\n---------------------------------------\n\n<a name=\"noConflict\" />\n### noConflict()\n\nChanges the value of async back to its original value, returning a reference to the\nasync object.\n",
	  "readmeFilename": "README.md",
	  "homepage": "https://github.com/caolan/async",
	  "_id": "async@0.2.9",
	  "_from": "async@~0.2.9"
	}
	
	}).call(this);
	

}, 'cache-storage': function(exports, module) { module.exports = window.require('/lib/Cache'); }
, 'cache-storage/Storage/BrowserLocalStorage': function(exports, module) { module.exports = window.require('/Storage/BrowserLocalStorage'); }
, 'cache-storage/Storage/DevNullSyncStorage': function(exports, module) { module.exports = window.require('/Storage/DevNullSyncStorage'); }
, 'cache-storage/Storage/DevNullStorage': function(exports, module) { module.exports = window.require('/Storage/DevNullStorage'); }
, 'cache-storage/Storage/FileStorage': function(exports, module) { module.exports = window.require('/Storage/FileStorage'); }
, 'cache-storage/Storage/MemoryStorage': function(exports, module) { module.exports = window.require('/Storage/MemoryStorage'); }
, 'cache-storage/Storage/Storage': function(exports, module) { module.exports = window.require('/Storage/Storage'); }
, 'moment': function(exports, module) { module.exports = window.require('moment/moment.js'); }
, 'fs-mock': function(exports, module) { module.exports = window.require('fs-mock/lib/fs.js'); }
, 'escape-regexp': function(exports, module) { module.exports = window.require('escape-regexp/index.js'); }
, 'async': function(exports, module) { module.exports = window.require('async/lib/async.js'); }

});
require.__setStats({"/lib/Storage/Sync/BrowserLocalStorage.js":{"atime":1389714776000,"mtime":1389714749000,"ctime":1389714749000},"/lib/Storage/Sync/Storage.js":{"atime":1389710368000,"mtime":1389710339000,"ctime":1389710339000},"/lib/Storage/Storage.js":{"atime":1389710368000,"mtime":1389710339000,"ctime":1389710339000},"moment/moment.js":{"atime":1389639277000,"mtime":1387832828000,"ctime":1389389769000},"/lib/Cache.js":{"atime":1389714061000,"mtime":1389714059000,"ctime":1389714059000},"fs-mock/lib/fs.js":{"atime":1389710368000,"mtime":1389273046000,"ctime":1389391420000},"fs-mock/lib/Stats.js":{"atime":1389710369000,"mtime":1389269301000,"ctime":1389391420000},"fs-mock/lib/Errors.js":{"atime":1389710369000,"mtime":1389269301000,"ctime":1389391420000},"fs-mock/lib/FSWatcher.js":{"atime":1389710369000,"mtime":1389269301000,"ctime":1389391420000},"escape-regexp/index.js":{"atime":1389710369000,"mtime":1345153109000,"ctime":1389391421000},"/lib/Storage/Async/DevNullStorage.js":{"atime":1389714776000,"mtime":1389714738000,"ctime":1389714738000},"/lib/Storage/Async/Storage.js":{"atime":1389714061000,"mtime":1389713968000,"ctime":1389713968000},"async/lib/async.js":{"atime":1389710368000,"mtime":1369727354000,"ctime":1389710356000},"/lib/Storage/Sync/DevNullStorage.js":{"atime":1389714776000,"mtime":1389714761000,"ctime":1389714761000},"/lib/Storage/Sync/FileStorage.js":{"atime":1389714776000,"mtime":1389714767000,"ctime":1389714767000},"/lib/Storage/Sync/MemoryStorage.js":{"atime":1389714776000,"mtime":1389714772000,"ctime":1389714772000},"/Storage/BrowserLocalStorage.js":{"atime":1389710368000,"mtime":1389462062000,"ctime":1389462062000},"/Storage/DevNullAsyncStorage.js":{"atime":1389710368000,"mtime":1389462072000,"ctime":1389462072000},"/Storage/DevNullStorage.js":{"atime":1389710368000,"mtime":1389462081000,"ctime":1389462081000},"/Storage/DevNullSyncStorage.js":{"atime":1389710368000,"mtime":1389462092000,"ctime":1389462092000},"/Storage/FileStorage.js":{"atime":1389710368000,"mtime":1389462097000,"ctime":1389462097000},"/Storage/MemoryStorage.js":{"atime":1389710368000,"mtime":1389462102000,"ctime":1389462102000},"/test/browser/tests/Cache.coffee":{"atime":1389710370000,"mtime":1383999743000,"ctime":1389463648000},"/test/browser/tests/Storage/Sync/BrowserLocalStorage.coffee":{"atime":1389710370000,"mtime":1389464183000,"ctime":1389464183000},"/test/browser/tests/Storage/Sync/DevNullStorage.coffee":{"atime":1389710370000,"mtime":1389462249000,"ctime":1389462249000},"/test/browser/tests/Storage/Sync/FileStorage.coffee":{"atime":1389710370000,"mtime":1383999743000,"ctime":1389462237000},"/test/browser/tests/Storage/Sync/MemoryStorage.coffee":{"atime":1389710370000,"mtime":1383999743000,"ctime":1389462237000},"/package.json":{"atime":1389710353000,"mtime":1389639476000,"ctime":1389639476000},"moment/package.json":{"atime":1389710353000,"mtime":1389389769000,"ctime":1389389769000},"async/package.json":{"atime":1389710368000,"mtime":1389710356000,"ctime":1389710356000}});
require.version = '5.5.1';

/** run section **/

/** /test/browser/tests/Cache **/
require('/test/browser/tests/Cache');

/** /test/browser/tests/Storage/Sync/BrowserLocalStorage **/
require('/test/browser/tests/Storage/Sync/BrowserLocalStorage');

/** /test/browser/tests/Storage/Sync/FileStorage **/
require('/test/browser/tests/Storage/Sync/FileStorage');

/** /test/browser/tests/Storage/Sync/DevNullStorage **/
require('/test/browser/tests/Storage/Sync/DevNullStorage');

/** /test/browser/tests/Storage/Sync/MemoryStorage **/
require('/test/browser/tests/Storage/Sync/MemoryStorage');