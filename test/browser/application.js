/** Generated by SimQ **/
/** modules **/

// Generated by CoffeeScript 1.6.3
(function() {
  var SUPPORTED, arrayIndexOf, cache, creating, modules, require, resolve, stats;

  if (!this.require) {
    SUPPORTED = ['js', 'json', 'ts', 'coffee', 'eco'];
    modules = {};
    stats = {};
    cache = {};
    creating = [];
    require = function(name, parent) {
      var fullName, m;
      if (parent == null) {
        parent = null;
      }
      fullName = resolve(name, parent);
      if (fullName === null) {
        throw new Error('Module ' + name + ' was not found.');
      }
      if (typeof cache[fullName] === 'undefined') {
        m = {
          exports: {},
          id: fullName,
          filename: fullName,
          loaded: false,
          parent: null,
          children: null
        };
        if (arrayIndexOf(creating, fullName) === -1) {
          creating.push(fullName);
          modules[fullName].apply(window, [m.exports, m]);
          creating.splice(arrayIndexOf(creating, fullName));
          cache[fullName] = m;
        }
        m.loaded = true;
      } else {
        m = cache[fullName];
      }
      if (typeof stats[fullName] === 'undefined') {
        stats[fullName] = {
          atime: null,
          mtime: null,
          ctime: null
        };
      }
      stats[fullName].atime = new Date;
      return m.exports;
    };
    resolve = function(name, parent) {
      var ext, num, part, parts, prev, result, _i, _j, _k, _len, _len1, _len2;
      if (parent == null) {
        parent = null;
      }
      if (parent !== null && name[0] === '.') {
        num = parent.lastIndexOf('/');
        if (num !== -1) {
          parent = parent.substr(0, num);
        }
        name = parent + '/' + name;
        parts = name.split('/');
        result = [];
        prev = null;
        for (_i = 0, _len = parts.length; _i < _len; _i++) {
          part = parts[_i];
          if (part === '.' || part === '') {
            continue;
          } else if (part === '..' && prev) {
            result.pop();
          } else {
            result.push(part);
          }
          prev = part;
        }
        name = result.join('/');
        if (parent[0] === '/') {
          name = '/' + name;
        }
      }
      if (typeof modules[name] !== 'undefined') {
        return name;
      }
      for (_j = 0, _len1 = SUPPORTED.length; _j < _len1; _j++) {
        ext = SUPPORTED[_j];
        if (typeof modules[name + '.' + ext] !== 'undefined') {
          return name + '.' + ext;
        }
      }
      for (_k = 0, _len2 = SUPPORTED.length; _k < _len2; _k++) {
        ext = SUPPORTED[_k];
        if (typeof modules[name + '/index.' + ext] !== 'undefined') {
          return name + '/index.' + ext;
        }
      }
      return null;
    };
    arrayIndexOf = function(array, search) {
      var element, i, _i, _len;
      if (typeof Array.prototype.indexOf !== 'undefined') {
        return array.indexOf(search);
      }
      if (array.length === 0) {
        return -1;
      }
      for (i = _i = 0, _len = array.length; _i < _len; i = ++_i) {
        element = array[i];
        if (element === search) {
          return i;
        }
      }
      return -1;
    };
    this.require = function(name, parent) {
      if (parent == null) {
        parent = null;
      }
      return require(name, parent);
    };
    this.require.simq = true;
    this.require.version = 1;
    this.require.resolve = function(name, parent) {
      if (parent == null) {
        parent = null;
      }
      return resolve(name, parent);
    };
    this.require.define = function(bundleOrName, obj) {
      var m, name, _results;
      if (obj == null) {
        obj = null;
      }
      if (typeof bundleOrName === 'string') {
        return modules[bundleOrName] = obj;
      } else {
        _results = [];
        for (name in bundleOrName) {
          m = bundleOrName[name];
          _results.push(modules[name] = m);
        }
        return _results;
      }
    };
    this.require.release = function() {
      var name, _results;
      _results = [];
      for (name in cache) {
        _results.push(delete cache[name]);
      }
      return _results;
    };
    this.require.getStats = function(name, parent) {
      var fullName;
      if (parent == null) {
        parent = null;
      }
      fullName = resolve(name, parent);
      if (fullName === null) {
        throw new Error('Module ' + name + ' was not found.');
      }
      if (typeof stats[fullName] === 'undefined') {
        stats[fullName] = {
          atime: null,
          mtime: null,
          ctime: null
        };
      }
      return stats[fullName];
    };
    this.require.__setStats = function(bundle) {
      var data, name, _results;
      _results = [];
      for (name in bundle) {
        data = bundle[name];
        _results.push(stats[name] = {
          atime: new Date(data.atime),
          mtime: new Date(data.mtime),
          ctime: new Date(data.ctime)
        });
      }
      return _results;
    };
    this.require.cache = cache;
  }

  return this.require.define;

}).call(this)({
 '/lib/Storage/Sync/BrowserLocalStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Sync/BrowserLocalStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Sync/BrowserLocalStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Sync/BrowserLocalStorage.js';
	var __dirname = '/lib/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Sync/BrowserLocalStorage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var BrowserLocalStorage, Cache, Storage,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  Storage = require('./Storage');
	
	  Cache = require('../../Cache');
	
	  BrowserLocalStorage = (function(_super) {
	    __extends(BrowserLocalStorage, _super);
	
	    BrowserLocalStorage.TEST_VALUE = '__--cache-storage--__';
	
	    BrowserLocalStorage.prototype.allData = null;
	
	    BrowserLocalStorage.prototype.data = null;
	
	    BrowserLocalStorage.prototype.meta = null;
	
	    function BrowserLocalStorage() {
	      if (!BrowserLocalStorage.isSupported()) {
	        throw new Error('Cache storage: Local storage is not supported');
	      }
	    }
	
	    BrowserLocalStorage.isSupported = function() {
	      var e;
	      try {
	        localStorage.setItem(BrowserLocalStorage.TEST_VALUE, BrowserLocalStorage.TEST_VALUE);
	        localStorage.getItem(BrowserLocalStorage.TEST_VALUE);
	        return true;
	      } catch (_error) {
	        e = _error;
	        return false;
	      }
	    };
	
	    BrowserLocalStorage.prototype.getName = function() {
	      return '__' + this.cache.namespace;
	    };
	
	    BrowserLocalStorage.prototype.loadData = function() {
	      var data;
	      if (this.allData === null) {
	        data = localStorage.getItem(this.getName());
	        if (data === null) {
	          this.allData = {
	            data: {},
	            meta: {}
	          };
	        } else {
	          this.allData = JSON.parse(data);
	        }
	      }
	      return this.allData;
	    };
	
	    BrowserLocalStorage.prototype.getData = function() {
	      if (this.data === null) {
	        this.data = this.loadData().data;
	      }
	      return this.data;
	    };
	
	    BrowserLocalStorage.prototype.getMeta = function() {
	      if (this.meta === null) {
	        this.meta = this.loadData().meta;
	      }
	      return this.meta;
	    };
	
	    BrowserLocalStorage.prototype.writeData = function(data, meta) {
	      this.data = data;
	      this.meta = meta;
	      return localStorage.setItem(this.getName(), JSON.stringify({
	        data: this.data,
	        meta: this.meta
	      }));
	    };
	
	    return BrowserLocalStorage;
	
	  })(Storage);
	
	  module.exports = BrowserLocalStorage;
	
	}).call(this);
	

}, '/lib/Storage/Sync/Storage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Sync/Storage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Sync/Storage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Sync/Storage.js';
	var __dirname = '/lib/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Sync/Storage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var BaseStorage, Cache, Storage, isWindow, moment, path, _ref,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  isWindow = typeof window === 'undefined' ? false : true;
	
	  if (!isWindow) {
	    path = require('path');
	  }
	
	  BaseStorage = require('../Storage');
	
	  moment = require('moment');
	
	  Cache = require('../../Cache');
	
	  Storage = (function(_super) {
	    __extends(Storage, _super);
	
	    function Storage() {
	      _ref = Storage.__super__.constructor.apply(this, arguments);
	      return _ref;
	    }
	
	    Storage.prototype.async = false;
	
	    Storage.prototype.read = function(key) {
	      var data;
	      data = this.getData();
	      if (typeof data[key] === 'undefined') {
	        return null;
	      } else {
	        if (this.verify(this.findMeta(key))) {
	          return data[key];
	        } else {
	          this.remove(key);
	          return null;
	        }
	      }
	    };
	
	    Storage.prototype.write = function(key, data, dependencies) {
	      var all, meta;
	      if (dependencies == null) {
	        dependencies = {};
	      }
	      all = this.getData();
	      all[key] = data;
	      meta = this.getMeta();
	      meta[key] = dependencies;
	      return this.writeData(all, meta);
	    };
	
	    Storage.prototype.remove = function(key) {
	      var data, meta;
	      data = this.getData();
	      meta = this.getMeta();
	      if (typeof data[key] !== 'undefined') {
	        delete data[key];
	        delete meta[key];
	      }
	      return this.writeData(data, meta);
	    };
	
	    Storage.prototype.removeAll = function() {
	      return this.writeData({}, {});
	    };
	
	    Storage.prototype.clean = function(conditions) {
	      var key, tag, type, typeFn, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3, _results;
	      typeFn = Object.prototype.toString;
	      type = typeFn.call(conditions);
	      if (conditions === Cache.ALL) {
	        return this.removeAll();
	      } else if (type === '[object Object]') {
	        if (typeof conditions[Cache.TAGS] !== 'undefined') {
	          if (typeFn(conditions[Cache.TAGS]) === '[object String]') {
	            conditions[Cache.TAGS] = [conditions[Cache.TAGS]];
	          }
	          _ref1 = conditions[Cache.TAGS];
	          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	            tag = _ref1[_i];
	            _ref2 = this.findKeysByTag(tag);
	            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
	              key = _ref2[_j];
	              this.remove(key);
	            }
	          }
	        }
	        if (typeof conditions[Cache.PRIORITY] !== 'undefined') {
	          _ref3 = this.findKeysByPriority(conditions[Cache.PRIORITY]);
	          _results = [];
	          for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
	            key = _ref3[_k];
	            _results.push(this.remove(key));
	          }
	          return _results;
	        }
	      }
	    };
	
	    Storage.prototype.findMeta = function(key) {
	      var meta;
	      meta = this.getMeta();
	      if (typeof meta[key] !== 'undefined') {
	        return meta[key];
	      } else {
	        return null;
	      }
	    };
	
	    Storage.prototype.findKeysByTag = function(tag) {
	      var key, meta, metas, result;
	      metas = this.getMeta();
	      result = [];
	      for (key in metas) {
	        meta = metas[key];
	        if (typeof meta[Cache.TAGS] !== 'undefined' && meta[Cache.TAGS].indexOf(tag) !== -1) {
	          result.push(key);
	        }
	      }
	      return result;
	    };
	
	    Storage.prototype.findKeysByPriority = function(priority) {
	      var key, meta, metas, result;
	      metas = this.getMeta();
	      result = [];
	      for (key in metas) {
	        meta = metas[key];
	        if (typeof meta[Cache.PRIORITY] !== 'undefined' && meta[Cache.PRIORITY] <= priority) {
	          result.push(key);
	        }
	      }
	      return result;
	    };
	
	    Storage.prototype.verify = function(meta) {
	      var file, item, mtime, time, typefn, _i, _len, _ref1, _ref2, _ref3;
	      typefn = Object.prototype.toString;
	      if (typefn.call(meta) === '[object Object]') {
	        if (typeof meta[Cache.EXPIRE] !== 'undefined') {
	          if (moment().valueOf() >= meta[Cache.EXPIRE]) {
	            return false;
	          }
	        }
	        if (typeof meta[Cache.ITEMS] !== 'undefined') {
	          _ref1 = meta[Cache.ITEMS];
	          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	            item = _ref1[_i];
	            item = this.findMeta(item);
	            if ((item === null) || (item !== null && this.verify(item) === false)) {
	              return false;
	            }
	          }
	        }
	        if (typeof meta[Cache.FILES] !== 'undefined') {
	          this.checkFilesSupport();
	          if (isWindow) {
	            _ref2 = meta[Cache.FILES];
	            for (file in _ref2) {
	              time = _ref2[file];
	              mtime = window.require.getStats(file).mtime;
	              if (mtime === null) {
	                throw new Error('File stats are disabled in your simq configuration. Can not get stats for ' + file + '.');
	              }
	              if (window.require.getStats(file).mtime.getTime() !== time) {
	                return false;
	              }
	            }
	          } else {
	            _ref3 = meta[Cache.FILES];
	            for (file in _ref3) {
	              time = _ref3[file];
	              if ((new Date(Cache.getFs().statSync(file).mtime)).getTime() !== time) {
	                return false;
	              }
	            }
	          }
	        }
	      }
	      return true;
	    };
	
	    Storage.prototype.parseDependencies = function(dependencies) {
	      var file, files, item, mtime, result, time, typefn, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3;
	      typefn = Object.prototype.toString;
	      result = {};
	      if (typefn.call(dependencies) === '[object Object]') {
	        if (typeof dependencies[Cache.PRIORITY] !== 'undefined') {
	          result[Cache.PRIORITY] = dependencies[Cache.PRIORITY];
	        }
	        if (typeof dependencies[Cache.TAGS] !== 'undefined') {
	          result[Cache.TAGS] = dependencies[Cache.TAGS];
	        }
	        if (typeof dependencies[Cache.ITEMS] !== 'undefined') {
	          result[Cache.ITEMS] = [];
	          _ref1 = dependencies[Cache.ITEMS];
	          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	            item = _ref1[_i];
	            result[Cache.ITEMS].push(this.cache.generateKey(item));
	          }
	        }
	        if (typeof dependencies[Cache.EXPIRE] !== 'undefined') {
	          switch (typefn.call(dependencies[Cache.EXPIRE])) {
	            case '[object String]':
	              time = moment(dependencies[Cache.EXPIRE], Cache.TIME_FORMAT);
	              break;
	            case '[object Object]':
	              time = moment().add(dependencies[Cache.EXPIRE]);
	              break;
	            default:
	              throw new Error('Expire format is not valid');
	          }
	          result[Cache.EXPIRE] = time.valueOf();
	        }
	        if (typeof dependencies[Cache.FILES] !== 'undefined') {
	          this.checkFilesSupport();
	          files = {};
	          if (isWindow) {
	            _ref2 = dependencies[Cache.FILES];
	            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
	              file = _ref2[_j];
	              mtime = window.require.getStats(file).mtime;
	              if (mtime === null) {
	                throw new Error('File stats are disabled in your simq configuration. Can not get stats for ' + file + '.');
	              }
	              file = window.require.resolve(file);
	              files[file] = mtime.getTime();
	            }
	          } else {
	            _ref3 = dependencies[Cache.FILES];
	            for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
	              file = _ref3[_k];
	              file = path.resolve(file);
	              files[file] = (new Date(Cache.getFs().statSync(file).mtime)).getTime();
	            }
	          }
	          result[Cache.FILES] = files;
	        }
	      }
	      return result;
	    };
	
	    return Storage;
	
	  })(BaseStorage);
	
	  module.exports = Storage;
	
	}).call(this);
	

}, '/lib/Storage/Storage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Storage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Storage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Storage.js';
	var __dirname = '/lib/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Storage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Storage;
	
	  Storage = (function() {
	    Storage.prototype.async = false;
	
	    Storage.prototype.cache = null;
	
	    function Storage() {
	      if (!(this instanceof Storage)) {
	        if (typeof this.read === 'undefined' || typeof this.write === 'undefined' || typeof this.remove === 'undefined' || typeof this.removeAll === 'undefined' || typeof this.getMeta === 'undefined') {
	          throw new Error('Cache storage: you have to implement methods read, write, remove, removeAll and getMeta.');
	        }
	      }
	    }
	
	    Storage.prototype.checkFilesSupport = function() {
	      var isWindow, version;
	      isWindow = typeof window === 'undefined' ? false : true;
	      if (isWindow && window.require.simq !== true) {
	        throw new Error('Files meta information can be used in browser only with simq.');
	      }
	      if (isWindow) {
	        version = window.require.version;
	        if (typeof version === 'undefined' || parseInt(version.replace(/\./g, '')) < 510) {
	          throw new Error('File method information is supported only with simq@5.1.0 and later.');
	        }
	      }
	    };
	
	    return Storage;
	
	  })();
	
	  module.exports = Storage;
	
	}).call(this);
	

}, 'moment/moment.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'moment/moment.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'moment/moment.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'moment/moment.js';
	var __dirname = 'moment';
	var process = {cwd: function() {return '/';}, argv: ['node', 'moment/moment.js'], env: {}};

	/** code **/
	//! moment.js
	//! version : 2.5.0
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com
	
	(function (undefined) {
	
	    /************************************
	        Constants
	    ************************************/
	
	    var moment,
	        VERSION = "2.5.0",
	        global = this,
	        round = Math.round,
	        i,
	
	        YEAR = 0,
	        MONTH = 1,
	        DATE = 2,
	        HOUR = 3,
	        MINUTE = 4,
	        SECOND = 5,
	        MILLISECOND = 6,
	
	        // internal storage for language config files
	        languages = {},
	
	        // check for nodeJS
	        hasModule = (typeof module !== 'undefined' && module.exports && typeof require !== 'undefined'),
	
	        // ASP.NET json date format regex
	        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
	        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,
	
	        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,
	
	        // format tokens
	        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
	        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,
	
	        // parsing token regexes
	        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
	        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
	        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
	        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
	        parseTokenDigits = /\d+/, // nonzero number of digits
	        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
	        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
	        parseTokenT = /T/i, // T (ISO separator)
	        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
	
	        //strict parsing regexes
	        parseTokenOneDigit = /\d/, // 0 - 9
	        parseTokenTwoDigits = /\d\d/, // 00 - 99
	        parseTokenThreeDigits = /\d{3}/, // 000 - 999
	        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
	        parseTokenSixDigits = /[+\-]?\d{6}/, // -999,999 - 999,999
	
	        // iso 8601 regex
	        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	        isoRegex = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
	
	        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',
	
	        isoDates = [
	            'YYYY-MM-DD',
	            'GGGG-[W]WW',
	            'GGGG-[W]WW-E',
	            'YYYY-DDD'
	        ],
	
	        // iso time formats and regexes
	        isoTimes = [
	            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d{1,3}/],
	            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
	            ['HH:mm', /(T| )\d\d:\d\d/],
	            ['HH', /(T| )\d\d/]
	        ],
	
	        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
	        parseTimezoneChunker = /([\+\-]|\d\d)/gi,
	
	        // getter and setter names
	        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
	        unitMillisecondFactors = {
	            'Milliseconds' : 1,
	            'Seconds' : 1e3,
	            'Minutes' : 6e4,
	            'Hours' : 36e5,
	            'Days' : 864e5,
	            'Months' : 2592e6,
	            'Years' : 31536e6
	        },
	
	        unitAliases = {
	            ms : 'millisecond',
	            s : 'second',
	            m : 'minute',
	            h : 'hour',
	            d : 'day',
	            D : 'date',
	            w : 'week',
	            W : 'isoWeek',
	            M : 'month',
	            y : 'year',
	            DDD : 'dayOfYear',
	            e : 'weekday',
	            E : 'isoWeekday',
	            gg: 'weekYear',
	            GG: 'isoWeekYear'
	        },
	
	        camelFunctions = {
	            dayofyear : 'dayOfYear',
	            isoweekday : 'isoWeekday',
	            isoweek : 'isoWeek',
	            weekyear : 'weekYear',
	            isoweekyear : 'isoWeekYear'
	        },
	
	        // format function strings
	        formatFunctions = {},
	
	        // tokens to ordinalize and pad
	        ordinalizeTokens = 'DDD w W M D d'.split(' '),
	        paddedTokens = 'M D H h m s w W'.split(' '),
	
	        formatTokenFunctions = {
	            M    : function () {
	                return this.month() + 1;
	            },
	            MMM  : function (format) {
	                return this.lang().monthsShort(this, format);
	            },
	            MMMM : function (format) {
	                return this.lang().months(this, format);
	            },
	            D    : function () {
	                return this.date();
	            },
	            DDD  : function () {
	                return this.dayOfYear();
	            },
	            d    : function () {
	                return this.day();
	            },
	            dd   : function (format) {
	                return this.lang().weekdaysMin(this, format);
	            },
	            ddd  : function (format) {
	                return this.lang().weekdaysShort(this, format);
	            },
	            dddd : function (format) {
	                return this.lang().weekdays(this, format);
	            },
	            w    : function () {
	                return this.week();
	            },
	            W    : function () {
	                return this.isoWeek();
	            },
	            YY   : function () {
	                return leftZeroFill(this.year() % 100, 2);
	            },
	            YYYY : function () {
	                return leftZeroFill(this.year(), 4);
	            },
	            YYYYY : function () {
	                return leftZeroFill(this.year(), 5);
	            },
	            YYYYYY : function () {
	                var y = this.year(), sign = y >= 0 ? '+' : '-';
	                return sign + leftZeroFill(Math.abs(y), 6);
	            },
	            gg   : function () {
	                return leftZeroFill(this.weekYear() % 100, 2);
	            },
	            gggg : function () {
	                return this.weekYear();
	            },
	            ggggg : function () {
	                return leftZeroFill(this.weekYear(), 5);
	            },
	            GG   : function () {
	                return leftZeroFill(this.isoWeekYear() % 100, 2);
	            },
	            GGGG : function () {
	                return this.isoWeekYear();
	            },
	            GGGGG : function () {
	                return leftZeroFill(this.isoWeekYear(), 5);
	            },
	            e : function () {
	                return this.weekday();
	            },
	            E : function () {
	                return this.isoWeekday();
	            },
	            a    : function () {
	                return this.lang().meridiem(this.hours(), this.minutes(), true);
	            },
	            A    : function () {
	                return this.lang().meridiem(this.hours(), this.minutes(), false);
	            },
	            H    : function () {
	                return this.hours();
	            },
	            h    : function () {
	                return this.hours() % 12 || 12;
	            },
	            m    : function () {
	                return this.minutes();
	            },
	            s    : function () {
	                return this.seconds();
	            },
	            S    : function () {
	                return toInt(this.milliseconds() / 100);
	            },
	            SS   : function () {
	                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
	            },
	            SSS  : function () {
	                return leftZeroFill(this.milliseconds(), 3);
	            },
	            SSSS : function () {
	                return leftZeroFill(this.milliseconds(), 3);
	            },
	            Z    : function () {
	                var a = -this.zone(),
	                    b = "+";
	                if (a < 0) {
	                    a = -a;
	                    b = "-";
	                }
	                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
	            },
	            ZZ   : function () {
	                var a = -this.zone(),
	                    b = "+";
	                if (a < 0) {
	                    a = -a;
	                    b = "-";
	                }
	                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
	            },
	            z : function () {
	                return this.zoneAbbr();
	            },
	            zz : function () {
	                return this.zoneName();
	            },
	            X    : function () {
	                return this.unix();
	            },
	            Q : function () {
	                return this.quarter();
	            }
	        },
	
	        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];
	
	    function padToken(func, count) {
	        return function (a) {
	            return leftZeroFill(func.call(this, a), count);
	        };
	    }
	    function ordinalizeToken(func, period) {
	        return function (a) {
	            return this.lang().ordinal(func.call(this, a), period);
	        };
	    }
	
	    while (ordinalizeTokens.length) {
	        i = ordinalizeTokens.pop();
	        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
	    }
	    while (paddedTokens.length) {
	        i = paddedTokens.pop();
	        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
	    }
	    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);
	
	
	    /************************************
	        Constructors
	    ************************************/
	
	    function Language() {
	
	    }
	
	    // Moment prototype object
	    function Moment(config) {
	        checkOverflow(config);
	        extend(this, config);
	    }
	
	    // Duration Constructor
	    function Duration(duration) {
	        var normalizedInput = normalizeObjectUnits(duration),
	            years = normalizedInput.year || 0,
	            months = normalizedInput.month || 0,
	            weeks = normalizedInput.week || 0,
	            days = normalizedInput.day || 0,
	            hours = normalizedInput.hour || 0,
	            minutes = normalizedInput.minute || 0,
	            seconds = normalizedInput.second || 0,
	            milliseconds = normalizedInput.millisecond || 0;
	
	        // representation for dateAddRemove
	        this._milliseconds = +milliseconds +
	            seconds * 1e3 + // 1000
	            minutes * 6e4 + // 1000 * 60
	            hours * 36e5; // 1000 * 60 * 60
	        // Because of dateAddRemove treats 24 hours as different from a
	        // day when working around DST, we need to store them separately
	        this._days = +days +
	            weeks * 7;
	        // It is impossible translate months into days without knowing
	        // which months you are are talking about, so we have to store
	        // it separately.
	        this._months = +months +
	            years * 12;
	
	        this._data = {};
	
	        this._bubble();
	    }
	
	    /************************************
	        Helpers
	    ************************************/
	
	
	    function extend(a, b) {
	        for (var i in b) {
	            if (b.hasOwnProperty(i)) {
	                a[i] = b[i];
	            }
	        }
	
	        if (b.hasOwnProperty("toString")) {
	            a.toString = b.toString;
	        }
	
	        if (b.hasOwnProperty("valueOf")) {
	            a.valueOf = b.valueOf;
	        }
	
	        return a;
	    }
	
	    function absRound(number) {
	        if (number < 0) {
	            return Math.ceil(number);
	        } else {
	            return Math.floor(number);
	        }
	    }
	
	    // left zero fill a number
	    // see http://jsperf.com/left-zero-filling for performance comparison
	    function leftZeroFill(number, targetLength, forceSign) {
	        var output = Math.abs(number) + '',
	            sign = number >= 0;
	
	        while (output.length < targetLength) {
	            output = '0' + output;
	        }
	        return (sign ? (forceSign ? '+' : '') : '-') + output;
	    }
	
	    // helper function for _.addTime and _.subtractTime
	    function addOrSubtractDurationFromMoment(mom, duration, isAdding, ignoreUpdateOffset) {
	        var milliseconds = duration._milliseconds,
	            days = duration._days,
	            months = duration._months,
	            minutes,
	            hours;
	
	        if (milliseconds) {
	            mom._d.setTime(+mom._d + milliseconds * isAdding);
	        }
	        // store the minutes and hours so we can restore them
	        if (days || months) {
	            minutes = mom.minute();
	            hours = mom.hour();
	        }
	        if (days) {
	            mom.date(mom.date() + days * isAdding);
	        }
	        if (months) {
	            mom.month(mom.month() + months * isAdding);
	        }
	        if (milliseconds && !ignoreUpdateOffset) {
	            moment.updateOffset(mom);
	        }
	        // restore the minutes and hours after possibly changing dst
	        if (days || months) {
	            mom.minute(minutes);
	            mom.hour(hours);
	        }
	    }
	
	    // check if is an array
	    function isArray(input) {
	        return Object.prototype.toString.call(input) === '[object Array]';
	    }
	
	    function isDate(input) {
	        return  Object.prototype.toString.call(input) === '[object Date]' ||
	                input instanceof Date;
	    }
	
	    // compare two arrays, return the number of differences
	    function compareArrays(array1, array2, dontConvert) {
	        var len = Math.min(array1.length, array2.length),
	            lengthDiff = Math.abs(array1.length - array2.length),
	            diffs = 0,
	            i;
	        for (i = 0; i < len; i++) {
	            if ((dontConvert && array1[i] !== array2[i]) ||
	                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	                diffs++;
	            }
	        }
	        return diffs + lengthDiff;
	    }
	
	    function normalizeUnits(units) {
	        if (units) {
	            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
	            units = unitAliases[units] || camelFunctions[lowered] || lowered;
	        }
	        return units;
	    }
	
	    function normalizeObjectUnits(inputObject) {
	        var normalizedInput = {},
	            normalizedProp,
	            prop;
	
	        for (prop in inputObject) {
	            if (inputObject.hasOwnProperty(prop)) {
	                normalizedProp = normalizeUnits(prop);
	                if (normalizedProp) {
	                    normalizedInput[normalizedProp] = inputObject[prop];
	                }
	            }
	        }
	
	        return normalizedInput;
	    }
	
	    function makeList(field) {
	        var count, setter;
	
	        if (field.indexOf('week') === 0) {
	            count = 7;
	            setter = 'day';
	        }
	        else if (field.indexOf('month') === 0) {
	            count = 12;
	            setter = 'month';
	        }
	        else {
	            return;
	        }
	
	        moment[field] = function (format, index) {
	            var i, getter,
	                method = moment.fn._lang[field],
	                results = [];
	
	            if (typeof format === 'number') {
	                index = format;
	                format = undefined;
	            }
	
	            getter = function (i) {
	                var m = moment().utc().set(setter, i);
	                return method.call(moment.fn._lang, m, format || '');
	            };
	
	            if (index != null) {
	                return getter(index);
	            }
	            else {
	                for (i = 0; i < count; i++) {
	                    results.push(getter(i));
	                }
	                return results;
	            }
	        };
	    }
	
	    function toInt(argumentForCoercion) {
	        var coercedNumber = +argumentForCoercion,
	            value = 0;
	
	        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	            if (coercedNumber >= 0) {
	                value = Math.floor(coercedNumber);
	            } else {
	                value = Math.ceil(coercedNumber);
	            }
	        }
	
	        return value;
	    }
	
	    function daysInMonth(year, month) {
	        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	    }
	
	    function daysInYear(year) {
	        return isLeapYear(year) ? 366 : 365;
	    }
	
	    function isLeapYear(year) {
	        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	    }
	
	    function checkOverflow(m) {
	        var overflow;
	        if (m._a && m._pf.overflow === -2) {
	            overflow =
	                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
	                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
	                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
	                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
	                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
	                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
	                -1;
	
	            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	                overflow = DATE;
	            }
	
	            m._pf.overflow = overflow;
	        }
	    }
	
	    function initializeParsingFlags(config) {
	        config._pf = {
	            empty : false,
	            unusedTokens : [],
	            unusedInput : [],
	            overflow : -2,
	            charsLeftOver : 0,
	            nullInput : false,
	            invalidMonth : null,
	            invalidFormat : false,
	            userInvalidated : false,
	            iso: false
	        };
	    }
	
	    function isValid(m) {
	        if (m._isValid == null) {
	            m._isValid = !isNaN(m._d.getTime()) &&
	                m._pf.overflow < 0 &&
	                !m._pf.empty &&
	                !m._pf.invalidMonth &&
	                !m._pf.nullInput &&
	                !m._pf.invalidFormat &&
	                !m._pf.userInvalidated;
	
	            if (m._strict) {
	                m._isValid = m._isValid &&
	                    m._pf.charsLeftOver === 0 &&
	                    m._pf.unusedTokens.length === 0;
	            }
	        }
	        return m._isValid;
	    }
	
	    function normalizeLanguage(key) {
	        return key ? key.toLowerCase().replace('_', '-') : key;
	    }
	
	    // Return a moment from input, that is local/utc/zone equivalent to model.
	    function makeAs(input, model) {
	        return model._isUTC ? moment(input).zone(model._offset || 0) :
	            moment(input).local();
	    }
	
	    /************************************
	        Languages
	    ************************************/
	
	
	    extend(Language.prototype, {
	
	        set : function (config) {
	            var prop, i;
	            for (i in config) {
	                prop = config[i];
	                if (typeof prop === 'function') {
	                    this[i] = prop;
	                } else {
	                    this['_' + i] = prop;
	                }
	            }
	        },
	
	        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
	        months : function (m) {
	            return this._months[m.month()];
	        },
	
	        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
	        monthsShort : function (m) {
	            return this._monthsShort[m.month()];
	        },
	
	        monthsParse : function (monthName) {
	            var i, mom, regex;
	
	            if (!this._monthsParse) {
	                this._monthsParse = [];
	            }
	
	            for (i = 0; i < 12; i++) {
	                // make the regex if we don't have it already
	                if (!this._monthsParse[i]) {
	                    mom = moment.utc([2000, i]);
	                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	                }
	                // test the regex
	                if (this._monthsParse[i].test(monthName)) {
	                    return i;
	                }
	            }
	        },
	
	        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
	        weekdays : function (m) {
	            return this._weekdays[m.day()];
	        },
	
	        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
	        weekdaysShort : function (m) {
	            return this._weekdaysShort[m.day()];
	        },
	
	        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
	        weekdaysMin : function (m) {
	            return this._weekdaysMin[m.day()];
	        },
	
	        weekdaysParse : function (weekdayName) {
	            var i, mom, regex;
	
	            if (!this._weekdaysParse) {
	                this._weekdaysParse = [];
	            }
	
	            for (i = 0; i < 7; i++) {
	                // make the regex if we don't have it already
	                if (!this._weekdaysParse[i]) {
	                    mom = moment([2000, 1]).day(i);
	                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	                }
	                // test the regex
	                if (this._weekdaysParse[i].test(weekdayName)) {
	                    return i;
	                }
	            }
	        },
	
	        _longDateFormat : {
	            LT : "h:mm A",
	            L : "MM/DD/YYYY",
	            LL : "MMMM D YYYY",
	            LLL : "MMMM D YYYY LT",
	            LLLL : "dddd, MMMM D YYYY LT"
	        },
	        longDateFormat : function (key) {
	            var output = this._longDateFormat[key];
	            if (!output && this._longDateFormat[key.toUpperCase()]) {
	                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
	                    return val.slice(1);
	                });
	                this._longDateFormat[key] = output;
	            }
	            return output;
	        },
	
	        isPM : function (input) {
	            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	            // Using charAt should be more compatible.
	            return ((input + '').toLowerCase().charAt(0) === 'p');
	        },
	
	        _meridiemParse : /[ap]\.?m?\.?/i,
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'pm' : 'PM';
	            } else {
	                return isLower ? 'am' : 'AM';
	            }
	        },
	
	        _calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        calendar : function (key, mom) {
	            var output = this._calendar[key];
	            return typeof output === 'function' ? output.apply(mom) : output;
	        },
	
	        _relativeTime : {
	            future : "in %s",
	            past : "%s ago",
	            s : "a few seconds",
	            m : "a minute",
	            mm : "%d minutes",
	            h : "an hour",
	            hh : "%d hours",
	            d : "a day",
	            dd : "%d days",
	            M : "a month",
	            MM : "%d months",
	            y : "a year",
	            yy : "%d years"
	        },
	        relativeTime : function (number, withoutSuffix, string, isFuture) {
	            var output = this._relativeTime[string];
	            return (typeof output === 'function') ?
	                output(number, withoutSuffix, string, isFuture) :
	                output.replace(/%d/i, number);
	        },
	        pastFuture : function (diff, output) {
	            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
	        },
	
	        ordinal : function (number) {
	            return this._ordinal.replace("%d", number);
	        },
	        _ordinal : "%d",
	
	        preparse : function (string) {
	            return string;
	        },
	
	        postformat : function (string) {
	            return string;
	        },
	
	        week : function (mom) {
	            return weekOfYear(mom, this._week.dow, this._week.doy).week;
	        },
	
	        _week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        },
	
	        _invalidDate: 'Invalid date',
	        invalidDate: function () {
	            return this._invalidDate;
	        }
	    });
	
	    // Loads a language definition into the `languages` cache.  The function
	    // takes a key and optionally values.  If not in the browser and no values
	    // are provided, it will load the language file module.  As a convenience,
	    // this function also returns the language values.
	    function loadLang(key, values) {
	        values.abbr = key;
	        if (!languages[key]) {
	            languages[key] = new Language();
	        }
	        languages[key].set(values);
	        return languages[key];
	    }
	
	    // Remove a language from the `languages` cache. Mostly useful in tests.
	    function unloadLang(key) {
	        delete languages[key];
	    }
	
	    // Determines which language definition to use and returns it.
	    //
	    // With no parameters, it will return the global language.  If you
	    // pass in a language key, such as 'en', it will return the
	    // definition for 'en', so long as 'en' has already been loaded using
	    // moment.lang.
	    function getLangDefinition(key) {
	        var i = 0, j, lang, next, split,
	            get = function (k) {
	                if (!languages[k] && hasModule) {
	                    try {
	                        require('./lang/' + k);
	                    } catch (e) { }
	                }
	                return languages[k];
	            };
	
	        if (!key) {
	            return moment.fn._lang;
	        }
	
	        if (!isArray(key)) {
	            //short-circuit everything else
	            lang = get(key);
	            if (lang) {
	                return lang;
	            }
	            key = [key];
	        }
	
	        //pick the language from the array
	        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	        while (i < key.length) {
	            split = normalizeLanguage(key[i]).split('-');
	            j = split.length;
	            next = normalizeLanguage(key[i + 1]);
	            next = next ? next.split('-') : null;
	            while (j > 0) {
	                lang = get(split.slice(0, j).join('-'));
	                if (lang) {
	                    return lang;
	                }
	                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                    //the next array item is better than a shallower substring of this one
	                    break;
	                }
	                j--;
	            }
	            i++;
	        }
	        return moment.fn._lang;
	    }
	
	    /************************************
	        Formatting
	    ************************************/
	
	
	    function removeFormattingTokens(input) {
	        if (input.match(/\[[\s\S]/)) {
	            return input.replace(/^\[|\]$/g, "");
	        }
	        return input.replace(/\\/g, "");
	    }
	
	    function makeFormatFunction(format) {
	        var array = format.match(formattingTokens), i, length;
	
	        for (i = 0, length = array.length; i < length; i++) {
	            if (formatTokenFunctions[array[i]]) {
	                array[i] = formatTokenFunctions[array[i]];
	            } else {
	                array[i] = removeFormattingTokens(array[i]);
	            }
	        }
	
	        return function (mom) {
	            var output = "";
	            for (i = 0; i < length; i++) {
	                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
	            }
	            return output;
	        };
	    }
	
	    // format date using native date object
	    function formatMoment(m, format) {
	
	        if (!m.isValid()) {
	            return m.lang().invalidDate();
	        }
	
	        format = expandFormat(format, m.lang());
	
	        if (!formatFunctions[format]) {
	            formatFunctions[format] = makeFormatFunction(format);
	        }
	
	        return formatFunctions[format](m);
	    }
	
	    function expandFormat(format, lang) {
	        var i = 5;
	
	        function replaceLongDateFormatTokens(input) {
	            return lang.longDateFormat(input) || input;
	        }
	
	        localFormattingTokens.lastIndex = 0;
	        while (i >= 0 && localFormattingTokens.test(format)) {
	            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	            localFormattingTokens.lastIndex = 0;
	            i -= 1;
	        }
	
	        return format;
	    }
	
	
	    /************************************
	        Parsing
	    ************************************/
	
	
	    // get the regex to find the next token
	    function getParseRegexForToken(token, config) {
	        var a, strict = config._strict;
	        switch (token) {
	        case 'DDDD':
	            return parseTokenThreeDigits;
	        case 'YYYY':
	        case 'GGGG':
	        case 'gggg':
	            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
	        case 'YYYYYY':
	        case 'YYYYY':
	        case 'GGGGG':
	        case 'ggggg':
	            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
	        case 'S':
	            if (strict) { return parseTokenOneDigit; }
	            /* falls through */
	        case 'SS':
	            if (strict) { return parseTokenTwoDigits; }
	            /* falls through */
	        case 'SSS':
	        case 'DDD':
	            return strict ? parseTokenThreeDigits : parseTokenOneToThreeDigits;
	        case 'MMM':
	        case 'MMMM':
	        case 'dd':
	        case 'ddd':
	        case 'dddd':
	            return parseTokenWord;
	        case 'a':
	        case 'A':
	            return getLangDefinition(config._l)._meridiemParse;
	        case 'X':
	            return parseTokenTimestampMs;
	        case 'Z':
	        case 'ZZ':
	            return parseTokenTimezone;
	        case 'T':
	            return parseTokenT;
	        case 'SSSS':
	            return parseTokenDigits;
	        case 'MM':
	        case 'DD':
	        case 'YY':
	        case 'GG':
	        case 'gg':
	        case 'HH':
	        case 'hh':
	        case 'mm':
	        case 'ss':
	        case 'ww':
	        case 'WW':
	            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
	        case 'M':
	        case 'D':
	        case 'd':
	        case 'H':
	        case 'h':
	        case 'm':
	        case 's':
	        case 'w':
	        case 'W':
	        case 'e':
	        case 'E':
	            return strict ? parseTokenOneDigit : parseTokenOneOrTwoDigits;
	        default :
	            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
	            return a;
	        }
	    }
	
	    function timezoneMinutesFromString(string) {
	        string = string || "";
	        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
	            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
	            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
	            minutes = +(parts[1] * 60) + toInt(parts[2]);
	
	        return parts[0] === '+' ? -minutes : minutes;
	    }
	
	    // function to convert string input to date
	    function addTimeToArrayFromToken(token, input, config) {
	        var a, datePartArray = config._a;
	
	        switch (token) {
	        // MONTH
	        case 'M' : // fall through to MM
	        case 'MM' :
	            if (input != null) {
	                datePartArray[MONTH] = toInt(input) - 1;
	            }
	            break;
	        case 'MMM' : // fall through to MMMM
	        case 'MMMM' :
	            a = getLangDefinition(config._l).monthsParse(input);
	            // if we didn't find a month name, mark the date as invalid.
	            if (a != null) {
	                datePartArray[MONTH] = a;
	            } else {
	                config._pf.invalidMonth = input;
	            }
	            break;
	        // DAY OF MONTH
	        case 'D' : // fall through to DD
	        case 'DD' :
	            if (input != null) {
	                datePartArray[DATE] = toInt(input);
	            }
	            break;
	        // DAY OF YEAR
	        case 'DDD' : // fall through to DDDD
	        case 'DDDD' :
	            if (input != null) {
	                config._dayOfYear = toInt(input);
	            }
	
	            break;
	        // YEAR
	        case 'YY' :
	            datePartArray[YEAR] = toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	            break;
	        case 'YYYY' :
	        case 'YYYYY' :
	        case 'YYYYYY' :
	            datePartArray[YEAR] = toInt(input);
	            break;
	        // AM / PM
	        case 'a' : // fall through to A
	        case 'A' :
	            config._isPm = getLangDefinition(config._l).isPM(input);
	            break;
	        // 24 HOUR
	        case 'H' : // fall through to hh
	        case 'HH' : // fall through to hh
	        case 'h' : // fall through to hh
	        case 'hh' :
	            datePartArray[HOUR] = toInt(input);
	            break;
	        // MINUTE
	        case 'm' : // fall through to mm
	        case 'mm' :
	            datePartArray[MINUTE] = toInt(input);
	            break;
	        // SECOND
	        case 's' : // fall through to ss
	        case 'ss' :
	            datePartArray[SECOND] = toInt(input);
	            break;
	        // MILLISECOND
	        case 'S' :
	        case 'SS' :
	        case 'SSS' :
	        case 'SSSS' :
	            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
	            break;
	        // UNIX TIMESTAMP WITH MS
	        case 'X':
	            config._d = new Date(parseFloat(input) * 1000);
	            break;
	        // TIMEZONE
	        case 'Z' : // fall through to ZZ
	        case 'ZZ' :
	            config._useUTC = true;
	            config._tzm = timezoneMinutesFromString(input);
	            break;
	        case 'w':
	        case 'ww':
	        case 'W':
	        case 'WW':
	        case 'd':
	        case 'dd':
	        case 'ddd':
	        case 'dddd':
	        case 'e':
	        case 'E':
	            token = token.substr(0, 1);
	            /* falls through */
	        case 'gg':
	        case 'gggg':
	        case 'GG':
	        case 'GGGG':
	        case 'GGGGG':
	            token = token.substr(0, 2);
	            if (input) {
	                config._w = config._w || {};
	                config._w[token] = input;
	            }
	            break;
	        }
	    }
	
	    // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]
	    function dateFromConfig(config) {
	        var i, date, input = [], currentDate,
	            yearToUse, fixYear, w, temp, lang, weekday, week;
	
	        if (config._d) {
	            return;
	        }
	
	        currentDate = currentDateArray(config);
	
	        //compute day of the year from weeks and weekdays
	        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	            fixYear = function (val) {
	                var int_val = parseInt(val, 10);
	                return val ?
	                  (val.length < 3 ? (int_val > 68 ? 1900 + int_val : 2000 + int_val) : int_val) :
	                  (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
	            };
	
	            w = config._w;
	            if (w.GG != null || w.W != null || w.E != null) {
	                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
	            }
	            else {
	                lang = getLangDefinition(config._l);
	                weekday = w.d != null ?  parseWeekday(w.d, lang) :
	                  (w.e != null ?  parseInt(w.e, 10) + lang._week.dow : 0);
	
	                week = parseInt(w.w, 10) || 1;
	
	                //if we're parsing 'd', then the low day numbers may be next week
	                if (w.d != null && weekday < lang._week.dow) {
	                    week++;
	                }
	
	                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
	            }
	
	            config._a[YEAR] = temp.year;
	            config._dayOfYear = temp.dayOfYear;
	        }
	
	        //if the day of the year is set, figure out what it is
	        if (config._dayOfYear) {
	            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];
	
	            if (config._dayOfYear > daysInYear(yearToUse)) {
	                config._pf._overflowDayOfYear = true;
	            }
	
	            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
	            config._a[MONTH] = date.getUTCMonth();
	            config._a[DATE] = date.getUTCDate();
	        }
	
	        // Default to current date.
	        // * if no year, month, day of month are given, default to today
	        // * if day of month is given, default month and year
	        // * if month is given, default only year
	        // * if year is given, don't default anything
	        for (i = 0; i < 3 && config._a[i] == null; ++i) {
	            config._a[i] = input[i] = currentDate[i];
	        }
	
	        // Zero out whatever was not defaulted, including time
	        for (; i < 7; i++) {
	            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	        }
	
	        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
	        input[HOUR] += toInt((config._tzm || 0) / 60);
	        input[MINUTE] += toInt((config._tzm || 0) % 60);
	
	        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
	    }
	
	    function dateFromObject(config) {
	        var normalizedInput;
	
	        if (config._d) {
	            return;
	        }
	
	        normalizedInput = normalizeObjectUnits(config._i);
	        config._a = [
	            normalizedInput.year,
	            normalizedInput.month,
	            normalizedInput.day,
	            normalizedInput.hour,
	            normalizedInput.minute,
	            normalizedInput.second,
	            normalizedInput.millisecond
	        ];
	
	        dateFromConfig(config);
	    }
	
	    function currentDateArray(config) {
	        var now = new Date();
	        if (config._useUTC) {
	            return [
	                now.getUTCFullYear(),
	                now.getUTCMonth(),
	                now.getUTCDate()
	            ];
	        } else {
	            return [now.getFullYear(), now.getMonth(), now.getDate()];
	        }
	    }
	
	    // date from string and format string
	    function makeDateFromStringAndFormat(config) {
	
	        config._a = [];
	        config._pf.empty = true;
	
	        // This array is used to make a Date, either with `new Date` or `Date.UTC`
	        var lang = getLangDefinition(config._l),
	            string = '' + config._i,
	            i, parsedInput, tokens, token, skipped,
	            stringLength = string.length,
	            totalParsedInputLength = 0;
	
	        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];
	
	        for (i = 0; i < tokens.length; i++) {
	            token = tokens[i];
	            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	            if (parsedInput) {
	                skipped = string.substr(0, string.indexOf(parsedInput));
	                if (skipped.length > 0) {
	                    config._pf.unusedInput.push(skipped);
	                }
	                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	                totalParsedInputLength += parsedInput.length;
	            }
	            // don't parse if it's not a known token
	            if (formatTokenFunctions[token]) {
	                if (parsedInput) {
	                    config._pf.empty = false;
	                }
	                else {
	                    config._pf.unusedTokens.push(token);
	                }
	                addTimeToArrayFromToken(token, parsedInput, config);
	            }
	            else if (config._strict && !parsedInput) {
	                config._pf.unusedTokens.push(token);
	            }
	        }
	
	        // add remaining unparsed input length to the string
	        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
	        if (string.length > 0) {
	            config._pf.unusedInput.push(string);
	        }
	
	        // handle am pm
	        if (config._isPm && config._a[HOUR] < 12) {
	            config._a[HOUR] += 12;
	        }
	        // if is 12 am, change hours to 0
	        if (config._isPm === false && config._a[HOUR] === 12) {
	            config._a[HOUR] = 0;
	        }
	
	        dateFromConfig(config);
	        checkOverflow(config);
	    }
	
	    function unescapeFormat(s) {
	        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	            return p1 || p2 || p3 || p4;
	        });
	    }
	
	    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	    function regexpEscape(s) {
	        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }
	
	    // date from string and array of format strings
	    function makeDateFromStringAndArray(config) {
	        var tempConfig,
	            bestMoment,
	
	            scoreToBeat,
	            i,
	            currentScore;
	
	        if (config._f.length === 0) {
	            config._pf.invalidFormat = true;
	            config._d = new Date(NaN);
	            return;
	        }
	
	        for (i = 0; i < config._f.length; i++) {
	            currentScore = 0;
	            tempConfig = extend({}, config);
	            initializeParsingFlags(tempConfig);
	            tempConfig._f = config._f[i];
	            makeDateFromStringAndFormat(tempConfig);
	
	            if (!isValid(tempConfig)) {
	                continue;
	            }
	
	            // if there is any input that was not parsed add a penalty for that format
	            currentScore += tempConfig._pf.charsLeftOver;
	
	            //or tokens
	            currentScore += tempConfig._pf.unusedTokens.length * 10;
	
	            tempConfig._pf.score = currentScore;
	
	            if (scoreToBeat == null || currentScore < scoreToBeat) {
	                scoreToBeat = currentScore;
	                bestMoment = tempConfig;
	            }
	        }
	
	        extend(config, bestMoment || tempConfig);
	    }
	
	    // date from iso format
	    function makeDateFromString(config) {
	        var i,
	            string = config._i,
	            match = isoRegex.exec(string);
	
	        if (match) {
	            config._pf.iso = true;
	            for (i = 4; i > 0; i--) {
	                if (match[i]) {
	                    // match[5] should be "T" or undefined
	                    config._f = isoDates[i - 1] + (match[6] || " ");
	                    break;
	                }
	            }
	            for (i = 0; i < 4; i++) {
	                if (isoTimes[i][1].exec(string)) {
	                    config._f += isoTimes[i][0];
	                    break;
	                }
	            }
	            if (string.match(parseTokenTimezone)) {
	                config._f += "Z";
	            }
	            makeDateFromStringAndFormat(config);
	        }
	        else {
	            config._d = new Date(string);
	        }
	    }
	
	    function makeDateFromInput(config) {
	        var input = config._i,
	            matched = aspNetJsonRegex.exec(input);
	
	        if (input === undefined) {
	            config._d = new Date();
	        } else if (matched) {
	            config._d = new Date(+matched[1]);
	        } else if (typeof input === 'string') {
	            makeDateFromString(config);
	        } else if (isArray(input)) {
	            config._a = input.slice(0);
	            dateFromConfig(config);
	        } else if (isDate(input)) {
	            config._d = new Date(+input);
	        } else if (typeof(input) === 'object') {
	            dateFromObject(config);
	        } else {
	            config._d = new Date(input);
	        }
	    }
	
	    function makeDate(y, m, d, h, M, s, ms) {
	        //can't just apply() to create a date:
	        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
	        var date = new Date(y, m, d, h, M, s, ms);
	
	        //the date constructor doesn't accept years < 1970
	        if (y < 1970) {
	            date.setFullYear(y);
	        }
	        return date;
	    }
	
	    function makeUTCDate(y) {
	        var date = new Date(Date.UTC.apply(null, arguments));
	        if (y < 1970) {
	            date.setUTCFullYear(y);
	        }
	        return date;
	    }
	
	    function parseWeekday(input, language) {
	        if (typeof input === 'string') {
	            if (!isNaN(input)) {
	                input = parseInt(input, 10);
	            }
	            else {
	                input = language.weekdaysParse(input);
	                if (typeof input !== 'number') {
	                    return null;
	                }
	            }
	        }
	        return input;
	    }
	
	    /************************************
	        Relative Time
	    ************************************/
	
	
	    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
	        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }
	
	    function relativeTime(milliseconds, withoutSuffix, lang) {
	        var seconds = round(Math.abs(milliseconds) / 1000),
	            minutes = round(seconds / 60),
	            hours = round(minutes / 60),
	            days = round(hours / 24),
	            years = round(days / 365),
	            args = seconds < 45 && ['s', seconds] ||
	                minutes === 1 && ['m'] ||
	                minutes < 45 && ['mm', minutes] ||
	                hours === 1 && ['h'] ||
	                hours < 22 && ['hh', hours] ||
	                days === 1 && ['d'] ||
	                days <= 25 && ['dd', days] ||
	                days <= 45 && ['M'] ||
	                days < 345 && ['MM', round(days / 30)] ||
	                years === 1 && ['y'] || ['yy', years];
	        args[2] = withoutSuffix;
	        args[3] = milliseconds > 0;
	        args[4] = lang;
	        return substituteTimeAgo.apply({}, args);
	    }
	
	
	    /************************************
	        Week of Year
	    ************************************/
	
	
	    // firstDayOfWeek       0 = sun, 6 = sat
	    //                      the day of the week that starts the week
	    //                      (usually sunday or monday)
	    // firstDayOfWeekOfYear 0 = sun, 6 = sat
	    //                      the first week is the week that contains the first
	    //                      of this day of the week
	    //                      (eg. ISO weeks use thursday (4))
	    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
	        var end = firstDayOfWeekOfYear - firstDayOfWeek,
	            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
	            adjustedMoment;
	
	
	        if (daysToDayOfWeek > end) {
	            daysToDayOfWeek -= 7;
	        }
	
	        if (daysToDayOfWeek < end - 7) {
	            daysToDayOfWeek += 7;
	        }
	
	        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
	        return {
	            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
	            year: adjustedMoment.year()
	        };
	    }
	
	    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
	        // The only solid way to create an iso date from year is to use
	        // a string format (Date.UTC handles only years > 1900). Don't ask why
	        // it doesn't need Z at the end.
	        var d = new Date(leftZeroFill(year, 6, true) + '-01-01').getUTCDay(),
	            daysToAdd, dayOfYear;
	
	        weekday = weekday != null ? weekday : firstDayOfWeek;
	        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0);
	        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
	
	        return {
	            year: dayOfYear > 0 ? year : year - 1,
	            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
	        };
	    }
	
	    /************************************
	        Top Level Functions
	    ************************************/
	
	    function makeMoment(config) {
	        var input = config._i,
	            format = config._f;
	
	        if (typeof config._pf === 'undefined') {
	            initializeParsingFlags(config);
	        }
	
	        if (input === null) {
	            return moment.invalid({nullInput: true});
	        }
	
	        if (typeof input === 'string') {
	            config._i = input = getLangDefinition().preparse(input);
	        }
	
	        if (moment.isMoment(input)) {
	            config = extend({}, input);
	
	            config._d = new Date(+input._d);
	        } else if (format) {
	            if (isArray(format)) {
	                makeDateFromStringAndArray(config);
	            } else {
	                makeDateFromStringAndFormat(config);
	            }
	        } else {
	            makeDateFromInput(config);
	        }
	
	        return new Moment(config);
	    }
	
	    moment = function (input, format, lang, strict) {
	        if (typeof(lang) === "boolean") {
	            strict = lang;
	            lang = undefined;
	        }
	        return makeMoment({
	            _i : input,
	            _f : format,
	            _l : lang,
	            _strict : strict,
	            _isUTC : false
	        });
	    };
	
	    // creating with utc
	    moment.utc = function (input, format, lang, strict) {
	        var m;
	
	        if (typeof(lang) === "boolean") {
	            strict = lang;
	            lang = undefined;
	        }
	        m = makeMoment({
	            _useUTC : true,
	            _isUTC : true,
	            _l : lang,
	            _i : input,
	            _f : format,
	            _strict : strict
	        }).utc();
	
	        return m;
	    };
	
	    // creating with unix timestamp (in seconds)
	    moment.unix = function (input) {
	        return moment(input * 1000);
	    };
	
	    // duration
	    moment.duration = function (input, key) {
	        var duration = input,
	            // matching against regexp is expensive, do it on demand
	            match = null,
	            sign,
	            ret,
	            parseIso;
	
	        if (moment.isDuration(input)) {
	            duration = {
	                ms: input._milliseconds,
	                d: input._days,
	                M: input._months
	            };
	        } else if (typeof input === 'number') {
	            duration = {};
	            if (key) {
	                duration[key] = input;
	            } else {
	                duration.milliseconds = input;
	            }
	        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
	            sign = (match[1] === "-") ? -1 : 1;
	            duration = {
	                y: 0,
	                d: toInt(match[DATE]) * sign,
	                h: toInt(match[HOUR]) * sign,
	                m: toInt(match[MINUTE]) * sign,
	                s: toInt(match[SECOND]) * sign,
	                ms: toInt(match[MILLISECOND]) * sign
	            };
	        } else if (!!(match = isoDurationRegex.exec(input))) {
	            sign = (match[1] === "-") ? -1 : 1;
	            parseIso = function (inp) {
	                // We'd normally use ~~inp for this, but unfortunately it also
	                // converts floats to ints.
	                // inp may be undefined, so careful calling replace on it.
	                var res = inp && parseFloat(inp.replace(',', '.'));
	                // apply sign while we're at it
	                return (isNaN(res) ? 0 : res) * sign;
	            };
	            duration = {
	                y: parseIso(match[2]),
	                M: parseIso(match[3]),
	                d: parseIso(match[4]),
	                h: parseIso(match[5]),
	                m: parseIso(match[6]),
	                s: parseIso(match[7]),
	                w: parseIso(match[8])
	            };
	        }
	
	        ret = new Duration(duration);
	
	        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
	            ret._lang = input._lang;
	        }
	
	        return ret;
	    };
	
	    // version number
	    moment.version = VERSION;
	
	    // default format
	    moment.defaultFormat = isoFormat;
	
	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.
	    moment.updateOffset = function () {};
	
	    // This function will load languages and then set the global language.  If
	    // no arguments are passed in, it will simply return the current global
	    // language key.
	    moment.lang = function (key, values) {
	        var r;
	        if (!key) {
	            return moment.fn._lang._abbr;
	        }
	        if (values) {
	            loadLang(normalizeLanguage(key), values);
	        } else if (values === null) {
	            unloadLang(key);
	            key = 'en';
	        } else if (!languages[key]) {
	            getLangDefinition(key);
	        }
	        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
	        return r._abbr;
	    };
	
	    // returns language data
	    moment.langData = function (key) {
	        if (key && key._lang && key._lang._abbr) {
	            key = key._lang._abbr;
	        }
	        return getLangDefinition(key);
	    };
	
	    // compare moment object
	    moment.isMoment = function (obj) {
	        return obj instanceof Moment;
	    };
	
	    // for typechecking Duration objects
	    moment.isDuration = function (obj) {
	        return obj instanceof Duration;
	    };
	
	    for (i = lists.length - 1; i >= 0; --i) {
	        makeList(lists[i]);
	    }
	
	    moment.normalizeUnits = function (units) {
	        return normalizeUnits(units);
	    };
	
	    moment.invalid = function (flags) {
	        var m = moment.utc(NaN);
	        if (flags != null) {
	            extend(m._pf, flags);
	        }
	        else {
	            m._pf.userInvalidated = true;
	        }
	
	        return m;
	    };
	
	    moment.parseZone = function (input) {
	        return moment(input).parseZone();
	    };
	
	    /************************************
	        Moment Prototype
	    ************************************/
	
	
	    extend(moment.fn = Moment.prototype, {
	
	        clone : function () {
	            return moment(this);
	        },
	
	        valueOf : function () {
	            return +this._d + ((this._offset || 0) * 60000);
	        },
	
	        unix : function () {
	            return Math.floor(+this / 1000);
	        },
	
	        toString : function () {
	            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
	        },
	
	        toDate : function () {
	            return this._offset ? new Date(+this) : this._d;
	        },
	
	        toISOString : function () {
	            var m = moment(this).utc();
	            if (0 < m.year() && m.year() <= 9999) {
	                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	            } else {
	                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	            }
	        },
	
	        toArray : function () {
	            var m = this;
	            return [
	                m.year(),
	                m.month(),
	                m.date(),
	                m.hours(),
	                m.minutes(),
	                m.seconds(),
	                m.milliseconds()
	            ];
	        },
	
	        isValid : function () {
	            return isValid(this);
	        },
	
	        isDSTShifted : function () {
	
	            if (this._a) {
	                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
	            }
	
	            return false;
	        },
	
	        parsingFlags : function () {
	            return extend({}, this._pf);
	        },
	
	        invalidAt: function () {
	            return this._pf.overflow;
	        },
	
	        utc : function () {
	            return this.zone(0);
	        },
	
	        local : function () {
	            this.zone(0);
	            this._isUTC = false;
	            return this;
	        },
	
	        format : function (inputString) {
	            var output = formatMoment(this, inputString || moment.defaultFormat);
	            return this.lang().postformat(output);
	        },
	
	        add : function (input, val) {
	            var dur;
	            // switch args to support add('s', 1) and add(1, 's')
	            if (typeof input === 'string') {
	                dur = moment.duration(+val, input);
	            } else {
	                dur = moment.duration(input, val);
	            }
	            addOrSubtractDurationFromMoment(this, dur, 1);
	            return this;
	        },
	
	        subtract : function (input, val) {
	            var dur;
	            // switch args to support subtract('s', 1) and subtract(1, 's')
	            if (typeof input === 'string') {
	                dur = moment.duration(+val, input);
	            } else {
	                dur = moment.duration(input, val);
	            }
	            addOrSubtractDurationFromMoment(this, dur, -1);
	            return this;
	        },
	
	        diff : function (input, units, asFloat) {
	            var that = makeAs(input, this),
	                zoneDiff = (this.zone() - that.zone()) * 6e4,
	                diff, output;
	
	            units = normalizeUnits(units);
	
	            if (units === 'year' || units === 'month') {
	                // average number of days in the months in the given dates
	                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
	                // difference in months
	                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
	                // adjust by taking difference in days, average number of days
	                // and dst in the given months.
	                output += ((this - moment(this).startOf('month')) -
	                        (that - moment(that).startOf('month'))) / diff;
	                // same as above but with zones, to negate all dst
	                output -= ((this.zone() - moment(this).startOf('month').zone()) -
	                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
	                if (units === 'year') {
	                    output = output / 12;
	                }
	            } else {
	                diff = (this - that);
	                output = units === 'second' ? diff / 1e3 : // 1000
	                    units === 'minute' ? diff / 6e4 : // 1000 * 60
	                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
	                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	                    diff;
	            }
	            return asFloat ? output : absRound(output);
	        },
	
	        from : function (time, withoutSuffix) {
	            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
	        },
	
	        fromNow : function (withoutSuffix) {
	            return this.from(moment(), withoutSuffix);
	        },
	
	        calendar : function () {
	            // We want to compare the start of today, vs this.
	            // Getting start-of-today depends on whether we're zone'd or not.
	            var sod = makeAs(moment(), this).startOf('day'),
	                diff = this.diff(sod, 'days', true),
	                format = diff < -6 ? 'sameElse' :
	                    diff < -1 ? 'lastWeek' :
	                    diff < 0 ? 'lastDay' :
	                    diff < 1 ? 'sameDay' :
	                    diff < 2 ? 'nextDay' :
	                    diff < 7 ? 'nextWeek' : 'sameElse';
	            return this.format(this.lang().calendar(format, this));
	        },
	
	        isLeapYear : function () {
	            return isLeapYear(this.year());
	        },
	
	        isDST : function () {
	            return (this.zone() < this.clone().month(0).zone() ||
	                this.zone() < this.clone().month(5).zone());
	        },
	
	        day : function (input) {
	            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	            if (input != null) {
	                input = parseWeekday(input, this.lang());
	                return this.add({ d : input - day });
	            } else {
	                return day;
	            }
	        },
	
	        month : function (input) {
	            var utc = this._isUTC ? 'UTC' : '',
	                dayOfMonth;
	
	            if (input != null) {
	                if (typeof input === 'string') {
	                    input = this.lang().monthsParse(input);
	                    if (typeof input !== 'number') {
	                        return this;
	                    }
	                }
	
	                dayOfMonth = this.date();
	                this.date(1);
	                this._d['set' + utc + 'Month'](input);
	                this.date(Math.min(dayOfMonth, this.daysInMonth()));
	
	                moment.updateOffset(this);
	                return this;
	            } else {
	                return this._d['get' + utc + 'Month']();
	            }
	        },
	
	        startOf: function (units) {
	            units = normalizeUnits(units);
	            // the following switch intentionally omits break keywords
	            // to utilize falling through the cases.
	            switch (units) {
	            case 'year':
	                this.month(0);
	                /* falls through */
	            case 'month':
	                this.date(1);
	                /* falls through */
	            case 'week':
	            case 'isoWeek':
	            case 'day':
	                this.hours(0);
	                /* falls through */
	            case 'hour':
	                this.minutes(0);
	                /* falls through */
	            case 'minute':
	                this.seconds(0);
	                /* falls through */
	            case 'second':
	                this.milliseconds(0);
	                /* falls through */
	            }
	
	            // weeks are a special case
	            if (units === 'week') {
	                this.weekday(0);
	            } else if (units === 'isoWeek') {
	                this.isoWeekday(1);
	            }
	
	            return this;
	        },
	
	        endOf: function (units) {
	            units = normalizeUnits(units);
	            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
	        },
	
	        isAfter: function (input, units) {
	            units = typeof units !== 'undefined' ? units : 'millisecond';
	            return +this.clone().startOf(units) > +moment(input).startOf(units);
	        },
	
	        isBefore: function (input, units) {
	            units = typeof units !== 'undefined' ? units : 'millisecond';
	            return +this.clone().startOf(units) < +moment(input).startOf(units);
	        },
	
	        isSame: function (input, units) {
	            units = units || 'ms';
	            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
	        },
	
	        min: function (other) {
	            other = moment.apply(null, arguments);
	            return other < this ? this : other;
	        },
	
	        max: function (other) {
	            other = moment.apply(null, arguments);
	            return other > this ? this : other;
	        },
	
	        zone : function (input) {
	            var offset = this._offset || 0;
	            if (input != null) {
	                if (typeof input === "string") {
	                    input = timezoneMinutesFromString(input);
	                }
	                if (Math.abs(input) < 16) {
	                    input = input * 60;
	                }
	                this._offset = input;
	                this._isUTC = true;
	                if (offset !== input) {
	                    addOrSubtractDurationFromMoment(this, moment.duration(offset - input, 'm'), 1, true);
	                }
	            } else {
	                return this._isUTC ? offset : this._d.getTimezoneOffset();
	            }
	            return this;
	        },
	
	        zoneAbbr : function () {
	            return this._isUTC ? "UTC" : "";
	        },
	
	        zoneName : function () {
	            return this._isUTC ? "Coordinated Universal Time" : "";
	        },
	
	        parseZone : function () {
	            if (this._tzm) {
	                this.zone(this._tzm);
	            } else if (typeof this._i === 'string') {
	                this.zone(this._i);
	            }
	            return this;
	        },
	
	        hasAlignedHourOffset : function (input) {
	            if (!input) {
	                input = 0;
	            }
	            else {
	                input = moment(input).zone();
	            }
	
	            return (this.zone() - input) % 60 === 0;
	        },
	
	        daysInMonth : function () {
	            return daysInMonth(this.year(), this.month());
	        },
	
	        dayOfYear : function (input) {
	            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
	            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
	        },
	
	        quarter : function () {
	            return Math.ceil((this.month() + 1.0) / 3.0);
	        },
	
	        weekYear : function (input) {
	            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
	            return input == null ? year : this.add("y", (input - year));
	        },
	
	        isoWeekYear : function (input) {
	            var year = weekOfYear(this, 1, 4).year;
	            return input == null ? year : this.add("y", (input - year));
	        },
	
	        week : function (input) {
	            var week = this.lang().week(this);
	            return input == null ? week : this.add("d", (input - week) * 7);
	        },
	
	        isoWeek : function (input) {
	            var week = weekOfYear(this, 1, 4).week;
	            return input == null ? week : this.add("d", (input - week) * 7);
	        },
	
	        weekday : function (input) {
	            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
	            return input == null ? weekday : this.add("d", input - weekday);
	        },
	
	        isoWeekday : function (input) {
	            // behaves the same as moment#day except
	            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	            // as a setter, sunday should belong to the previous week.
	            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
	        },
	
	        get : function (units) {
	            units = normalizeUnits(units);
	            return this[units]();
	        },
	
	        set : function (units, value) {
	            units = normalizeUnits(units);
	            if (typeof this[units] === 'function') {
	                this[units](value);
	            }
	            return this;
	        },
	
	        // If passed a language key, it will set the language for this
	        // instance.  Otherwise, it will return the language configuration
	        // variables for this instance.
	        lang : function (key) {
	            if (key === undefined) {
	                return this._lang;
	            } else {
	                this._lang = getLangDefinition(key);
	                return this;
	            }
	        }
	    });
	
	    // helper for adding shortcuts
	    function makeGetterAndSetter(name, key) {
	        moment.fn[name] = moment.fn[name + 's'] = function (input) {
	            var utc = this._isUTC ? 'UTC' : '';
	            if (input != null) {
	                this._d['set' + utc + key](input);
	                moment.updateOffset(this);
	                return this;
	            } else {
	                return this._d['get' + utc + key]();
	            }
	        };
	    }
	
	    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
	    for (i = 0; i < proxyGettersAndSetters.length; i ++) {
	        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ''), proxyGettersAndSetters[i]);
	    }
	
	    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
	    makeGetterAndSetter('year', 'FullYear');
	
	    // add plural methods
	    moment.fn.days = moment.fn.day;
	    moment.fn.months = moment.fn.month;
	    moment.fn.weeks = moment.fn.week;
	    moment.fn.isoWeeks = moment.fn.isoWeek;
	
	    // add aliased format methods
	    moment.fn.toJSON = moment.fn.toISOString;
	
	    /************************************
	        Duration Prototype
	    ************************************/
	
	
	    extend(moment.duration.fn = Duration.prototype, {
	
	        _bubble : function () {
	            var milliseconds = this._milliseconds,
	                days = this._days,
	                months = this._months,
	                data = this._data,
	                seconds, minutes, hours, years;
	
	            // The following code bubbles up values, see the tests for
	            // examples of what that means.
	            data.milliseconds = milliseconds % 1000;
	
	            seconds = absRound(milliseconds / 1000);
	            data.seconds = seconds % 60;
	
	            minutes = absRound(seconds / 60);
	            data.minutes = minutes % 60;
	
	            hours = absRound(minutes / 60);
	            data.hours = hours % 24;
	
	            days += absRound(hours / 24);
	            data.days = days % 30;
	
	            months += absRound(days / 30);
	            data.months = months % 12;
	
	            years = absRound(months / 12);
	            data.years = years;
	        },
	
	        weeks : function () {
	            return absRound(this.days() / 7);
	        },
	
	        valueOf : function () {
	            return this._milliseconds +
	              this._days * 864e5 +
	              (this._months % 12) * 2592e6 +
	              toInt(this._months / 12) * 31536e6;
	        },
	
	        humanize : function (withSuffix) {
	            var difference = +this,
	                output = relativeTime(difference, !withSuffix, this.lang());
	
	            if (withSuffix) {
	                output = this.lang().pastFuture(difference, output);
	            }
	
	            return this.lang().postformat(output);
	        },
	
	        add : function (input, val) {
	            // supports only 2.0-style add(1, 's') or add(moment)
	            var dur = moment.duration(input, val);
	
	            this._milliseconds += dur._milliseconds;
	            this._days += dur._days;
	            this._months += dur._months;
	
	            this._bubble();
	
	            return this;
	        },
	
	        subtract : function (input, val) {
	            var dur = moment.duration(input, val);
	
	            this._milliseconds -= dur._milliseconds;
	            this._days -= dur._days;
	            this._months -= dur._months;
	
	            this._bubble();
	
	            return this;
	        },
	
	        get : function (units) {
	            units = normalizeUnits(units);
	            return this[units.toLowerCase() + 's']();
	        },
	
	        as : function (units) {
	            units = normalizeUnits(units);
	            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
	        },
	
	        lang : moment.fn.lang,
	
	        toIsoString : function () {
	            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	            var years = Math.abs(this.years()),
	                months = Math.abs(this.months()),
	                days = Math.abs(this.days()),
	                hours = Math.abs(this.hours()),
	                minutes = Math.abs(this.minutes()),
	                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);
	
	            if (!this.asSeconds()) {
	                // this is the same as C#'s (Noda) and python (isodate)...
	                // but not other JS (goog.date)
	                return 'P0D';
	            }
	
	            return (this.asSeconds() < 0 ? '-' : '') +
	                'P' +
	                (years ? years + 'Y' : '') +
	                (months ? months + 'M' : '') +
	                (days ? days + 'D' : '') +
	                ((hours || minutes || seconds) ? 'T' : '') +
	                (hours ? hours + 'H' : '') +
	                (minutes ? minutes + 'M' : '') +
	                (seconds ? seconds + 'S' : '');
	        }
	    });
	
	    function makeDurationGetter(name) {
	        moment.duration.fn[name] = function () {
	            return this._data[name];
	        };
	    }
	
	    function makeDurationAsGetter(name, factor) {
	        moment.duration.fn['as' + name] = function () {
	            return +this / factor;
	        };
	    }
	
	    for (i in unitMillisecondFactors) {
	        if (unitMillisecondFactors.hasOwnProperty(i)) {
	            makeDurationAsGetter(i, unitMillisecondFactors[i]);
	            makeDurationGetter(i.toLowerCase());
	        }
	    }
	
	    makeDurationAsGetter('Weeks', 6048e5);
	    moment.duration.fn.asMonths = function () {
	        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
	    };
	
	
	    /************************************
	        Default Lang
	    ************************************/
	
	
	    // Set default language, other languages will inherit from English.
	    moment.lang('en', {
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (toInt(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });
	
	    /* EMBED_LANGUAGES */
	
	    /************************************
	        Exposing Moment
	    ************************************/
	
	    function makeGlobal(deprecate) {
	        var warned = false, local_moment = moment;
	        /*global ender:false */
	        if (typeof ender !== 'undefined') {
	            return;
	        }
	        // here, `this` means `window` in the browser, or `global` on the server
	        // add `moment` as a global object via a string identifier,
	        // for Closure Compiler "advanced" mode
	        if (deprecate) {
	            global.moment = function () {
	                if (!warned && console && console.warn) {
	                    warned = true;
	                    console.warn(
	                            "Accessing Moment through the global scope is " +
	                            "deprecated, and will be removed in an upcoming " +
	                            "release.");
	                }
	                return local_moment.apply(null, arguments);
	            };
	            extend(global.moment, local_moment);
	        } else {
	            global['moment'] = moment;
	        }
	    }
	
	    // CommonJS module is defined
	    if (hasModule) {
	        module.exports = moment;
	        makeGlobal(true);
	    } else if (typeof define === "function" && define.amd) {
	        define("moment", function (require, exports, module) {
	            if (module.config && module.config() && module.config().noGlobal !== true) {
	                // If user provided noGlobal, he is aware of global
	                makeGlobal(module.config().noGlobal === undefined);
	            }
	
	            return moment;
	        });
	    } else {
	        makeGlobal();
	    }
	}).call(this);
	

}, '/lib/Cache.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Cache.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Cache.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Cache.js';
	var __dirname = '/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Cache.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Cache, isFunction;
	
	  isFunction = function(obj) {
	    return Object.prototype.toString.call(obj) === '[object Function]';
	  };
	
	  Cache = (function() {
	    Cache.FILES = 'files';
	
	    Cache.TAGS = 'tags';
	
	    Cache.EXPIRE = 'expire';
	
	    Cache.ITEMS = 'items';
	
	    Cache.PRIORITY = 'priority';
	
	    Cache.ALL = 'all';
	
	    Cache.TIME_FORMAT = 'YYYY-MM-DD HH:mm';
	
	    Cache.fs = null;
	
	    Cache.prototype.storage = null;
	
	    Cache.prototype.async = null;
	
	    Cache.prototype.namespace = null;
	
	    function Cache(storage, namespace) {
	      this.storage = storage;
	      this.namespace = namespace;
	      if (!(this.storage instanceof require('./Storage/Storage'))) {
	        throw new Error('Cache: storage must be instance of cache-storage/Storage/Storage');
	      }
	      this.async = this.storage.async;
	      this.storage.cache = this;
	    }
	
	    Cache.mockFs = function(tree, info) {
	      var FS;
	      if (tree == null) {
	        tree = {};
	      }
	      if (info == null) {
	        info = {};
	      }
	      FS = require('fs-mock');
	      Cache.fs = new FS(tree, info);
	      return Cache.fs;
	    };
	
	    Cache.restoreFs = function() {
	      if (typeof window !== 'undefined') {
	        throw new Error('Testing with fs module is not allowed in browser.');
	      }
	      return Cache.fs = require('fs');
	    };
	
	    Cache.getFs = function() {
	      if (Cache.fs === null) {
	        Cache.restoreFs();
	      }
	      return Cache.fs;
	    };
	
	    Cache.prototype.generateKey = function(key) {
	      var ch, hash, i, max, _i;
	      hash = 0;
	      if (key.length === 0) {
	        return hash;
	      }
	      max = key.length - 1;
	      for (i = _i = 0; 0 <= max ? _i <= max : _i >= max; i = 0 <= max ? ++_i : --_i) {
	        ch = key.charCodeAt(i);
	        hash = ((hash << 5) - hash) + ch;
	        hash |= 0;
	      }
	      return hash;
	    };
	
	    Cache.prototype.load = function(key, fallback, fn) {
	      var data,
	        _this = this;
	      if (fallback == null) {
	        fallback = null;
	      }
	      if (fn == null) {
	        fn = null;
	      }
	      if (this.async && arguments.length === 2) {
	        fn = fallback;
	        fallback = null;
	      }
	      if (this.async) {
	        return this.storage.read(this.generateKey(key), function(err, data) {
	          if (err) {
	            return fn(err, null);
	          } else if (data === null && fallback !== null) {
	            return _this.save(key, fallback, function(err, data) {
	              return fn(err, data);
	            });
	          } else {
	            return fn(null, data);
	          }
	        });
	      } else {
	        data = this.storage.read(this.generateKey(key));
	        if (data === null && fallback !== null) {
	          return this.save(key, fallback);
	        }
	        return data;
	      }
	    };
	
	    Cache.prototype.save = function(key, data, dependencies, fn) {
	      var _this = this;
	      if (dependencies == null) {
	        dependencies = {};
	      }
	      if (fn == null) {
	        fn = null;
	      }
	      if (isFunction(dependencies)) {
	        fn = dependencies;
	        dependencies = {};
	      }
	      key = this.generateKey(key);
	      if (isFunction(data)) {
	        data = data();
	      }
	      if (this.async) {
	        if (data === null) {
	          this.storage.remove(key, function(err) {
	            if (err) {
	              return fn(err, null);
	            } else {
	              return fn(null, data);
	            }
	          });
	        } else {
	          this.storage.parseDependencies(dependencies, function(err, dependencies) {
	            if (err) {
	              return fn(err, null);
	            } else {
	              return _this.storage.write(key, data, dependencies, function(err) {
	                if (err) {
	                  return fn(err, null);
	                } else {
	                  return fn(null, data);
	                }
	              });
	            }
	          });
	        }
	      } else {
	        if (data === null) {
	          this.storage.remove(key);
	        } else {
	          this.storage.write(key, data, this.storage.parseDependencies(dependencies));
	        }
	      }
	      return data;
	    };
	
	    Cache.prototype.remove = function(key, fn) {
	      if (fn == null) {
	        fn = null;
	      }
	      return this.save(key, null, fn);
	    };
	
	    Cache.prototype.clean = function(conditions, fn) {
	      if (fn == null) {
	        fn = null;
	      }
	      this.storage.clean(conditions, fn);
	      return this;
	    };
	
	    return Cache;
	
	  })();
	
	  module.exports = Cache;
	
	}).call(this);
	

}, 'fs-mock/lib/fs.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'fs-mock/lib/fs.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'fs-mock/lib/fs.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'fs-mock/lib/fs.js';
	var __dirname = 'fs-mock/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'fs-mock/lib/fs.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Errors, FSWatcher, Readable, Stats, Writable, escape, fs, isAppendable, isCreatable, isFunction, isReadable, isWritable, toDate, _path;
	
	  Stats = require('./Stats');
	
	  Errors = require('./Errors');
	
	  FSWatcher = require('./FSWatcher');
	
	  escape = require('escape-regexp');
	
	  _path = require('path');
	
	  Readable = require('stream').Readable;
	
	  Writable = require('stream').Writable;
	
	  isFunction = function(obj) {
	    return Object.prototype.toString.call(obj) === '[object Function]';
	  };
	
	  isReadable = function(flags) {
	    return flags === 'r' || flags === 'r+' || flags === 'rs' || flags === 'rs+' || flags === 'w+' || flags === 'wx+' || flags === 'a+' || flags === 'ax+';
	  };
	
	  isWritable = function(flags) {
	    return flags === 'r+' || flags === 'rs+' || flags === 'w' || flags === 'wx' || flags === 'w+' || flags === 'wx+';
	  };
	
	  isAppendable = function(flags) {
	    return flags === 'a' || flags === 'ax' || flags === 'a+' || flags === 'ax+';
	  };
	
	  isCreatable = function(flags) {
	    return flags === 'w' || flags === 'w+' || flags === 'a' || flags === 'a+';
	  };
	
	  toDate = function(time) {
	    if (typeof time === 'number') {
	      return new Date(time * 1000);
	    }
	    if (time instanceof Date) {
	      return time;
	    }
	    throw new Error("Cannot parse time: " + time);
	  };
	
	  fs = (function() {
	    fs.prototype._data = null;
	
	    fs.prototype._fileDescriptors = null;
	
	    fs.prototype._fileDescriptorsCounter = 0;
	
	    function fs(tree, info) {
	      if (tree == null) {
	        tree = {};
	      }
	      if (info == null) {
	        info = {};
	      }
	      this._data = {};
	      this._fileDescriptors = [];
	      this._addPath('/', {});
	      this._setTree(tree, info);
	    }
	
	    fs.prototype._hasFd = function(fd) {
	      return typeof this._fileDescriptors[fd] !== 'undefined';
	    };
	
	    fs.prototype._hasSubPaths = function(path) {
	      var data, found, _ref;
	      _ref = this._data;
	      for (found in _ref) {
	        data = _ref[found];
	        if (path !== found && found.match(new RegExp('^' + escape(path))) !== null) {
	          return true;
	        }
	      }
	      return false;
	    };
	
	    fs.prototype._setAttributes = function(path, attributes) {
	      if (attributes == null) {
	        attributes = {};
	      }
	      return this._data[path].stats._setAttributes(attributes);
	    };
	
	    fs.prototype._addPath = function(path, data, info) {
	      var item, stats, subData, subPath, type, _ref, _results;
	      if (data == null) {
	        data = '';
	      }
	      if (info == null) {
	        info = {};
	      }
	      if (typeof info.stats === 'undefined') {
	        info.stats = {};
	      }
	      if (typeof info.mode === 'undefined') {
	        info.mode = 777;
	      }
	      if (typeof info.encoding === 'undefined') {
	        info.encoding = 'utf8';
	      }
	      if (typeof info.source === 'undefined') {
	        info.source = null;
	      }
	      if (path[0] === '@') {
	        return this.linkSync(data, path.substr(1));
	      }
	      if (path[0] === '%') {
	        type = 'symlink';
	        info = {
	          source: data
	        };
	        path = path.substr(1);
	      } else if (typeof data === 'string') {
	        type = 'file';
	        info = {
	          data: data
	        };
	      } else if (Object.prototype.toString.call(data) === '[object Object]') {
	        type = 'directory';
	        info = {
	          paths: data
	        };
	      } else {
	        throw new Error('Unknown type');
	      }
	      path = _path.join('/', path);
	      stats = new Stats(path, info.stats);
	      stats.mode = info.mode;
	      this._data[path] = {};
	      item = this._data[path];
	      item.stats = stats;
	      switch (type) {
	        case 'directory':
	          stats._isDirectory = true;
	          if (typeof info.paths !== 'undefined') {
	            _ref = info.paths;
	            _results = [];
	            for (subPath in _ref) {
	              subData = _ref[subPath];
	              _results.push(this._addPath(_path.join(path, subPath), subData));
	            }
	            return _results;
	          }
	          break;
	        case 'file':
	          stats._isFile = true;
	          if (typeof info.data === 'undefined') {
	            item.data = new Buffer('', info.encoding);
	          } else if (info.data instanceof Buffer) {
	            item.data = info.data;
	          } else {
	            item.data = new Buffer(info.data, info.encoding);
	          }
	          return stats.blksize = stats.size = item.data.length;
	        case 'symlink':
	          stats._isSymlink = true;
	          return item.source = info.source;
	        default:
	          throw new Error("Type must be directory, file or symlink, " + type + " given.");
	      }
	    };
	
	    fs.prototype._expandPaths = function() {
	      var data, path, _ref, _results;
	      _ref = this._data;
	      _results = [];
	      for (path in _ref) {
	        data = _ref[path];
	        _results.push(this._expandPath(path));
	      }
	      return _results;
	    };
	
	    fs.prototype._expandPath = function(path) {
	      var match, position, sub, _results;
	      match = path.match(/\//g);
	      if (match !== null && match.length > 1) {
	        sub = path;
	        _results = [];
	        while (sub !== null) {
	          position = sub.lastIndexOf('/');
	          if (position > 0) {
	            sub = sub.substring(0, sub.lastIndexOf('/'));
	            if (typeof this._data[sub] === 'undefined') {
	              _results.push(this._addPath(sub, {}));
	            } else {
	              _results.push(void 0);
	            }
	          } else {
	            _results.push(sub = null);
	          }
	        }
	        return _results;
	      }
	    };
	
	    fs.prototype._setTree = function(tree, info) {
	      var attributes, data, path;
	      if (info == null) {
	        info = {};
	      }
	      for (path in tree) {
	        data = tree[path];
	        this._addPath(path, data);
	      }
	      for (path in info) {
	        attributes = info[path];
	        this._setAttributes(path, attributes);
	      }
	      return this._expandPaths();
	    };
	
	    fs.prototype._realpath = function(path) {
	      if (path[0] === '.') {
	        path = _path.join('/', path);
	      }
	      return _path.normalize(path);
	    };
	
	    fs.prototype._getSourcePath = function(path) {
	      var _ref;
	      path = this._realpath(path);
	      if ((_ref = this._data[path]) != null ? _ref.stats.isSymbolicLink() : void 0) {
	        path = this._data[path].source;
	      }
	      return path;
	    };
	
	    fs.prototype.rename = function(oldPath, newPath, callback) {
	      var err;
	      try {
	        this.renameSync(oldPath, newPath);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.renameSync = function(oldPath, newPath) {
	      oldPath = this.realpathSync(oldPath);
	      newPath = this._realpath(newPath);
	      if (!this.existsSync(oldPath)) {
	        Errors.notFound(oldPath);
	      }
	      if (this.existsSync(newPath)) {
	        Errors.alreadyExists(newPath);
	      }
	      this._data[newPath] = this._data[oldPath];
	      delete this._data[oldPath];
	      this._data[newPath].stats._path = newPath;
	      return this._data[newPath].stats._modifiedAttributes('rename');
	    };
	
	    fs.prototype.ftruncate = function(fd, len, callback) {
	      var err;
	      try {
	        this.ftruncateSync(fd, len);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.ftruncateSync = function(fd, len) {
	      var data, item;
	      if (!this._hasFd(fd)) {
	        Errors.fdNotFound(fd);
	      }
	      item = this._data[this._fileDescriptors[fd].path];
	      data = item.data.toString('utf8');
	      if (item.data.length > len) {
	        data = data.substr(0, len);
	      }
	      return this.writeSync(fd, new Buffer(data), 0, data.length, null);
	    };
	
	    fs.prototype.truncate = function(path, len, callback) {
	      var err;
	      try {
	        this.truncateSync(path, len);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.truncateSync = function(path, len) {
	      var fd;
	      path = this._getSourcePath(path);
	      if (!this.existsSync(path)) {
	        Errors.notFound(path);
	      }
	      fd = this.openSync(path, 'w');
	      if (!this.fstatSync(fd).isFile()) {
	        Errors.notFile(path);
	      }
	      this.ftruncateSync(fd, len);
	      return this.closeSync(fd);
	    };
	
	    fs.prototype.chown = function(path, uid, gid, callback) {
	      var err;
	      try {
	        this.chownSync(path, uid, gid);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.chownSync = function(path, uid, gid) {
	      var fd;
	      path = this._getSourcePath(path);
	      fd = this.openSync(path, 'r');
	      this.fchownSync(fd, uid, gid);
	      return this.closeSync(fd);
	    };
	
	    fs.prototype.fchown = function(fd, uid, gid, callback) {
	      var err;
	      try {
	        this.fchownSync(fd, uid, gid);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.fchownSync = function(fd, uid, gid) {
	      if (!this._hasFd(fd)) {
	        Errors.fdNotFound(fd);
	      }
	      return this._setAttributes(this._fileDescriptors[fd].path, {
	        uid: uid,
	        gid: gid
	      });
	    };
	
	    fs.prototype.lchown = function(path, uid, gid, callback) {
	      var err;
	      try {
	        this.lchownSync(path, uid, gid);
	        return callback(null);
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.lchownSync = function(path, uid, gid) {
	      path = this.realpathSync(path);
	      if (!this.existsSync(path)) {
	        Errors.notFound(path);
	      }
	      if (!this.lstatSync(path).isSymbolicLink()) {
	        Errors.notSymlink(path);
	      }
	      return this._setAttributes(path, {
	        uid: uid,
	        gid: gid
	      });
	    };
	
	    fs.prototype.chmod = function(path, mode, callback) {
	      var err;
	      try {
	        this.chmodSync(path, mode);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.chmodSync = function(path, mode) {
	      var fd;
	      path = this._getSourcePath(path);
	      fd = this.openSync(path, 'r', mode);
	      this.fchmodSync(fd, mode);
	      return this.closeSync(fd);
	    };
	
	    fs.prototype.fchmod = function(fd, mode, callback) {
	      var err;
	      try {
	        this.fchmodSync(fd, mode);
	        return callback(null);
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.fchmodSync = function(fd, mode) {
	      if (!this._hasFd(fd)) {
	        Errors.fdNotFound(fd);
	      }
	      return this._setAttributes(this._fileDescriptors[fd].path, {
	        mode: mode
	      });
	    };
	
	    fs.prototype.lchmod = function(path, mode, callback) {
	      var err;
	      try {
	        this.lchmodSync(path, mode);
	        return callback(null);
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.lchmodSync = function(path, mode) {
	      path = this.realpathSync(path);
	      if (!this.existsSync(path)) {
	        Errors.notFound(path);
	      }
	      if (!this.lstatSync(path).isSymbolicLink()) {
	        Errors.notSymlink(path);
	      }
	      return this._setAttributes(path, {
	        mode: mode
	      });
	    };
	
	    fs.prototype.stat = function(path, callback) {
	      var err;
	      try {
	        return callback(null, this.statSync(path));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.statSync = function(path) {
	      var fd, result;
	      path = this._getSourcePath(path);
	      fd = this.openSync(path, 'r');
	      result = this.fstatSync(fd);
	      this.closeSync(fd);
	      return result;
	    };
	
	    fs.prototype.lstat = function(path, callback) {
	      var err;
	      try {
	        return callback(null, this.lstatSync(path));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.lstatSync = function(path) {
	      var stats;
	      path = this.realpathSync(path);
	      if (!this.existsSync(path)) {
	        Error.notFound(path);
	      }
	      stats = this._data[path].stats;
	      if (!stats.isSymbolicLink()) {
	        Errors.notSymlink(path);
	      }
	      return stats;
	    };
	
	    fs.prototype.fstat = function(fd, callback) {
	      var err;
	      try {
	        return callback(null, this.fstatSync(fd));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.fstatSync = function(fd) {
	      if (!this._hasFd(fd)) {
	        Errors.fdNotFound(fd);
	      }
	      return this._data[this._fileDescriptors[fd].path].stats;
	    };
	
	    fs.prototype.link = function(srcpath, dstpath, callback) {
	      var err;
	      try {
	        this.linkSync(srcpath, dstpath);
	        return callback(null);
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.linkSync = function(srcpath, dstpath) {
	      srcpath = this.realpathSync(srcpath);
	      dstpath = this._realpath(dstpath);
	      if (!this.existsSync(srcpath)) {
	        Errors.notFound(srcpath);
	      }
	      return this._data[dstpath] = this._data[srcpath];
	    };
	
	    fs.prototype.symlink = function(srcpath, dstpath, type, callback) {
	      var err;
	      if (type == null) {
	        type = null;
	      }
	      if (isFunction(type)) {
	        callback = type;
	        type = null;
	      }
	      try {
	        this.symlinkSync(srcpath, dstpath);
	        return callback(null);
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.symlinkSync = function(srcpath, dstpath, type) {
	      if (type == null) {
	        type = null;
	      }
	      srcpath = this.realpathSync(srcpath);
	      dstpath = this._realpath(dstpath);
	      if (!this.existsSync(srcpath)) {
	        Errors.notFound(srcpath);
	      }
	      return this._addPath('%' + dstpath, srcpath);
	    };
	
	    fs.prototype.readlink = function(path, callback) {
	      var err;
	      try {
	        return callback(null, this.readlinkSync(path));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.readlinkSync = function(path) {
	      path = this._getSourcePath(path);
	      if (!this.existsSync(path)) {
	        Errors.notFound(path);
	      }
	      return path;
	    };
	
	    fs.prototype.realpath = function(path, cache, callback) {
	      var err;
	      if (cache == null) {
	        cache = null;
	      }
	      if (isFunction(cache)) {
	        callback = cache;
	        cache = null;
	      }
	      try {
	        return callback(null, this.realpathSync(path, cache));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.realpathSync = function(path, cache) {
	      if (cache == null) {
	        cache = null;
	      }
	      if (cache !== null && typeof cache[path] !== 'undefined') {
	        return cache[path];
	      }
	      path = this._realpath(path);
	      if (!this.existsSync(path)) {
	        Errors.notFound(path);
	      }
	      return path;
	    };
	
	    fs.prototype.unlink = function(path, callback) {
	      var err;
	      try {
	        this.unlinkSync(path);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.unlinkSync = function(path) {
	      path = this.realpathSync(path);
	      if (!this.existsSync(path)) {
	        Errors.notFound(path);
	      }
	      if (!this.statSync(path).isFile()) {
	        Errors.notFile(path);
	      }
	      return delete this._data[path];
	    };
	
	    fs.prototype.rmdir = function(path, callback) {
	      var err;
	      try {
	        this.rmdirSync(path);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.rmdirSync = function(path) {
	      path = this.realpathSync(path);
	      if (!this.existsSync(path)) {
	        Errors.notFound(path);
	      }
	      if (!this.statSync(path).isDirectory()) {
	        Errors.notDirectory(path);
	      }
	      if (this._hasSubPaths(path)) {
	        Errors.directoryNotEmpty(path);
	      }
	      return delete this._data[path];
	    };
	
	    fs.prototype.mkdir = function(path, mode, callback) {
	      var err;
	      if (mode == null) {
	        mode = null;
	      }
	      if (isFunction(mode)) {
	        callback = mode;
	        mode = null;
	      }
	      try {
	        this.mkdirSync(path, mode);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.mkdirSync = function(path, mode) {
	      if (mode == null) {
	        mode = null;
	      }
	      path = this._realpath(path);
	      if (this.existsSync(path)) {
	        Errors.alreadyExists(path);
	      }
	      this._addPath(path, {}, {
	        mode: mode
	      });
	      return this._expandPath(path);
	    };
	
	    fs.prototype.readdir = function(path, callback) {
	      var err;
	      try {
	        return callback(null, this.readdirSync(path));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.readdirSync = function(path) {
	      var data, files, match, name, slashes, _ref;
	      path = this._getSourcePath(path);
	      if (!this.existsSync(path)) {
	        Errors.notFound(path);
	      }
	      if (!this.statSync(path).isDirectory()) {
	        Errors.notDirectory(path);
	      }
	      path = path === '/' ? '' : path;
	      path = escape(path);
	      files = [];
	      _ref = this._data;
	      for (name in _ref) {
	        data = _ref[name];
	        if (name !== path && name !== '/' && (match = name.match(new RegExp('^' + path + '(.+)$'))) !== null) {
	          slashes = match[1].match(/\//g);
	          slashes = slashes === null ? 0 : slashes.length;
	          if (slashes === 1) {
	            files.push(match[1].substr(1));
	          }
	        }
	      }
	      return files;
	    };
	
	    fs.prototype.close = function(fd, callback) {
	      var err;
	      try {
	        this.closeSync(fd);
	        return callback();
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.closeSync = function(fd) {
	      if (!this._hasFd(fd)) {
	        Errors.fdNotFound(fd);
	      }
	      return delete this._fileDescriptors[fd];
	    };
	
	    fs.prototype.open = function(path, flags, mode, callback) {
	      var err;
	      if (mode == null) {
	        mode = null;
	      }
	      if (isFunction(mode)) {
	        callback = mode;
	        mode = null;
	      }
	      try {
	        return callback(null, this.openSync(path, flags, mode));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.openSync = function(path, flags, mode) {
	      var exists;
	      if (mode == null) {
	        mode = null;
	      }
	      path = this._getSourcePath(path);
	      exists = this.existsSync(path);
	      if ((flags === 'r' || flags === 'r+') && !exists) {
	        Errors.notFound(path);
	      }
	      if ((flags === 'wx' || flags === 'wx+' || flags === 'ax' || flags === 'ax+') && exists) {
	        Errors.alreadyExists(path);
	      }
	      this._fileDescriptors[this._fileDescriptorsCounter] = {
	        path: path,
	        flags: flags
	      };
	      if (isCreatable(flags) && !exists) {
	        this._addPath(path, '', {
	          mode: mode
	        });
	      }
	      this._fileDescriptorsCounter++;
	      return this._fileDescriptorsCounter - 1;
	    };
	
	    fs.prototype.utimes = function(path, atime, mtime, callback) {
	      var err;
	      try {
	        this.utimesSync(path, atime, mtime);
	        return callback(null);
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.utimesSync = function(path, atime, mtime) {
	      var fd;
	      path = this.realpathSync(path);
	      fd = this.openSync(path, 'r');
	      this.futimesSync(fd, atime, mtime);
	      return this.closeSync(fd);
	    };
	
	    fs.prototype.futimes = function(fd, atime, mtime, callback) {
	      var err;
	      try {
	        this.futimesSync(fd, atime, mtime);
	        return callback(null);
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.futimesSync = function(fd, atime, mtime) {
	      if (!this._hasFd(fd)) {
	        Errors.fdNotFound(fd);
	      }
	      return this._setAttributes(this._fileDescriptors[fd].path, {
	        atime: toDate(atime),
	        mtime: toDate(mtime)
	      });
	    };
	
	    fs.prototype.fsync = function(fd, callback) {
	      var err;
	      try {
	        this.fsyncSync(fd);
	        return callback(null);
	      } catch (_error) {
	        err = _error;
	        return callback(err);
	      }
	    };
	
	    fs.prototype.fsyncSync = function(fd) {
	      if (!this._hasFd(fd)) {
	        return Errors.fdNotFound(fd);
	      }
	    };
	
	    fs.prototype.write = function(fd, buffer, offset, length, position, callback) {
	      var err;
	      if (position == null) {
	        position = null;
	      }
	      if (callback == null) {
	        callback = null;
	      }
	      try {
	        this.writeSync(fd, buffer, offset, length, position);
	        if (callback !== null) {
	          return callback(null, length, buffer);
	        }
	      } catch (_error) {
	        err = _error;
	        if (callback !== null) {
	          return callback(err, null, buffer);
	        }
	      }
	    };
	
	    fs.prototype.writeSync = function(fd, buffer, offset, length, position) {
	      var data, fdData, item, oldData, oldFlags, path, stats;
	      if (position == null) {
	        position = null;
	      }
	      if (!this._hasFd(fd)) {
	        Errors.fdNotFound(fd);
	      }
	      fdData = this._fileDescriptors[fd];
	      path = fdData.path;
	      if (!isWritable(fdData.flags)) {
	        Errors.notWritable(path);
	      }
	      stats = this.fstatSync(fd);
	      if (!stats.isFile()) {
	        Errors.notFile(path);
	      }
	      item = this._data[path];
	      data = buffer.toString('utf8', offset).substr(0, length);
	      if (position !== null) {
	        buffer = new Buffer(stats.size);
	        oldFlags = fdData.flags;
	        fdData.flags = 'r';
	        this.readSync(fd, buffer, 0, stats.size, 0);
	        fdData.flags = oldFlags;
	        oldData = buffer.toString('utf8');
	        data = [oldData.slice(0, position), data, oldData.slice(position)].join('');
	      }
	      item.data = new Buffer(data);
	      item.stats.size = data.length;
	      item.stats.blksize = data.length;
	      return item.stats._modified();
	    };
	
	    fs.prototype.read = function(fd, buffer, offset, length, position, callback) {
	      var err;
	      if (position == null) {
	        position = 0;
	      }
	      if (callback == null) {
	        callback = null;
	      }
	      try {
	        this.readSync(fd, buffer, offset, length, position);
	        if (callback !== null) {
	          return callback(null, length, buffer);
	        }
	      } catch (_error) {
	        err = _error;
	        if (callback !== null) {
	          return callback(err, 0, buffer);
	        }
	      }
	    };
	
	    fs.prototype.readSync = function(fd, buffer, offset, length, position) {
	      var data, item, path;
	      if (position == null) {
	        position = 0;
	      }
	      if (!this._hasFd(fd)) {
	        Errors.fdNotFound(fd);
	      }
	      item = this._fileDescriptors[fd];
	      path = item.path;
	      if (!isReadable(item.flags)) {
	        Errors.notReadable(path);
	      }
	      if (!this.fstatSync(fd).isFile()) {
	        Errors.notFile(path);
	      }
	      item = this._data[path];
	      data = item.data.toString('utf8');
	      data = data.substr(position, length);
	      buffer.write(data, offset);
	      item.stats._accessed();
	      return length;
	    };
	
	    fs.prototype.readFile = function(filename, options, callback) {
	      var err;
	      if (options == null) {
	        options = {};
	      }
	      if (isFunction(options)) {
	        callback = options;
	        options = null;
	      }
	      try {
	        return callback(null, this.readFileSync(filename, options));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.readFileSync = function(filename, options) {
	      var buffer, data, fd, size;
	      if (options == null) {
	        options = {};
	      }
	      if (typeof options.encoding === 'undefined') {
	        options.encoding = null;
	      }
	      if (typeof options.flag === 'undefined') {
	        options.flag = 'r';
	      }
	      fd = this.openSync(filename, options.flag);
	      size = this.fstatSync(fd).size;
	      buffer = new Buffer(size);
	      this.readSync(fd, buffer, 0, size, null);
	      this.closeSync(fd);
	      data = buffer;
	      if (options.encoding !== null) {
	        data = buffer.toString(options.encoding);
	      }
	      return data;
	    };
	
	    fs.prototype.writeFile = function(filename, data, options, callback) {
	      var err;
	      if (options == null) {
	        options = {};
	      }
	      if (isFunction(options)) {
	        callback = options;
	        options = null;
	      }
	      try {
	        return callback(null, this.writeFileSync(filename, data, options));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.writeFileSync = function(filename, data, options) {
	      var fd;
	      if (options == null) {
	        options = {};
	      }
	      if (typeof options.encoding === 'undefined') {
	        options.encoding = 'utf8';
	      }
	      if (typeof options.mode === 'undefined') {
	        options.mode = 438;
	      }
	      if (typeof options.flag === 'undefined') {
	        options.flag = 'w';
	      }
	      filename = this._getSourcePath(filename);
	      fd = this.openSync(filename, options.flag, options.mode);
	      this.writeSync(fd, new Buffer(data, options.encoding), 0, data.length, null);
	      this.closeSync(fd);
	      return this._expandPath(filename);
	    };
	
	    fs.prototype.appendFile = function(filename, data, options, callback) {
	      var err;
	      if (options == null) {
	        options = {};
	      }
	      if (isFunction(options)) {
	        callback = options;
	        options = null;
	      }
	      try {
	        return callback(null, this.appendFileSync(filename, data, options));
	      } catch (_error) {
	        err = _error;
	        return callback(err, null);
	      }
	    };
	
	    fs.prototype.appendFileSync = function(filename, data, options) {
	      var fd, size;
	      if (options == null) {
	        options = {};
	      }
	      if (typeof options.encoding === 'undefined') {
	        options.encoding = 'utf8';
	      }
	      if (typeof options.mode === 'undefined') {
	        options.mode = 438;
	      }
	      if (typeof options.flag === 'undefined') {
	        options.flag = 'w';
	      }
	      if (typeof data === 'string') {
	        data = new Buffer(data, options.encoding);
	      }
	      fd = this.openSync(filename, options.flag, options.mode);
	      size = this.fstatSync(fd).size;
	      this.writeSync(fd, data, 0, data.length, size);
	      return this.closeSync(fd);
	    };
	
	    fs.prototype.watchFile = function(filename, options, listener) {
	      if (options == null) {
	        options = null;
	      }
	      if (listener == null) {
	        listener = null;
	      }
	      if (isFunction(options)) {
	        listener = options;
	        options = null;
	      }
	      return Errors.notImplemented('watchFile');
	    };
	
	    fs.prototype.unwatchFile = function(filename, listener) {
	      if (listener == null) {
	        listener = null;
	      }
	      return Errors.notImplemented('unwatchFile');
	    };
	
	    fs.prototype.watch = function(filename, options, listener) {
	      var stats, watcher;
	      if (options == null) {
	        options = null;
	      }
	      if (listener == null) {
	        listener = null;
	      }
	      if (isFunction(options)) {
	        listener = options;
	        options = null;
	      }
	      if (!this.existsSync(filename)) {
	        Errors.notFound(filename);
	      }
	      watcher = new FSWatcher(listener);
	      stats = this.statSync(filename);
	      stats.on('modified', function(stats) {
	        return watcher.emit('change', 'change', stats._path);
	      });
	      stats.on('modifiedAttributes', function(stats, event) {
	        return watcher.emit('change', event, stats._path);
	      });
	      return watcher;
	    };
	
	    fs.prototype.exists = function(path, callback) {
	      return callback(this.existsSync(path));
	    };
	
	    fs.prototype.existsSync = function(path) {
	      path = this._realpath(path);
	      return typeof this._data[path] !== 'undefined';
	    };
	
	    fs.prototype.createReadStream = function(path, options) {
	      var buffer, data, fd, rs, size;
	      if (options == null) {
	        options = {};
	      }
	      if (typeof options.flags === 'undefined') {
	        options.flags = 'r';
	      }
	      if (typeof options.encoding === 'undefined') {
	        options.encoding = null;
	      }
	      if (typeof options.fd === 'undefined') {
	        options.fd = null;
	      }
	      if (typeof options.mode === 'undefined') {
	        options.mode = 666;
	      }
	      if (typeof options.autoClose === 'undefined') {
	        options.autoClose = true;
	      }
	      if (typeof options.start === 'undefined') {
	        options.start = null;
	      }
	      if (typeof options.end === 'undefined') {
	        options.end = null;
	      }
	      if (options.fd === null) {
	        fd = this.openSync(path, options.flags, options.mode);
	      }
	      size = this.fstatSync(fd).size;
	      rs = new Readable;
	      buffer = new Buffer(size);
	      this.readSync(fd, buffer, 0, size, 0);
	      data = buffer.toString(options.encoding);
	      if (options.start !== null && options.end !== null) {
	        data = data.substring(options.start, options.end);
	      }
	      rs.push(data);
	      rs.push(null);
	      if (options.autoClose) {
	        this.closeSync(fd);
	      }
	      return rs;
	    };
	
	    fs.prototype.createWriteStream = function(path, options) {
	      var fd, position, ws,
	        _this = this;
	      if (options == null) {
	        options = {};
	      }
	      if (typeof options.flags === 'undefined') {
	        options.flags = 'w';
	      }
	      if (typeof options.encoding === 'undefined') {
	        options.encoding = null;
	      }
	      if (typeof options.mode === 'undefined') {
	        options.mode = 666;
	      }
	      if (typeof options.start === 'undefined') {
	        options.start = 0;
	      }
	      fd = this.openSync(path, options.flags, options.mode);
	      position = options.start;
	      ws = Writable();
	      ws._write = function(chunk, enc, next) {
	        if (typeof chunk === 'string') {
	          chunk = new Buffer(chunk);
	        }
	        return _this.write(fd, chunk, 0, chunk.length, position, function(err) {
	          if (err) {
	            throw err;
	          }
	          position += chunk.length;
	          return next();
	        });
	      };
	      ws.on('finish', function() {
	        return _this.closeSync(fd);
	      });
	      return ws;
	    };
	
	    return fs;
	
	  })();
	
	  module.exports = fs;
	
	}).call(this);
	

}, 'fs-mock/lib/Stats.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'fs-mock/lib/Stats.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'fs-mock/lib/Stats.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'fs-mock/lib/Stats.js';
	var __dirname = 'fs-mock/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'fs-mock/lib/Stats.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Errors, EventEmitter, Stats,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  Errors = require('./Errors');
	
	  EventEmitter = require('events').EventEmitter;
	
	  Stats = (function(_super) {
	    __extends(Stats, _super);
	
	    Stats.prototype._path = null;
	
	    Stats.prototype._isFile = false;
	
	    Stats.prototype._isDirectory = false;
	
	    Stats.prototype._isSymlink = false;
	
	    Stats.prototype.dev = 0;
	
	    Stats.prototype.ino = 0;
	
	    Stats.prototype.mode = 438;
	
	    Stats.prototype.nlink = 0;
	
	    Stats.prototype.uid = 100;
	
	    Stats.prototype.gid = 100;
	
	    Stats.prototype.rdev = 0;
	
	    Stats.prototype.size = 0;
	
	    Stats.prototype.blksize = 0;
	
	    Stats.prototype.blocks = 1;
	
	    Stats.prototype.atime = null;
	
	    Stats.prototype.mtime = null;
	
	    Stats.prototype.ctime = null;
	
	    function Stats(_path, data) {
	      var name, value;
	      this._path = _path;
	      if (data == null) {
	        data = {};
	      }
	      this.atime = new Date;
	      this.mtime = new Date;
	      this.ctime = new Date;
	      for (name in data) {
	        value = data[name];
	        if (typeof this[name] !== 'undefined' && Object.prototype.toString.call(this[name]) !== '[object Function]') {
	          this[name] = value;
	        }
	      }
	    }
	
	    Stats.prototype._modified = function() {
	      this.mtime = new Date;
	      this.ctime = new Date;
	      return this.emit('modified', this);
	    };
	
	    Stats.prototype._modifiedAttributes = function(event) {
	      if (event == null) {
	        event = 'change';
	      }
	      this.ctime = new Date;
	      return this.emit('modifiedAttributes', this, event);
	    };
	
	    Stats.prototype._accessed = function() {
	      this.atime = new Date;
	      return this.emit('accessed', this);
	    };
	
	    Stats.prototype._setAttributes = function(attributes) {
	      var name, value;
	      if (attributes == null) {
	        attributes = {};
	      }
	      for (name in attributes) {
	        value = attributes[name];
	        if (Object.prototype.toString.call(this[name]) !== '[object Function]') {
	          this[name] = value;
	        }
	      }
	      return this._modifiedAttributes();
	    };
	
	    Stats.prototype._clone = function() {
	      var name, stats, value;
	      stats = new Stats(this._path, {});
	      for (name in this) {
	        value = this[name];
	        if (Object.prototype.toString.call(this[name]) !== '[object Function]') {
	          stats[name] = this[name];
	        }
	      }
	      return stats;
	    };
	
	    Stats.prototype.isFile = function() {
	      return this._isFile;
	    };
	
	    Stats.prototype.isDirectory = function() {
	      return this._isDirectory;
	    };
	
	    Stats.prototype.isBlockDevice = function() {
	      return Errors.notImplemented('isBlockDevice');
	    };
	
	    Stats.prototype.isCharacterDevice = function() {
	      return Errors.notImplemented('isCharacterDevice');
	    };
	
	    Stats.prototype.isSymbolicLink = function() {
	      return this._isSymlink;
	    };
	
	    Stats.prototype.isFIFO = function() {
	      return Errors.notImplemented('isFIFO');
	    };
	
	    Stats.prototype.isSocket = function() {
	      return Errors.notImplemented('isSocket');
	    };
	
	    return Stats;
	
	  })(EventEmitter);
	
	  module.exports = Stats;
	
	}).call(this);
	

}, 'fs-mock/lib/Errors.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'fs-mock/lib/Errors.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'fs-mock/lib/Errors.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'fs-mock/lib/Errors.js';
	var __dirname = 'fs-mock/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'fs-mock/lib/Errors.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Errors;
	
	  Errors = (function() {
	    function Errors() {}
	
	    Errors.notImplemented = function(method) {
	      throw new Error("Method '" + method + "' is not implemented.");
	    };
	
	    Errors.notFound = function(path) {
	      throw new Error("File or directory '" + path + "' does not exists.");
	    };
	
	    Errors.alreadyExists = function(path) {
	      throw new Error("File or directory '" + path + "' already exists.");
	    };
	
	    Errors.directoryExists = function(path) {
	      throw new Error("Directory '" + path + "' already exists.");
	    };
	
	    Errors.notFile = function(path) {
	      throw new Error("Path '" + path + "' is not a file.");
	    };
	
	    Errors.notDirectory = function(path) {
	      throw new Error("Path '" + path + "' is not a directory.");
	    };
	
	    Errors.notSymlink = function(path) {
	      throw new Error("Path '" + path + "' is not a symbolic link.");
	    };
	
	    Errors.directoryNotEmpty = function(path) {
	      throw new Error("Directory '" + path + "' is not empty.");
	    };
	
	    Errors.fdNotFound = function(fd) {
	      throw new Error("File descriptor " + fd + " not exists.");
	    };
	
	    Errors.notWritable = function(path) {
	      throw new Error("File '" + path + "' is not open for writing.");
	    };
	
	    Errors.notReadable = function(path) {
	      throw new Error("File '" + path + "' is not open for reading.");
	    };
	
	    return Errors;
	
	  })();
	
	  module.exports = Errors;
	
	}).call(this);
	

}, 'fs-mock/lib/FSWatcher.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'fs-mock/lib/FSWatcher.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'fs-mock/lib/FSWatcher.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'fs-mock/lib/FSWatcher.js';
	var __dirname = 'fs-mock/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'fs-mock/lib/FSWatcher.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var EventEmitter, FSWatcher,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  EventEmitter = require('events').EventEmitter;
	
	  FSWatcher = (function(_super) {
	    __extends(FSWatcher, _super);
	
	    FSWatcher.prototype.listener = null;
	
	    function FSWatcher(listener) {
	      this.listener = listener;
	      FSWatcher.__super__.constructor.apply(this, arguments);
	      this.addListener('change', this.listener);
	    }
	
	    FSWatcher.prototype.close = function() {
	      return this.removeListener('change', this.listener);
	    };
	
	    return FSWatcher;
	
	  })(EventEmitter);
	
	  module.exports = FSWatcher;
	
	}).call(this);
	

}, 'escape-regexp/index.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'escape-regexp/index.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'escape-regexp/index.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'escape-regexp/index.js';
	var __dirname = 'escape-regexp';
	var process = {cwd: function() {return '/';}, argv: ['node', 'escape-regexp/index.js'], env: {}};

	/** code **/
	
	/**
	 * Escape regexp special characters in `str`.
	 *
	 * @param {String} str
	 * @return {String}
	 * @api public
	 */
	
	module.exports = function(str){
	  return String(str).replace(/([.*+?=^!:${}()|[\]\/\\])/g, '\\$1');
	};

}, '/lib/Storage/Async/DevNullStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Async/DevNullStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Async/DevNullStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Async/DevNullStorage.js';
	var __dirname = '/lib/Storage/Async';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Async/DevNullStorage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var DevNullStorage, Storage, _ref,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  Storage = require('./Storage');
	
	  DevNullStorage = (function(_super) {
	    __extends(DevNullStorage, _super);
	
	    function DevNullStorage() {
	      _ref = DevNullStorage.__super__.constructor.apply(this, arguments);
	      return _ref;
	    }
	
	    DevNullStorage.prototype.getData = function(fn) {
	      return fn(null, {});
	    };
	
	    DevNullStorage.prototype.getMeta = function(fn) {
	      return fn(null, {});
	    };
	
	    DevNullStorage.prototype.writeData = function(data, meta, fn) {
	      return fn(null);
	    };
	
	    DevNullStorage.prototype.read = function(key, fn) {
	      return fn(null, null);
	    };
	
	    DevNullStorage.prototype.write = function(key, data, dependencies, fn) {
	      if (dependencies == null) {
	        dependencies = {};
	      }
	      if (Object.prototype.toString.call(dependencies) === '[object Function]') {
	        fn = dependencies;
	        dependencies = {};
	      }
	      return fn(null);
	    };
	
	    DevNullStorage.prototype.remove = function(key, fn) {
	      return fn(null);
	    };
	
	    return DevNullStorage;
	
	  })(Storage);
	
	  module.exports = DevNullStorage;
	
	}).call(this);
	

}, '/lib/Storage/Async/Storage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Async/Storage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Async/Storage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Async/Storage.js';
	var __dirname = '/lib/Storage/Async';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Async/Storage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var BaseStorage, Cache, Storage, async, isWindow, moment, path, _ref,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  isWindow = typeof window === 'undefined' ? false : true;
	
	  if (!isWindow) {
	    path = require('path');
	  }
	
	  BaseStorage = require('../Storage');
	
	  moment = require('moment');
	
	  Cache = require('../../Cache');
	
	  async = require('async');
	
	  Storage = (function(_super) {
	    __extends(Storage, _super);
	
	    function Storage() {
	      _ref = Storage.__super__.constructor.apply(this, arguments);
	      return _ref;
	    }
	
	    Storage.prototype.async = true;
	
	    Storage.prototype.read = function(key, fn) {
	      var _this = this;
	      return this.getData(function(err, data) {
	        if (err) {
	          return fn(err, null);
	        } else if (typeof data[key] === 'undefined') {
	          return fn(null, null);
	        } else {
	          return _this.findMeta(key, function(err, meta) {
	            if (err) {
	              return fn(err, null);
	            } else {
	              return _this.verify(meta, function(err, state) {
	                if (err) {
	                  return fn(err, null);
	                } else if (state) {
	                  return fn(null, data[key]);
	                } else {
	                  return _this.remove(key, function(err) {
	                    if (err) {
	                      return fn(err, null);
	                    } else {
	                      return fn(null, null);
	                    }
	                  });
	                }
	              });
	            }
	          });
	        }
	      });
	    };
	
	    Storage.prototype.write = function(key, data, dependencies, fn) {
	      var _this = this;
	      if (dependencies == null) {
	        dependencies = {};
	      }
	      return this.getData(function(err, all) {
	        if (err) {
	          return fn(err);
	        } else {
	          all[key] = data;
	          return _this.getMeta(function(err, meta) {
	            if (err) {
	              return fn(err);
	            } else {
	              meta[key] = dependencies;
	              return _this.writeData(all, meta, fn);
	            }
	          });
	        }
	      });
	    };
	
	    Storage.prototype.remove = function(key, fn) {
	      var _this = this;
	      return this.getData(function(err, data) {
	        if (err) {
	          return fn(err);
	        } else {
	          return _this.getMeta(function(err, meta) {
	            if (err) {
	              return fn(err);
	            } else {
	              if (typeof data[key] !== 'undefined') {
	                delete data[key];
	                delete meta[key];
	              }
	              return _this.writeData(data, meta, fn);
	            }
	          });
	        }
	      });
	    };
	
	    Storage.prototype.removeAll = function(fn) {
	      return this.writeData({}, {}, fn);
	    };
	
	    Storage.prototype.clean = function(conditions, fn) {
	      var keys, removeKeys, type, typeFn,
	        _this = this;
	      typeFn = Object.prototype.toString;
	      type = typeFn.call(conditions);
	      if (conditions === Cache.ALL) {
	        this.removeAll(fn);
	      } else if (type === '[object Object]') {
	        if (typeof conditions[Cache.TAGS] === 'undefined') {
	          conditions[Cache.TAGS] = [];
	        }
	        if (typeFn(conditions[Cache.TAGS]) === '[object String]') {
	          conditions[Cache.TAGS] = [conditions[Cache.TAGS]];
	        }
	        removeKeys = function(keys) {
	          return async.eachSeries(keys, function(key, cb) {
	            return _this.remove(key, function(err) {
	              return cb(err);
	            });
	          }, function(err) {
	            return fn(err);
	          });
	        };
	        keys = [];
	        async.eachSeries(conditions[Cache.TAGS], function(tag, cb) {
	          return _this.findKeysByTag(tag, function(err, _keys) {
	            keys = keys.concat(_keys);
	            return cb(err);
	          });
	        }, function(err) {
	          if (err) {
	            return fn(err);
	          } else if (typeof conditions[Cache.PRIORITY] === 'undefined') {
	            return removeKeys(keys);
	          } else {
	            return _this.findKeysByPriority(conditions[Cache.PRIORITY], function(err, _keys) {
	              if (err) {
	                return fn(err);
	              } else {
	                keys = keys.concat(_keys);
	                return removeKeys(keys);
	              }
	            });
	          }
	        });
	      } else {
	        fn(null);
	      }
	      return this;
	    };
	
	    Storage.prototype.findMeta = function(key, fn) {
	      return this.getMeta(function(err, meta) {
	        if (err) {
	          return fn(err, null);
	        } else if (typeof meta[key] !== 'undefined') {
	          return fn(null, meta[key]);
	        } else {
	          return fn(null, null);
	        }
	      });
	    };
	
	    Storage.prototype.findKeysByTag = function(tag, fn) {
	      return this.getMeta(function(err, metas) {
	        var key, meta, result;
	        if (err) {
	          return fn(err, null);
	        } else {
	          result = [];
	          for (key in metas) {
	            meta = metas[key];
	            if (typeof meta[Cache.TAGS] !== 'undefined' && meta[Cache.TAGS].indexOf(tag) !== -1) {
	              result.push(key);
	            }
	          }
	          return fn(null, result);
	        }
	      });
	    };
	
	    Storage.prototype.findKeysByPriority = function(priority, fn) {
	      return this.getMeta(function(err, metas) {
	        var key, meta, result;
	        if (err) {
	          return fn(err, null);
	        } else {
	          result = [];
	          for (key in metas) {
	            meta = metas[key];
	            if (typeof meta[Cache.PRIORITY] !== 'undefined' && meta[Cache.PRIORITY] <= priority) {
	              result.push(key);
	            }
	          }
	          return fn(null, result);
	        }
	      });
	    };
	
	    Storage.prototype.verify = function(meta, fn) {
	      var typefn,
	        _this = this;
	      typefn = Object.prototype.toString;
	      if (typefn.call(meta) === '[object Object]') {
	        if (typeof meta[Cache.EXPIRE] !== 'undefined') {
	          if (moment().valueOf() >= meta[Cache.EXPIRE]) {
	            fn(null, false);
	            return null;
	          }
	        }
	        if (typeof meta[Cache.ITEMS] === 'undefined') {
	          meta[Cache.ITEMS] = [];
	        }
	        return async.eachSeries(meta[Cache.ITEMS], function(item, cb) {
	          return _this.findMeta(item, function(err, meta) {
	            if (err) {
	              fn(err, null);
	              return cb(new Error('Fake error'));
	            } else if (meta === null) {
	              fn(null, false);
	              return cb(new Error('Fake error'));
	            } else if (meta !== null) {
	              return _this.verify(meta, function(err, state) {
	                if (err) {
	                  fn(err, null);
	                  return cb(new Error('Fake error'));
	                } else if (state === false) {
	                  fn(null, false);
	                  return cb(new Error('Fake error'));
	                } else {
	                  return cb();
	                }
	              });
	            } else {
	              return cb();
	            }
	          });
	        }, function(err) {
	          var file, files, mtime, time, _ref1, _ref2, _ref3;
	          if (!err) {
	            if (typeof meta[Cache.FILES] === 'undefined') {
	              meta[Cache.FILES] = [];
	            }
	            _this.checkFilesSupport();
	            if (isWindow) {
	              _ref1 = meta[Cache.FILES];
	              for (file in _ref1) {
	                time = _ref1[file];
	                mtime = window.require.getStats(file).mtime;
	                if (mtime === null) {
	                  throw new Error('File stats are disabled in your simq configuration. Can not get stats for ' + file + '.');
	                }
	                if (window.require.getStats(file).mtime.getTime() !== time) {
	                  fn(null, false);
	                  return null;
	                }
	              }
	              return fn(null, true);
	            } else {
	              files = [];
	              _ref2 = meta[Cache.FILES];
	              for (file in _ref2) {
	                time = _ref2[file];
	                _ref3 = meta[Cache.FILES];
	                for (file in _ref3) {
	                  time = _ref3[file];
	                  files.push({
	                    file: file,
	                    time: time
	                  });
	                }
	              }
	              return async.eachSeries(files, function(item, cb) {
	                return Cache.getFs().stat(item.file, function(err, stats) {
	                  if (err) {
	                    return cb(err);
	                  } else {
	                    if ((new Date(stats.mtime)).getTime() !== item.time) {
	                      fn(null, false);
	                      return cb(new Error('Fake error'));
	                    } else {
	                      return cb();
	                    }
	                  }
	                });
	              }, function(err) {
	                if (err && err.message === 'Fake error') {
	
	                } else if (err) {
	                  return fn(err, null);
	                } else {
	                  return fn(null, true);
	                }
	              });
	            }
	          }
	        });
	      } else {
	        return fn(null, true);
	      }
	    };
	
	    Storage.prototype.parseDependencies = function(dependencies, fn) {
	      var file, files, item, mtime, result, time, typefn, _i, _j, _len, _len1, _ref1, _ref2;
	      typefn = Object.prototype.toString;
	      result = {};
	      if (typefn.call(dependencies) === '[object Object]') {
	        if (typeof dependencies[Cache.EXPIRE] !== 'undefined') {
	          switch (typefn.call(dependencies[Cache.EXPIRE])) {
	            case '[object String]':
	              time = moment(dependencies[Cache.EXPIRE], Cache.TIME_FORMAT);
	              break;
	            case '[object Object]':
	              time = moment().add(dependencies[Cache.EXPIRE]);
	              break;
	            default:
	              throw new Error('Expire format is not valid');
	          }
	          result[Cache.EXPIRE] = time.valueOf();
	        }
	        if (typeof dependencies[Cache.ITEMS] !== 'undefined') {
	          result[Cache.ITEMS] = [];
	          _ref1 = dependencies[Cache.ITEMS];
	          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	            item = _ref1[_i];
	            result[Cache.ITEMS].push(this.cache.generateKey(item));
	          }
	        }
	        if (typeof dependencies[Cache.PRIORITY] !== 'undefined') {
	          result[Cache.PRIORITY] = dependencies[Cache.PRIORITY];
	        }
	        if (typeof dependencies[Cache.TAGS] !== 'undefined') {
	          result[Cache.TAGS] = dependencies[Cache.TAGS];
	        }
	        if (typeof dependencies[Cache.FILES] !== 'undefined') {
	          this.checkFilesSupport();
	          files = {};
	          if (isWindow) {
	            _ref2 = dependencies[Cache.FILES];
	            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
	              file = _ref2[_j];
	              mtime = window.require.getStats(file).mtime;
	              if (mtime === null) {
	                throw new Error('File stats are disabled in your simq configuration. Can not get stats for ' + file + '.');
	              }
	              file = window.require.resolve(file);
	              files[file] = mtime.getTime();
	            }
	            result[Cache.FILES] = files;
	            fn(null, result);
	          } else {
	            async.eachSeries(dependencies[Cache.FILES], function(file, cb) {
	              file = path.resolve(file);
	              return Cache.getFs().stat(file, function(err, stats) {
	                if (err) {
	                  return cb(err);
	                } else {
	                  files[file] = (new Date(stats.mtime)).getTime();
	                  return cb();
	                }
	              });
	            }, function(err) {
	              if (err) {
	                return fn(err, null);
	              } else {
	                result[Cache.FILES] = files;
	                return fn(null, result);
	              }
	            });
	          }
	          return result[Cache.FILES] = files;
	        } else {
	          return fn(null, result);
	        }
	      } else {
	        return fn(null, result);
	      }
	    };
	
	    return Storage;
	
	  })(BaseStorage);
	
	  module.exports = Storage;
	
	}).call(this);
	

}, 'async/lib/async.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'async/lib/async.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'async/lib/async.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'async/lib/async.js';
	var __dirname = 'async/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'async/lib/async.js'], env: {}};

	/** code **/
	/*global setImmediate: false, setTimeout: false, console: false */
	(function () {
	
	    var async = {};
	
	    // global on the server, window in the browser
	    var root, previous_async;
	
	    root = this;
	    if (root != null) {
	      previous_async = root.async;
	    }
	
	    async.noConflict = function () {
	        root.async = previous_async;
	        return async;
	    };
	
	    function only_once(fn) {
	        var called = false;
	        return function() {
	            if (called) throw new Error("Callback was already called.");
	            called = true;
	            fn.apply(root, arguments);
	        }
	    }
	
	    //// cross-browser compatiblity functions ////
	
	    var _each = function (arr, iterator) {
	        if (arr.forEach) {
	            return arr.forEach(iterator);
	        }
	        for (var i = 0; i < arr.length; i += 1) {
	            iterator(arr[i], i, arr);
	        }
	    };
	
	    var _map = function (arr, iterator) {
	        if (arr.map) {
	            return arr.map(iterator);
	        }
	        var results = [];
	        _each(arr, function (x, i, a) {
	            results.push(iterator(x, i, a));
	        });
	        return results;
	    };
	
	    var _reduce = function (arr, iterator, memo) {
	        if (arr.reduce) {
	            return arr.reduce(iterator, memo);
	        }
	        _each(arr, function (x, i, a) {
	            memo = iterator(memo, x, i, a);
	        });
	        return memo;
	    };
	
	    var _keys = function (obj) {
	        if (Object.keys) {
	            return Object.keys(obj);
	        }
	        var keys = [];
	        for (var k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                keys.push(k);
	            }
	        }
	        return keys;
	    };
	
	    //// exported async module functions ////
	
	    //// nextTick implementation with browser-compatible fallback ////
	    if (typeof process === 'undefined' || !(process.nextTick)) {
	        if (typeof setImmediate === 'function') {
	            async.nextTick = function (fn) {
	                // not a direct alias for IE10 compatibility
	                setImmediate(fn);
	            };
	            async.setImmediate = async.nextTick;
	        }
	        else {
	            async.nextTick = function (fn) {
	                setTimeout(fn, 0);
	            };
	            async.setImmediate = async.nextTick;
	        }
	    }
	    else {
	        async.nextTick = process.nextTick;
	        if (typeof setImmediate !== 'undefined') {
	            async.setImmediate = setImmediate;
	        }
	        else {
	            async.setImmediate = async.nextTick;
	        }
	    }
	
	    async.each = function (arr, iterator, callback) {
	        callback = callback || function () {};
	        if (!arr.length) {
	            return callback();
	        }
	        var completed = 0;
	        _each(arr, function (x) {
	            iterator(x, only_once(function (err) {
	                if (err) {
	                    callback(err);
	                    callback = function () {};
	                }
	                else {
	                    completed += 1;
	                    if (completed >= arr.length) {
	                        callback(null);
	                    }
	                }
	            }));
	        });
	    };
	    async.forEach = async.each;
	
	    async.eachSeries = function (arr, iterator, callback) {
	        callback = callback || function () {};
	        if (!arr.length) {
	            return callback();
	        }
	        var completed = 0;
	        var iterate = function () {
	            iterator(arr[completed], function (err) {
	                if (err) {
	                    callback(err);
	                    callback = function () {};
	                }
	                else {
	                    completed += 1;
	                    if (completed >= arr.length) {
	                        callback(null);
	                    }
	                    else {
	                        iterate();
	                    }
	                }
	            });
	        };
	        iterate();
	    };
	    async.forEachSeries = async.eachSeries;
	
	    async.eachLimit = function (arr, limit, iterator, callback) {
	        var fn = _eachLimit(limit);
	        fn.apply(null, [arr, iterator, callback]);
	    };
	    async.forEachLimit = async.eachLimit;
	
	    var _eachLimit = function (limit) {
	
	        return function (arr, iterator, callback) {
	            callback = callback || function () {};
	            if (!arr.length || limit <= 0) {
	                return callback();
	            }
	            var completed = 0;
	            var started = 0;
	            var running = 0;
	
	            (function replenish () {
	                if (completed >= arr.length) {
	                    return callback();
	                }
	
	                while (running < limit && started < arr.length) {
	                    started += 1;
	                    running += 1;
	                    iterator(arr[started - 1], function (err) {
	                        if (err) {
	                            callback(err);
	                            callback = function () {};
	                        }
	                        else {
	                            completed += 1;
	                            running -= 1;
	                            if (completed >= arr.length) {
	                                callback();
	                            }
	                            else {
	                                replenish();
	                            }
	                        }
	                    });
	                }
	            })();
	        };
	    };
	
	
	    var doParallel = function (fn) {
	        return function () {
	            var args = Array.prototype.slice.call(arguments);
	            return fn.apply(null, [async.each].concat(args));
	        };
	    };
	    var doParallelLimit = function(limit, fn) {
	        return function () {
	            var args = Array.prototype.slice.call(arguments);
	            return fn.apply(null, [_eachLimit(limit)].concat(args));
	        };
	    };
	    var doSeries = function (fn) {
	        return function () {
	            var args = Array.prototype.slice.call(arguments);
	            return fn.apply(null, [async.eachSeries].concat(args));
	        };
	    };
	
	
	    var _asyncMap = function (eachfn, arr, iterator, callback) {
	        var results = [];
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        eachfn(arr, function (x, callback) {
	            iterator(x.value, function (err, v) {
	                results[x.index] = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, results);
	        });
	    };
	    async.map = doParallel(_asyncMap);
	    async.mapSeries = doSeries(_asyncMap);
	    async.mapLimit = function (arr, limit, iterator, callback) {
	        return _mapLimit(limit)(arr, iterator, callback);
	    };
	
	    var _mapLimit = function(limit) {
	        return doParallelLimit(limit, _asyncMap);
	    };
	
	    // reduce only has a series version, as doing reduce in parallel won't
	    // work in many situations.
	    async.reduce = function (arr, memo, iterator, callback) {
	        async.eachSeries(arr, function (x, callback) {
	            iterator(memo, x, function (err, v) {
	                memo = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, memo);
	        });
	    };
	    // inject alias
	    async.inject = async.reduce;
	    // foldl alias
	    async.foldl = async.reduce;
	
	    async.reduceRight = function (arr, memo, iterator, callback) {
	        var reversed = _map(arr, function (x) {
	            return x;
	        }).reverse();
	        async.reduce(reversed, memo, iterator, callback);
	    };
	    // foldr alias
	    async.foldr = async.reduceRight;
	
	    var _filter = function (eachfn, arr, iterator, callback) {
	        var results = [];
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        eachfn(arr, function (x, callback) {
	            iterator(x.value, function (v) {
	                if (v) {
	                    results.push(x);
	                }
	                callback();
	            });
	        }, function (err) {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    };
	    async.filter = doParallel(_filter);
	    async.filterSeries = doSeries(_filter);
	    // select alias
	    async.select = async.filter;
	    async.selectSeries = async.filterSeries;
	
	    var _reject = function (eachfn, arr, iterator, callback) {
	        var results = [];
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        eachfn(arr, function (x, callback) {
	            iterator(x.value, function (v) {
	                if (!v) {
	                    results.push(x);
	                }
	                callback();
	            });
	        }, function (err) {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    };
	    async.reject = doParallel(_reject);
	    async.rejectSeries = doSeries(_reject);
	
	    var _detect = function (eachfn, arr, iterator, main_callback) {
	        eachfn(arr, function (x, callback) {
	            iterator(x, function (result) {
	                if (result) {
	                    main_callback(x);
	                    main_callback = function () {};
	                }
	                else {
	                    callback();
	                }
	            });
	        }, function (err) {
	            main_callback();
	        });
	    };
	    async.detect = doParallel(_detect);
	    async.detectSeries = doSeries(_detect);
	
	    async.some = function (arr, iterator, main_callback) {
	        async.each(arr, function (x, callback) {
	            iterator(x, function (v) {
	                if (v) {
	                    main_callback(true);
	                    main_callback = function () {};
	                }
	                callback();
	            });
	        }, function (err) {
	            main_callback(false);
	        });
	    };
	    // any alias
	    async.any = async.some;
	
	    async.every = function (arr, iterator, main_callback) {
	        async.each(arr, function (x, callback) {
	            iterator(x, function (v) {
	                if (!v) {
	                    main_callback(false);
	                    main_callback = function () {};
	                }
	                callback();
	            });
	        }, function (err) {
	            main_callback(true);
	        });
	    };
	    // all alias
	    async.all = async.every;
	
	    async.sortBy = function (arr, iterator, callback) {
	        async.map(arr, function (x, callback) {
	            iterator(x, function (err, criteria) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    callback(null, {value: x, criteria: criteria});
	                }
	            });
	        }, function (err, results) {
	            if (err) {
	                return callback(err);
	            }
	            else {
	                var fn = function (left, right) {
	                    var a = left.criteria, b = right.criteria;
	                    return a < b ? -1 : a > b ? 1 : 0;
	                };
	                callback(null, _map(results.sort(fn), function (x) {
	                    return x.value;
	                }));
	            }
	        });
	    };
	
	    async.auto = function (tasks, callback) {
	        callback = callback || function () {};
	        var keys = _keys(tasks);
	        if (!keys.length) {
	            return callback(null);
	        }
	
	        var results = {};
	
	        var listeners = [];
	        var addListener = function (fn) {
	            listeners.unshift(fn);
	        };
	        var removeListener = function (fn) {
	            for (var i = 0; i < listeners.length; i += 1) {
	                if (listeners[i] === fn) {
	                    listeners.splice(i, 1);
	                    return;
	                }
	            }
	        };
	        var taskComplete = function () {
	            _each(listeners.slice(0), function (fn) {
	                fn();
	            });
	        };
	
	        addListener(function () {
	            if (_keys(results).length === keys.length) {
	                callback(null, results);
	                callback = function () {};
	            }
	        });
	
	        _each(keys, function (k) {
	            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
	            var taskCallback = function (err) {
	                var args = Array.prototype.slice.call(arguments, 1);
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                if (err) {
	                    var safeResults = {};
	                    _each(_keys(results), function(rkey) {
	                        safeResults[rkey] = results[rkey];
	                    });
	                    safeResults[k] = args;
	                    callback(err, safeResults);
	                    // stop subsequent errors hitting callback multiple times
	                    callback = function () {};
	                }
	                else {
	                    results[k] = args;
	                    async.setImmediate(taskComplete);
	                }
	            };
	            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
	            var ready = function () {
	                return _reduce(requires, function (a, x) {
	                    return (a && results.hasOwnProperty(x));
	                }, true) && !results.hasOwnProperty(k);
	            };
	            if (ready()) {
	                task[task.length - 1](taskCallback, results);
	            }
	            else {
	                var listener = function () {
	                    if (ready()) {
	                        removeListener(listener);
	                        task[task.length - 1](taskCallback, results);
	                    }
	                };
	                addListener(listener);
	            }
	        });
	    };
	
	    async.waterfall = function (tasks, callback) {
	        callback = callback || function () {};
	        if (tasks.constructor !== Array) {
	          var err = new Error('First argument to waterfall must be an array of functions');
	          return callback(err);
	        }
	        if (!tasks.length) {
	            return callback();
	        }
	        var wrapIterator = function (iterator) {
	            return function (err) {
	                if (err) {
	                    callback.apply(null, arguments);
	                    callback = function () {};
	                }
	                else {
	                    var args = Array.prototype.slice.call(arguments, 1);
	                    var next = iterator.next();
	                    if (next) {
	                        args.push(wrapIterator(next));
	                    }
	                    else {
	                        args.push(callback);
	                    }
	                    async.setImmediate(function () {
	                        iterator.apply(null, args);
	                    });
	                }
	            };
	        };
	        wrapIterator(async.iterator(tasks))();
	    };
	
	    var _parallel = function(eachfn, tasks, callback) {
	        callback = callback || function () {};
	        if (tasks.constructor === Array) {
	            eachfn.map(tasks, function (fn, callback) {
	                if (fn) {
	                    fn(function (err) {
	                        var args = Array.prototype.slice.call(arguments, 1);
	                        if (args.length <= 1) {
	                            args = args[0];
	                        }
	                        callback.call(null, err, args);
	                    });
	                }
	            }, callback);
	        }
	        else {
	            var results = {};
	            eachfn.each(_keys(tasks), function (k, callback) {
	                tasks[k](function (err) {
	                    var args = Array.prototype.slice.call(arguments, 1);
	                    if (args.length <= 1) {
	                        args = args[0];
	                    }
	                    results[k] = args;
	                    callback(err);
	                });
	            }, function (err) {
	                callback(err, results);
	            });
	        }
	    };
	
	    async.parallel = function (tasks, callback) {
	        _parallel({ map: async.map, each: async.each }, tasks, callback);
	    };
	
	    async.parallelLimit = function(tasks, limit, callback) {
	        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
	    };
	
	    async.series = function (tasks, callback) {
	        callback = callback || function () {};
	        if (tasks.constructor === Array) {
	            async.mapSeries(tasks, function (fn, callback) {
	                if (fn) {
	                    fn(function (err) {
	                        var args = Array.prototype.slice.call(arguments, 1);
	                        if (args.length <= 1) {
	                            args = args[0];
	                        }
	                        callback.call(null, err, args);
	                    });
	                }
	            }, callback);
	        }
	        else {
	            var results = {};
	            async.eachSeries(_keys(tasks), function (k, callback) {
	                tasks[k](function (err) {
	                    var args = Array.prototype.slice.call(arguments, 1);
	                    if (args.length <= 1) {
	                        args = args[0];
	                    }
	                    results[k] = args;
	                    callback(err);
	                });
	            }, function (err) {
	                callback(err, results);
	            });
	        }
	    };
	
	    async.iterator = function (tasks) {
	        var makeCallback = function (index) {
	            var fn = function () {
	                if (tasks.length) {
	                    tasks[index].apply(null, arguments);
	                }
	                return fn.next();
	            };
	            fn.next = function () {
	                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
	            };
	            return fn;
	        };
	        return makeCallback(0);
	    };
	
	    async.apply = function (fn) {
	        var args = Array.prototype.slice.call(arguments, 1);
	        return function () {
	            return fn.apply(
	                null, args.concat(Array.prototype.slice.call(arguments))
	            );
	        };
	    };
	
	    var _concat = function (eachfn, arr, fn, callback) {
	        var r = [];
	        eachfn(arr, function (x, cb) {
	            fn(x, function (err, y) {
	                r = r.concat(y || []);
	                cb(err);
	            });
	        }, function (err) {
	            callback(err, r);
	        });
	    };
	    async.concat = doParallel(_concat);
	    async.concatSeries = doSeries(_concat);
	
	    async.whilst = function (test, iterator, callback) {
	        if (test()) {
	            iterator(function (err) {
	                if (err) {
	                    return callback(err);
	                }
	                async.whilst(test, iterator, callback);
	            });
	        }
	        else {
	            callback();
	        }
	    };
	
	    async.doWhilst = function (iterator, test, callback) {
	        iterator(function (err) {
	            if (err) {
	                return callback(err);
	            }
	            if (test()) {
	                async.doWhilst(iterator, test, callback);
	            }
	            else {
	                callback();
	            }
	        });
	    };
	
	    async.until = function (test, iterator, callback) {
	        if (!test()) {
	            iterator(function (err) {
	                if (err) {
	                    return callback(err);
	                }
	                async.until(test, iterator, callback);
	            });
	        }
	        else {
	            callback();
	        }
	    };
	
	    async.doUntil = function (iterator, test, callback) {
	        iterator(function (err) {
	            if (err) {
	                return callback(err);
	            }
	            if (!test()) {
	                async.doUntil(iterator, test, callback);
	            }
	            else {
	                callback();
	            }
	        });
	    };
	
	    async.queue = function (worker, concurrency) {
	        if (concurrency === undefined) {
	            concurrency = 1;
	        }
	        function _insert(q, data, pos, callback) {
	          if(data.constructor !== Array) {
	              data = [data];
	          }
	          _each(data, function(task) {
	              var item = {
	                  data: task,
	                  callback: typeof callback === 'function' ? callback : null
	              };
	
	              if (pos) {
	                q.tasks.unshift(item);
	              } else {
	                q.tasks.push(item);
	              }
	
	              if (q.saturated && q.tasks.length === concurrency) {
	                  q.saturated();
	              }
	              async.setImmediate(q.process);
	          });
	        }
	
	        var workers = 0;
	        var q = {
	            tasks: [],
	            concurrency: concurrency,
	            saturated: null,
	            empty: null,
	            drain: null,
	            push: function (data, callback) {
	              _insert(q, data, false, callback);
	            },
	            unshift: function (data, callback) {
	              _insert(q, data, true, callback);
	            },
	            process: function () {
	                if (workers < q.concurrency && q.tasks.length) {
	                    var task = q.tasks.shift();
	                    if (q.empty && q.tasks.length === 0) {
	                        q.empty();
	                    }
	                    workers += 1;
	                    var next = function () {
	                        workers -= 1;
	                        if (task.callback) {
	                            task.callback.apply(task, arguments);
	                        }
	                        if (q.drain && q.tasks.length + workers === 0) {
	                            q.drain();
	                        }
	                        q.process();
	                    };
	                    var cb = only_once(next);
	                    worker(task.data, cb);
	                }
	            },
	            length: function () {
	                return q.tasks.length;
	            },
	            running: function () {
	                return workers;
	            }
	        };
	        return q;
	    };
	
	    async.cargo = function (worker, payload) {
	        var working     = false,
	            tasks       = [];
	
	        var cargo = {
	            tasks: tasks,
	            payload: payload,
	            saturated: null,
	            empty: null,
	            drain: null,
	            push: function (data, callback) {
	                if(data.constructor !== Array) {
	                    data = [data];
	                }
	                _each(data, function(task) {
	                    tasks.push({
	                        data: task,
	                        callback: typeof callback === 'function' ? callback : null
	                    });
	                    if (cargo.saturated && tasks.length === payload) {
	                        cargo.saturated();
	                    }
	                });
	                async.setImmediate(cargo.process);
	            },
	            process: function process() {
	                if (working) return;
	                if (tasks.length === 0) {
	                    if(cargo.drain) cargo.drain();
	                    return;
	                }
	
	                var ts = typeof payload === 'number'
	                            ? tasks.splice(0, payload)
	                            : tasks.splice(0);
	
	                var ds = _map(ts, function (task) {
	                    return task.data;
	                });
	
	                if(cargo.empty) cargo.empty();
	                working = true;
	                worker(ds, function () {
	                    working = false;
	
	                    var args = arguments;
	                    _each(ts, function (data) {
	                        if (data.callback) {
	                            data.callback.apply(null, args);
	                        }
	                    });
	
	                    process();
	                });
	            },
	            length: function () {
	                return tasks.length;
	            },
	            running: function () {
	                return working;
	            }
	        };
	        return cargo;
	    };
	
	    var _console_fn = function (name) {
	        return function (fn) {
	            var args = Array.prototype.slice.call(arguments, 1);
	            fn.apply(null, args.concat([function (err) {
	                var args = Array.prototype.slice.call(arguments, 1);
	                if (typeof console !== 'undefined') {
	                    if (err) {
	                        if (console.error) {
	                            console.error(err);
	                        }
	                    }
	                    else if (console[name]) {
	                        _each(args, function (x) {
	                            console[name](x);
	                        });
	                    }
	                }
	            }]));
	        };
	    };
	    async.log = _console_fn('log');
	    async.dir = _console_fn('dir');
	    /*async.info = _console_fn('info');
	    async.warn = _console_fn('warn');
	    async.error = _console_fn('error');*/
	
	    async.memoize = function (fn, hasher) {
	        var memo = {};
	        var queues = {};
	        hasher = hasher || function (x) {
	            return x;
	        };
	        var memoized = function () {
	            var args = Array.prototype.slice.call(arguments);
	            var callback = args.pop();
	            var key = hasher.apply(null, args);
	            if (key in memo) {
	                callback.apply(null, memo[key]);
	            }
	            else if (key in queues) {
	                queues[key].push(callback);
	            }
	            else {
	                queues[key] = [callback];
	                fn.apply(null, args.concat([function () {
	                    memo[key] = arguments;
	                    var q = queues[key];
	                    delete queues[key];
	                    for (var i = 0, l = q.length; i < l; i++) {
	                      q[i].apply(null, arguments);
	                    }
	                }]));
	            }
	        };
	        memoized.memo = memo;
	        memoized.unmemoized = fn;
	        return memoized;
	    };
	
	    async.unmemoize = function (fn) {
	      return function () {
	        return (fn.unmemoized || fn).apply(null, arguments);
	      };
	    };
	
	    async.times = function (count, iterator, callback) {
	        var counter = [];
	        for (var i = 0; i < count; i++) {
	            counter.push(i);
	        }
	        return async.map(counter, iterator, callback);
	    };
	
	    async.timesSeries = function (count, iterator, callback) {
	        var counter = [];
	        for (var i = 0; i < count; i++) {
	            counter.push(i);
	        }
	        return async.mapSeries(counter, iterator, callback);
	    };
	
	    async.compose = function (/* functions... */) {
	        var fns = Array.prototype.reverse.call(arguments);
	        return function () {
	            var that = this;
	            var args = Array.prototype.slice.call(arguments);
	            var callback = args.pop();
	            async.reduce(fns, args, function (newargs, fn, cb) {
	                fn.apply(that, newargs.concat([function () {
	                    var err = arguments[0];
	                    var nextargs = Array.prototype.slice.call(arguments, 1);
	                    cb(err, nextargs);
	                }]))
	            },
	            function (err, results) {
	                callback.apply(that, [err].concat(results));
	            });
	        };
	    };
	
	    var _applyEach = function (eachfn, fns /*args...*/) {
	        var go = function () {
	            var that = this;
	            var args = Array.prototype.slice.call(arguments);
	            var callback = args.pop();
	            return eachfn(fns, function (fn, cb) {
	                fn.apply(that, args.concat([cb]));
	            },
	            callback);
	        };
	        if (arguments.length > 2) {
	            var args = Array.prototype.slice.call(arguments, 2);
	            return go.apply(this, args);
	        }
	        else {
	            return go;
	        }
	    };
	    async.applyEach = doParallel(_applyEach);
	    async.applyEachSeries = doSeries(_applyEach);
	
	    async.forever = function (fn, callback) {
	        function next(err) {
	            if (err) {
	                if (callback) {
	                    return callback(err);
	                }
	                throw err;
	            }
	            fn(next);
	        }
	        next();
	    };
	
	    // AMD / RequireJS
	    if (typeof define !== 'undefined' && define.amd) {
	        define([], function () {
	            return async;
	        });
	    }
	    // Node.js
	    else if (typeof module !== 'undefined' && module.exports) {
	        module.exports = async;
	    }
	    // included directly via <script> tag
	    else {
	        root.async = async;
	    }
	
	}());
	

}, '/lib/Storage/Sync/DevNullStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Sync/DevNullStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Sync/DevNullStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Sync/DevNullStorage.js';
	var __dirname = '/lib/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Sync/DevNullStorage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var DevNullStorage, Storage, _ref,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  Storage = require('./Storage');
	
	  DevNullStorage = (function(_super) {
	    __extends(DevNullStorage, _super);
	
	    function DevNullStorage() {
	      _ref = DevNullStorage.__super__.constructor.apply(this, arguments);
	      return _ref;
	    }
	
	    DevNullStorage.prototype.getData = function() {
	      return {};
	    };
	
	    DevNullStorage.prototype.getMeta = function() {
	      return {};
	    };
	
	    DevNullStorage.prototype.writeData = function(data, meta) {};
	
	    DevNullStorage.prototype.read = function(key) {
	      return null;
	    };
	
	    DevNullStorage.prototype.write = function(key, data, dependencies) {
	      if (dependencies == null) {
	        dependencies = {};
	      }
	    };
	
	    DevNullStorage.prototype.remove = function(key) {};
	
	    return DevNullStorage;
	
	  })(Storage);
	
	  module.exports = DevNullStorage;
	
	}).call(this);
	

}, '/lib/Storage/Async/FileStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Async/FileStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Async/FileStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Async/FileStorage.js';
	var __dirname = '/lib/Storage/Async';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Async/FileStorage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Cache, FileStorage, Storage, fs, path,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  Storage = require('./Storage');
	
	  Cache = require('../../Cache');
	
	  fs = null;
	
	  path = null;
	
	  FileStorage = (function(_super) {
	    __extends(FileStorage, _super);
	
	    FileStorage.prototype.directory = null;
	
	    FileStorage.prototype.allData = null;
	
	    FileStorage.prototype.data = null;
	
	    FileStorage.prototype.meta = null;
	
	    function FileStorage(directory) {
	      this.directory = directory;
	      if (typeof window !== 'undefined') {
	        throw new Error('FileStorage: Can not use this storage in browser');
	      }
	      fs = require('fs');
	      path = require('path');
	      this.directory = path.resolve(this.directory);
	      if (!Cache.getFs().existsSync(this.directory)) {
	        throw new Error('FileStorage: directory ' + this.directory + ' does not exists');
	      }
	      if (!Cache.getFs().statSync(this.directory).isDirectory()) {
	        throw new Error('FileStorage: path ' + this.directory + ' must be directory');
	      }
	    }
	
	    FileStorage.prototype.getFileName = function() {
	      return this.directory + '/__' + this.cache.namespace + '.json';
	    };
	
	    FileStorage.prototype.loadData = function(fn) {
	      var file,
	        _this = this;
	      if (this.allData === null) {
	        file = this.getFileName();
	        return Cache.getFs().exists(file, function(exists) {
	          if (exists) {
	            return Cache.getFs().readFile(file, {
	              encoding: 'utf8'
	            }, function(err, data) {
	              if (err) {
	                return fn(err, null);
	              } else {
	                _this.allData = JSON.parse(data);
	                return fn(null, _this.allData);
	              }
	            });
	          } else {
	            _this.allData = {
	              data: {},
	              meta: {}
	            };
	            return fn(null, _this.allData);
	          }
	        });
	      } else {
	        return fn(null, this.allData);
	      }
	    };
	
	    FileStorage.prototype.getData = function(fn) {
	      return this.loadData(function(err, data) {
	        return fn(err, data.data);
	      });
	    };
	
	    FileStorage.prototype.getMeta = function(fn) {
	      return this.loadData(function(err, data) {
	        return fn(err, data.meta);
	      });
	    };
	
	    FileStorage.prototype.writeData = function(data, meta, fn) {
	      var file;
	      this.data = data;
	      this.meta = meta;
	      this.allData = {
	        data: this.data,
	        meta: this.meta
	      };
	      file = this.getFileName();
	      Cache.getFs().writeFile(file, JSON.stringify({
	        data: this.data,
	        meta: this.meta
	      }), function(err) {
	        if (err) {
	          return fn(err);
	        } else {
	          return fn(null);
	        }
	      });
	      return this;
	    };
	
	    return FileStorage;
	
	  })(Storage);
	
	  module.exports = FileStorage;
	
	}).call(this);
	

}, '/lib/Storage/Sync/FileStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Sync/FileStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Sync/FileStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Sync/FileStorage.js';
	var __dirname = '/lib/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Sync/FileStorage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var Cache, FileStorage, Storage, fs, path,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  Storage = require('./Storage');
	
	  Cache = require('../../Cache');
	
	  fs = null;
	
	  path = null;
	
	  FileStorage = (function(_super) {
	    __extends(FileStorage, _super);
	
	    FileStorage.prototype.directory = null;
	
	    FileStorage.prototype.allData = null;
	
	    FileStorage.prototype.data = null;
	
	    FileStorage.prototype.meta = null;
	
	    function FileStorage(directory) {
	      this.directory = directory;
	      if (typeof window !== 'undefined') {
	        throw new Error('FileStorage: Can not use this storage in browser');
	      }
	      fs = require('fs');
	      path = require('path');
	      this.directory = path.resolve(this.directory);
	      if (!Cache.getFs().existsSync(this.directory)) {
	        throw new Error('FileStorage: directory ' + this.directory + ' does not exists');
	      }
	      if (!Cache.getFs().statSync(this.directory).isDirectory()) {
	        throw new Error('FileStorage: path ' + this.directory + ' must be directory');
	      }
	    }
	
	    FileStorage.prototype.getFileName = function() {
	      return this.directory + '/__' + this.cache.namespace + '.json';
	    };
	
	    FileStorage.prototype.loadData = function() {
	      var file;
	      if (this.allData === null) {
	        file = this.getFileName();
	        if (Cache.getFs().existsSync(file)) {
	          this.allData = JSON.parse(Cache.getFs().readFileSync(file, {
	            encoding: 'utf8'
	          }));
	        } else {
	          this.allData = {
	            data: {},
	            meta: {}
	          };
	        }
	      }
	      return this.allData;
	    };
	
	    FileStorage.prototype.getData = function() {
	      if (this.data === null) {
	        this.data = this.loadData().data;
	      }
	      return this.data;
	    };
	
	    FileStorage.prototype.getMeta = function() {
	      if (this.meta === null) {
	        this.meta = this.loadData().meta;
	      }
	      return this.meta;
	    };
	
	    FileStorage.prototype.writeData = function(data, meta) {
	      var file;
	      this.data = data;
	      this.meta = meta;
	      this.allData = {
	        data: this.data,
	        meta: this.meta
	      };
	      file = this.getFileName();
	      return Cache.getFs().writeFileSync(file, JSON.stringify({
	        data: this.data,
	        meta: this.meta
	      }));
	    };
	
	    return FileStorage;
	
	  })(Storage);
	
	  module.exports = FileStorage;
	
	}).call(this);
	

}, '/lib/Storage/Async/MemoryStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Async/MemoryStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Async/MemoryStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Async/MemoryStorage.js';
	var __dirname = '/lib/Storage/Async';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Async/MemoryStorage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var MemoryStorage, Storage, _ref,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  Storage = require('./Storage');
	
	  MemoryStorage = (function(_super) {
	    __extends(MemoryStorage, _super);
	
	    function MemoryStorage() {
	      _ref = MemoryStorage.__super__.constructor.apply(this, arguments);
	      return _ref;
	    }
	
	    MemoryStorage.prototype.data = null;
	
	    MemoryStorage.prototype.meta = null;
	
	    MemoryStorage.prototype.getData = function(fn) {
	      if (this.data === null) {
	        this.data = {};
	      }
	      return fn(null, this.data);
	    };
	
	    MemoryStorage.prototype.getMeta = function(fn) {
	      if (this.meta === null) {
	        this.meta = {};
	      }
	      return fn(null, this.meta);
	    };
	
	    MemoryStorage.prototype.writeData = function(data, meta, fn) {
	      this.data = data;
	      this.meta = meta;
	      return fn(null);
	    };
	
	    return MemoryStorage;
	
	  })(Storage);
	
	  module.exports = MemoryStorage;
	
	}).call(this);
	

}, '/lib/Storage/Sync/MemoryStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Sync/MemoryStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Sync/MemoryStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Sync/MemoryStorage.js';
	var __dirname = '/lib/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Sync/MemoryStorage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var MemoryStorage, Storage, _ref,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  Storage = require('./Storage');
	
	  MemoryStorage = (function(_super) {
	    __extends(MemoryStorage, _super);
	
	    function MemoryStorage() {
	      _ref = MemoryStorage.__super__.constructor.apply(this, arguments);
	      return _ref;
	    }
	
	    MemoryStorage.prototype.data = null;
	
	    MemoryStorage.prototype.meta = null;
	
	    MemoryStorage.prototype.getData = function() {
	      if (this.data === null) {
	        this.data = {};
	      }
	      return this.data;
	    };
	
	    MemoryStorage.prototype.getMeta = function() {
	      if (this.meta === null) {
	        this.meta = {};
	      }
	      return this.meta;
	    };
	
	    MemoryStorage.prototype.writeData = function(data, meta) {
	      this.data = data;
	      this.meta = meta;
	    };
	
	    return MemoryStorage;
	
	  })(Storage);
	
	  module.exports = MemoryStorage;
	
	}).call(this);
	

}, '/lib/Storage/Async/RedisStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/lib/Storage/Async/RedisStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/lib/Storage/Async/RedisStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/lib/Storage/Async/RedisStorage.js';
	var __dirname = '/lib/Storage/Async';
	var process = {cwd: function() {return '/';}, argv: ['node', '/lib/Storage/Async/RedisStorage.js'], env: {}};

	/** code **/
	// Generated by CoffeeScript 1.6.3
	(function() {
	  var RedisStorage, Storage, assert, redis,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  Storage = require('./Storage');
	
	  redis = require('redis');
	
	  assert = require('assert');
	
	  RedisStorage = (function(_super) {
	    __extends(RedisStorage, _super);
	
	    RedisStorage.META_KEY = '__redis__storage__meta__key__';
	
	    RedisStorage.prototype.client = null;
	
	    function RedisStorage() {
	      if (typeof window !== 'undefined') {
	        throw new Error('FileStorage: Can not use this storage in browser');
	      }
	      this.client = redis.createClient();
	    }
	
	    RedisStorage.prototype.selectDatabase = function(database, fn) {
	      return this.client.SELECT(database, fn);
	    };
	
	    RedisStorage.prototype._read = function(name, fn, defaults) {
	      var _this = this;
	      if (defaults == null) {
	        defaults = null;
	      }
	      return this.client.GET(name, function(err, data) {
	        if (err) {
	          return fn(err, null);
	        } else if (data === null) {
	          if (defaults === null) {
	            return fn(null, null);
	          } else {
	            return _this._write(name, defaults, function(err) {
	              if (err) {
	                return fn(err, null);
	              } else {
	                return _this._read(name, function(err, data) {
	                  if (err) {
	                    return fn(err, null);
	                  } else {
	                    return fn(null, data);
	                  }
	                });
	              }
	            });
	          }
	        } else {
	          return fn(null, JSON.parse(data));
	        }
	      });
	    };
	
	    RedisStorage.prototype._write = function(name, data, fn) {
	      return this.client.SET(name, JSON.stringify(data), function(err) {
	        if (err) {
	          return fn(err);
	        } else {
	          return fn(null);
	        }
	      });
	    };
	
	    RedisStorage.prototype._remove = function(name, fn) {
	      return this.client.DEL(name, fn);
	    };
	
	    RedisStorage.prototype._removeAll = function(fn) {
	      return this.client.FLUSHDB(fn);
	    };
	
	    RedisStorage.prototype.getMeta = function(fn) {
	      return this._read(RedisStorage.META_KEY, fn, {});
	    };
	
	    RedisStorage.prototype.read = function(key, fn) {
	      var _this = this;
	      return this._read(key, function(err, data) {
	        if (err) {
	          return fn(err, null);
	        } else if (data === null) {
	          return fn(null, null);
	        } else {
	          return _this.findMeta(key, function(err, meta) {
	            if (err) {
	              return fn(err, null);
	            } else {
	              return _this.verify(meta, function(err, state) {
	                if (err) {
	                  return fn(err, null);
	                } else if (state) {
	                  return fn(null, data);
	                } else {
	                  return _this.remove(key, function() {
	                    return fn(null, null);
	                  });
	                }
	              });
	            }
	          });
	        }
	      });
	    };
	
	    RedisStorage.prototype.write = function(key, data, dependencies, fn) {
	      var _this = this;
	      if (dependencies == null) {
	        dependencies = {};
	      }
	      return this._write(key, data, function(err) {
	        if (err) {
	          return fn(err);
	        } else {
	          return _this.getMeta(function(err, meta) {
	            if (err) {
	              return fn(err);
	            } else {
	              meta[key] = dependencies;
	              return _this._write(RedisStorage.META_KEY, meta, fn);
	            }
	          });
	        }
	      });
	    };
	
	    RedisStorage.prototype.remove = function(key, fn) {
	      var _this = this;
	      return this.getMeta(function(err, meta) {
	        if (err) {
	          return fn(err);
	        } else {
	          if (typeof meta[key] !== 'undefined') {
	            delete meta[key];
	          }
	          return _this._remove(key, function(err) {
	            if (err) {
	              return fn(err);
	            } else {
	              return _this._write(RedisStorage.META_KEY, meta, fn);
	            }
	          });
	        }
	      });
	    };
	
	    RedisStorage.prototype.removeAll = function(fn) {
	      return this._removeAll(fn);
	    };
	
	    return RedisStorage;
	
	  })(Storage);
	
	  module.exports = RedisStorage;
	
	}).call(this);
	

}, 'redis/index.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'redis/index.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'redis/index.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'redis/index.js';
	var __dirname = 'redis';
	var process = {cwd: function() {return '/';}, argv: ['node', 'redis/index.js'], env: {}};

	/** code **/
	/*global Buffer require exports console setTimeout */
	
	var net = require("net"),
	    util = require("./lib/util"),
	    Queue = require("./lib/queue"),
	    to_array = require("./lib/to_array"),
	    events = require("events"),
	    crypto = require("crypto"),
	    parsers = [], commands,
	    connection_id = 0,
	    default_port = 6379,
	    default_host = "127.0.0.1";
	
	// can set this to true to enable for all connections
	exports.debug_mode = false;
	
	var arraySlice = Array.prototype.slice
	function trace() {
	    if (!exports.debug_mode) return;
	    console.log.apply(null, arraySlice.call(arguments))
	}
	
	// hiredis might not be installed
	try {
	    require("./lib/parser/hiredis");
	    parsers.push(require("./lib/parser/hiredis"));
	} catch (err) {
	    if (exports.debug_mode) {
	        console.warn("hiredis parser not installed.");
	    }
	}
	
	parsers.push(require("./lib/parser/javascript"));
	
	function RedisClient(stream, options) {
	    this.stream = stream;
	    this.options = options = options || {};
	
	    this.connection_id = ++connection_id;
	    this.connected = false;
	    this.ready = false;
	    this.connections = 0;
	    if (this.options.socket_nodelay === undefined) {
	        this.options.socket_nodelay = true;
	    }
	    this.should_buffer = false;
	    this.command_queue_high_water = this.options.command_queue_high_water || 1000;
	    this.command_queue_low_water = this.options.command_queue_low_water || 0;
	    this.max_attempts = null;
	    if (options.max_attempts && !isNaN(options.max_attempts) && options.max_attempts > 0) {
	        this.max_attempts = +options.max_attempts;
	    }
	    this.command_queue = new Queue(); // holds sent commands to de-pipeline them
	    this.offline_queue = new Queue(); // holds commands issued but not able to be sent
	    this.commands_sent = 0;
	    this.connect_timeout = false;
	    if (options.connect_timeout && !isNaN(options.connect_timeout) && options.connect_timeout > 0) {
	        this.connect_timeout = +options.connect_timeout;
	    }
	    this.enable_offline_queue = true;
	    if (typeof this.options.enable_offline_queue === "boolean") {
	        this.enable_offline_queue = this.options.enable_offline_queue;
	    }
	    this.retry_max_delay = null;
	    if (options.retry_max_delay !== undefined && !isNaN(options.retry_max_delay) && options.retry_max_delay > 0) {
	        this.retry_max_delay = options.retry_max_delay;
	    }
	
	    this.initialize_retry_vars();
	    this.pub_sub_mode = false;
	    this.subscription_set = {};
	    this.monitoring = false;
	    this.closing = false;
	    this.server_info = {};
	    this.auth_pass = null;
	    if (options.auth_pass !== undefined) {
	        this.auth_pass = options.auth_pass;
	    }
	    this.parser_module = null;
	    this.selected_db = null;	// save the selected db here, used when reconnecting
	
	    this.old_state = null;
	
	    var self = this;
	
	    this.stream.on("connect", function () {
	        self.on_connect();
	    });
	
	    this.stream.on("data", function (buffer_from_socket) {
	        self.on_data(buffer_from_socket);
	    });
	
	    this.stream.on("error", function (msg) {
	        self.on_error(msg.message);
	    });
	
	    this.stream.on("close", function () {
	        self.connection_gone("close");
	    });
	
	    this.stream.on("end", function () {
	        self.connection_gone("end");
	    });
	
	    this.stream.on("drain", function () {
	        self.should_buffer = false;
	        self.emit("drain");
	    });
	
	    events.EventEmitter.call(this);
	}
	util.inherits(RedisClient, events.EventEmitter);
	exports.RedisClient = RedisClient;
	
	RedisClient.prototype.initialize_retry_vars = function () {
	    this.retry_timer = null;
	    this.retry_totaltime = 0;
	    this.retry_delay = 150;
	    this.retry_backoff = 1.7;
	    this.attempts = 1;
	};
	
	RedisClient.prototype.unref = function () {
	    trace("User requesting to unref the connection");
	    if (this.connected) {
	        trace("unref'ing the socket connection");
	        this.stream.unref();
	    }
	    else {
	        trace("Not connected yet, will unref later");
	        this.once("connect", function () {
	            this.unref();
	        })
	    }
	};
	
	// flush offline_queue and command_queue, erroring any items with a callback first
	RedisClient.prototype.flush_and_error = function (message) {
	    var command_obj, error;
	
	    error = new Error(message);
	
	    while (this.offline_queue.length > 0) {
	        command_obj = this.offline_queue.shift();
	        if (typeof command_obj.callback === "function") {
	            try {
	                command_obj.callback(error);
	            } catch (callback_err) {
	                this.emit("error", callback_err);
	            }
	        }
	    }
	    this.offline_queue = new Queue();
	
	    while (this.command_queue.length > 0) {
	        command_obj = this.command_queue.shift();
	        if (typeof command_obj.callback === "function") {
	            try {
	                command_obj.callback(error);
	            } catch (callback_err) {
	                this.emit("error", callback_err);
	            }
	        }
	    }
	    this.command_queue = new Queue();
	};
	
	RedisClient.prototype.on_error = function (msg) {
	    var message = "Redis connection to " + this.host + ":" + this.port + " failed - " + msg;
	
	    if (this.closing) {
	        return;
	    }
	
	    if (exports.debug_mode) {
	        console.warn(message);
	    }
	
	    this.flush_and_error(message);
	
	    this.connected = false;
	    this.ready = false;
	
	    this.emit("error", new Error(message));
	    // "error" events get turned into exceptions if they aren't listened for.  If the user handled this error
	    // then we should try to reconnect.
	    this.connection_gone("error");
	};
	
	RedisClient.prototype.do_auth = function () {
	    var self = this;
	
	    if (exports.debug_mode) {
	        console.log("Sending auth to " + self.host + ":" + self.port + " id " + self.connection_id);
	    }
	    self.send_anyway = true;
	    self.send_command("auth", [this.auth_pass], function (err, res) {
	        if (err) {
	            if (err.toString().match("LOADING")) {
	                // if redis is still loading the db, it will not authenticate and everything else will fail
	                console.log("Redis still loading, trying to authenticate later");
	                setTimeout(function () {
	                    self.do_auth();
	                }, 2000); // TODO - magic number alert
	                return;
	            } else if (err.toString().match("no password is set")) {
	                console.log("Warning: Redis server does not require a password, but a password was supplied.")
	                err = null;
	                res = "OK";
	            } else {
	                return self.emit("error", new Error("Auth error: " + err.message));
	            }
	        }
	        if (res.toString() !== "OK") {
	            return self.emit("error", new Error("Auth failed: " + res.toString()));
	        }
	        if (exports.debug_mode) {
	            console.log("Auth succeeded " + self.host + ":" + self.port + " id " + self.connection_id);
	        }
	        if (self.auth_callback) {
	            self.auth_callback(err, res);
	            self.auth_callback = null;
	        }
	
	        // now we are really connected
	        self.emit("connect");
	        self.initialize_retry_vars();
	
	        if (self.options.no_ready_check) {
	            self.on_ready();
	        } else {
	            self.ready_check();
	        }
	    });
	    self.send_anyway = false;
	};
	
	RedisClient.prototype.on_connect = function () {
	    if (exports.debug_mode) {
	        console.log("Stream connected " + this.host + ":" + this.port + " id " + this.connection_id);
	    }
	
	    this.connected = true;
	    this.ready = false;
	    this.connections += 1;
	    this.command_queue = new Queue();
	    this.emitted_end = false;
	    if (this.options.socket_nodelay) {
	        this.stream.setNoDelay();
	    }
	    this.stream.setTimeout(0);
	
	    this.init_parser();
	
	    if (this.auth_pass) {
	        this.do_auth();
	    } else {
	        this.emit("connect");
	        this.initialize_retry_vars();
	
	        if (this.options.no_ready_check) {
	            this.on_ready();
	        } else {
	            this.ready_check();
	        }
	    }
	};
	
	RedisClient.prototype.init_parser = function () {
	    var self = this;
	
	    if (this.options.parser) {
	        if (! parsers.some(function (parser) {
	            if (parser.name === self.options.parser) {
	                self.parser_module = parser;
	                if (exports.debug_mode) {
	                    console.log("Using parser module: " + self.parser_module.name);
	                }
	                return true;
	            }
	        })) {
	            throw new Error("Couldn't find named parser " + self.options.parser + " on this system");
	        }
	    } else {
	        if (exports.debug_mode) {
	            console.log("Using default parser module: " + parsers[0].name);
	        }
	        this.parser_module = parsers[0];
	    }
	
	    this.parser_module.debug_mode = exports.debug_mode;
	
	    // return_buffers sends back Buffers from parser to callback. detect_buffers sends back Buffers from parser, but
	    // converts to Strings if the input arguments are not Buffers.
	    this.reply_parser = new this.parser_module.Parser({
	        return_buffers: self.options.return_buffers || self.options.detect_buffers || false
	    });
	
	    // "reply error" is an error sent back by Redis
	    this.reply_parser.on("reply error", function (reply) {
	        if (reply instanceof Error) {
	            self.return_error(reply);
	        } else {
	            self.return_error(new Error(reply));
	        }
	    });
	    this.reply_parser.on("reply", function (reply) {
	        self.return_reply(reply);
	    });
	    // "error" is bad.  Somehow the parser got confused.  It'll try to reset and continue.
	    this.reply_parser.on("error", function (err) {
	        self.emit("error", new Error("Redis reply parser error: " + err.stack));
	    });
	};
	
	RedisClient.prototype.on_ready = function () {
	    var self = this;
	
	    this.ready = true;
	
	    if (this.old_state !== null) {
	        this.monitoring = this.old_state.monitoring;
	        this.pub_sub_mode = this.old_state.pub_sub_mode;
	        this.selected_db = this.old_state.selected_db;
	        this.old_state = null;
	    }
	
	    // magically restore any modal commands from a previous connection
	    if (this.selected_db !== null) {
	        // this trick works if and only if the following send_command
	        // never goes into the offline queue
	        var pub_sub_mode = this.pub_sub_mode;
	        this.pub_sub_mode = false;
	        this.send_command('select', [this.selected_db]);
	        this.pub_sub_mode = pub_sub_mode;
	    }
	    if (this.pub_sub_mode === true) {
	        // only emit "ready" when all subscriptions were made again
	        var callback_count = 0;
	        var callback = function () {
	            callback_count--;
	            if (callback_count === 0) {
	                self.emit("ready");
	            }
	        };
	        Object.keys(this.subscription_set).forEach(function (key) {
	            var parts = key.split(" ");
	            if (exports.debug_mode) {
	                console.warn("sending pub/sub on_ready " + parts[0] + ", " + parts[1]);
	            }
	            callback_count++;
	            self.send_command(parts[0] + "scribe", [parts[1]], callback);
	        });
	        return;
	    } else if (this.monitoring) {
	        this.send_command("monitor");
	    } else {
	        this.send_offline_queue();
	    }
	    this.emit("ready");
	};
	
	RedisClient.prototype.on_info_cmd = function (err, res) {
	    var self = this, obj = {}, lines, retry_time;
	
	    if (err) {
	        return self.emit("error", new Error("Ready check failed: " + err.message));
	    }
	
	    lines = res.toString().split("\r\n");
	
	    lines.forEach(function (line) {
	        var parts = line.split(':');
	        if (parts[1]) {
	            obj[parts[0]] = parts[1];
	        }
	    });
	
	    obj.versions = [];
	    obj.redis_version.split('.').forEach(function (num) {
	        obj.versions.push(+num);
	    });
	
	    // expose info key/vals to users
	    this.server_info = obj;
	
	    if (!obj.loading || (obj.loading && obj.loading === "0")) {
	        if (exports.debug_mode) {
	            console.log("Redis server ready.");
	        }
	        this.on_ready();
	    } else {
	        retry_time = obj.loading_eta_seconds * 1000;
	        if (retry_time > 1000) {
	            retry_time = 1000;
	        }
	        if (exports.debug_mode) {
	            console.log("Redis server still loading, trying again in " + retry_time);
	        }
	        setTimeout(function () {
	            self.ready_check();
	        }, retry_time);
	    }
	};
	
	RedisClient.prototype.ready_check = function () {
	    var self = this;
	
	    if (exports.debug_mode) {
	        console.log("checking server ready state...");
	    }
	
	    this.send_anyway = true;  // secret flag to send_command to send something even if not "ready"
	    this.info(function (err, res) {
	        self.on_info_cmd(err, res);
	    });
	    this.send_anyway = false;
	};
	
	RedisClient.prototype.send_offline_queue = function () {
	    var command_obj, buffered_writes = 0;
	
	    while (this.offline_queue.length > 0) {
	        command_obj = this.offline_queue.shift();
	        if (exports.debug_mode) {
	            console.log("Sending offline command: " + command_obj.command);
	        }
	        buffered_writes += !this.send_command(command_obj.command, command_obj.args, command_obj.callback);
	    }
	    this.offline_queue = new Queue();
	    // Even though items were shifted off, Queue backing store still uses memory until next add, so just get a new Queue
	
	    if (!buffered_writes) {
	        this.should_buffer = false;
	        this.emit("drain");
	    }
	};
	
	RedisClient.prototype.connection_gone = function (why) {
	    var self = this;
	
	    // If a retry is already in progress, just let that happen
	    if (this.retry_timer) {
	        return;
	    }
	
	    if (exports.debug_mode) {
	        console.warn("Redis connection is gone from " + why + " event.");
	    }
	    this.connected = false;
	    this.ready = false;
	
	    if (this.old_state === null) {
	        var state = {
	            monitoring: this.monitoring,
	            pub_sub_mode: this.pub_sub_mode,
	            selected_db: this.selected_db
	        };
	        this.old_state = state;
	        this.monitoring = false;
	        this.pub_sub_mode = false;
	        this.selected_db = null;
	    }
	
	    // since we are collapsing end and close, users don't expect to be called twice
	    if (! this.emitted_end) {
	        this.emit("end");
	        this.emitted_end = true;
	    }
	
	    this.flush_and_error("Redis connection gone from " + why + " event.");
	
	    // If this is a requested shutdown, then don't retry
	    if (this.closing) {
	        this.retry_timer = null;
	        if (exports.debug_mode) {
	            console.warn("connection ended from quit command, not retrying.");
	        }
	        return;
	    }
	
	    var nextDelay = Math.floor(this.retry_delay * this.retry_backoff);
	    if (this.retry_max_delay !== null && nextDelay > this.retry_max_delay) {
	        this.retry_delay = this.retry_max_delay;
	    } else {
	        this.retry_delay = nextDelay;
	    }
	
	    if (exports.debug_mode) {
	        console.log("Retry connection in " + this.retry_delay + " ms");
	    }
	
	    if (this.max_attempts && this.attempts >= this.max_attempts) {
	        this.retry_timer = null;
	        // TODO - some people need a "Redis is Broken mode" for future commands that errors immediately, and others
	        // want the program to exit.  Right now, we just log, which doesn't really help in either case.
	        console.error("node_redis: Couldn't get Redis connection after " + this.max_attempts + " attempts.");
	        return;
	    }
	
	    this.attempts += 1;
	    this.emit("reconnecting", {
	        delay: self.retry_delay,
	        attempt: self.attempts
	    });
	    this.retry_timer = setTimeout(function () {
	        if (exports.debug_mode) {
	            console.log("Retrying connection...");
	        }
	
	        self.retry_totaltime += self.retry_delay;
	
	        if (self.connect_timeout && self.retry_totaltime >= self.connect_timeout) {
	            self.retry_timer = null;
	            // TODO - engage Redis is Broken mode for future commands, or whatever
	            console.error("node_redis: Couldn't get Redis connection after " + self.retry_totaltime + "ms.");
	            return;
	        }
	
	        self.stream.connect(self.port, self.host);
	        self.retry_timer = null;
	    }, this.retry_delay);
	};
	
	RedisClient.prototype.on_data = function (data) {
	    if (exports.debug_mode) {
	        console.log("net read " + this.host + ":" + this.port + " id " + this.connection_id + ": " + data.toString());
	    }
	
	    try {
	        this.reply_parser.execute(data);
	    } catch (err) {
	        // This is an unexpected parser problem, an exception that came from the parser code itself.
	        // Parser should emit "error" events if it notices things are out of whack.
	        // Callbacks that throw exceptions will land in return_reply(), below.
	        // TODO - it might be nice to have a different "error" event for different types of errors
	        this.emit("error", err);
	    }
	};
	
	RedisClient.prototype.return_error = function (err) {
	    var command_obj = this.command_queue.shift(), queue_len = this.command_queue.getLength();
	
	    if (this.pub_sub_mode === false && queue_len === 0) {
	        this.command_queue = new Queue();
	        this.emit("idle");
	    }
	    if (this.should_buffer && queue_len <= this.command_queue_low_water) {
	        this.emit("drain");
	        this.should_buffer = false;
	    }
	
	    if (command_obj && typeof command_obj.callback === "function") {
	        try {
	            command_obj.callback(err);
	        } catch (callback_err) {
	            this.emit("error", callback_err);
	        }
	    } else {
	        console.log("node_redis: no callback to send error: " + err.message);
	        this.emit("error", err);
	    }
	};
	
	// if a callback throws an exception, re-throw it on a new stack so the parser can keep going.
	// if a domain is active, emit the error on the domain, which will serve the same function.
	// put this try/catch in its own function because V8 doesn't optimize this well yet.
	function try_callback(client, callback, reply) {
	    try {
	        callback(null, reply);
	    } catch (err) {
	        if (process.domain) {
	            process.domain.emit('error', err);
	            process.domain.exit();
	        } else {
	            client.emit("error", err);
	        }
	    }
	}
	
	// hgetall converts its replies to an Object.  If the reply is empty, null is returned.
	function reply_to_object(reply) {
	    var obj = {}, j, jl, key, val;
	
	    if (reply.length === 0) {
	        return null;
	    }
	
	    for (j = 0, jl = reply.length; j < jl; j += 2) {
	        key = reply[j].toString();
	        val = reply[j + 1];
	        obj[key] = val;
	    }
	
	    return obj;
	}
	
	function reply_to_strings(reply) {
	    var i;
	
	    if (Buffer.isBuffer(reply)) {
	        return reply.toString();
	    }
	
	    if (Array.isArray(reply)) {
	        for (i = 0; i < reply.length; i++) {
	            if (reply[i] !== null && reply[i] !== undefined) {
	                reply[i] = reply[i].toString();
	            }
	        }
	        return reply;
	    }
	
	    return reply;
	}
	
	RedisClient.prototype.return_reply = function (reply) {
	    var command_obj, len, type, timestamp, argindex, args, queue_len;
	
	    // If the "reply" here is actually a message received asynchronously due to a
	    // pubsub subscription, don't pop the command queue as we'll only be consuming
	    // the head command prematurely.
	    if (Array.isArray(reply) && reply.length > 0 && reply[0]) {
	        type = reply[0].toString();
	    }
	
	    if (this.pub_sub_mode && (type == 'message' || type == 'pmessage')) {
	        trace("received pubsub message");
	    }
	    else {
	        command_obj = this.command_queue.shift();
	    }
	
	    queue_len = this.command_queue.getLength();
	
	    if (this.pub_sub_mode === false && queue_len === 0) {
	        this.command_queue = new Queue();  // explicitly reclaim storage from old Queue
	        this.emit("idle");
	    }
	    if (this.should_buffer && queue_len <= this.command_queue_low_water) {
	        this.emit("drain");
	        this.should_buffer = false;
	    }
	
	    if (command_obj && !command_obj.sub_command) {
	        if (typeof command_obj.callback === "function") {
	            if (this.options.detect_buffers && command_obj.buffer_args === false) {
	                // If detect_buffers option was specified, then the reply from the parser will be Buffers.
	                // If this command did not use Buffer arguments, then convert the reply to Strings here.
	                reply = reply_to_strings(reply);
	            }
	
	            // TODO - confusing and error-prone that hgetall is special cased in two places
	            if (reply && 'hgetall' === command_obj.command.toLowerCase()) {
	                reply = reply_to_object(reply);
	            }
	
	            try_callback(this, command_obj.callback, reply);
	        } else if (exports.debug_mode) {
	            console.log("no callback for reply: " + (reply && reply.toString && reply.toString()));
	        }
	    } else if (this.pub_sub_mode || (command_obj && command_obj.sub_command)) {
	        if (Array.isArray(reply)) {
	            type = reply[0].toString();
	
	            if (type === "message") {
	                this.emit("message", reply[1].toString(), reply[2]); // channel, message
	            } else if (type === "pmessage") {
	                this.emit("pmessage", reply[1].toString(), reply[2].toString(), reply[3]); // pattern, channel, message
	            } else if (type === "subscribe" || type === "unsubscribe" || type === "psubscribe" || type === "punsubscribe") {
	                if (reply[2] === 0) {
	                    this.pub_sub_mode = false;
	                    if (this.debug_mode) {
	                        console.log("All subscriptions removed, exiting pub/sub mode");
	                    }
	                } else {
	                    this.pub_sub_mode = true;
	                }
	                // subscribe commands take an optional callback and also emit an event, but only the first response is included in the callback
	                // TODO - document this or fix it so it works in a more obvious way
	                // reply[1] can be null
	                var reply1String = (reply[1] === null) ? null : reply[1].toString();
	                if (command_obj && typeof command_obj.callback === "function") {
	                    try_callback(this, command_obj.callback, reply1String);
	                }
	                this.emit(type, reply1String, reply[2]); // channel, count
	            } else {
	                throw new Error("subscriptions are active but got unknown reply type " + type);
	            }
	        } else if (! this.closing) {
	            throw new Error("subscriptions are active but got an invalid reply: " + reply);
	        }
	    } else if (this.monitoring) {
	        len = reply.indexOf(" ");
	        timestamp = reply.slice(0, len);
	        argindex = reply.indexOf('"');
	        args = reply.slice(argindex + 1, -1).split('" "').map(function (elem) {
	            return elem.replace(/\\"/g, '"');
	        });
	        this.emit("monitor", timestamp, args);
	    } else {
	        throw new Error("node_redis command queue state error. If you can reproduce this, please report it.");
	    }
	};
	
	// This Command constructor is ever so slightly faster than using an object literal, but more importantly, using
	// a named constructor helps it show up meaningfully in the V8 CPU profiler and in heap snapshots.
	function Command(command, args, sub_command, buffer_args, callback) {
	    this.command = command;
	    this.args = args;
	    this.sub_command = sub_command;
	    this.buffer_args = buffer_args;
	    this.callback = callback;
	}
	
	RedisClient.prototype.send_command = function (command, args, callback) {
	    var arg, command_obj, i, il, elem_count, buffer_args, stream = this.stream, command_str = "", buffered_writes = 0, last_arg_type, lcaseCommand;
	
	    if (typeof command !== "string") {
	        throw new Error("First argument to send_command must be the command name string, not " + typeof command);
	    }
	
	    if (Array.isArray(args)) {
	        if (typeof callback === "function") {
	            // probably the fastest way:
	            //     client.command([arg1, arg2], cb);  (straight passthrough)
	            //         send_command(command, [arg1, arg2], cb);
	        } else if (! callback) {
	            // most people find this variable argument length form more convenient, but it uses arguments, which is slower
	            //     client.command(arg1, arg2, cb);   (wraps up arguments into an array)
	            //       send_command(command, [arg1, arg2, cb]);
	            //     client.command(arg1, arg2);   (callback is optional)
	            //       send_command(command, [arg1, arg2]);
	            //     client.command(arg1, arg2, undefined);   (callback is undefined)
	            //       send_command(command, [arg1, arg2, undefined]);
	            last_arg_type = typeof args[args.length - 1];
	            if (last_arg_type === "function" || last_arg_type === "undefined") {
	                callback = args.pop();
	            }
	        } else {
	            throw new Error("send_command: last argument must be a callback or undefined");
	        }
	    } else {
	        throw new Error("send_command: second argument must be an array");
	    }
	
	    if (callback && process.domain) callback = process.domain.bind(callback);
	
	    // if the last argument is an array and command is sadd or srem, expand it out:
	    //     client.sadd(arg1, [arg2, arg3, arg4], cb);
	    //  converts to:
	    //     client.sadd(arg1, arg2, arg3, arg4, cb);
	    lcaseCommand = command.toLowerCase();
	    if ((lcaseCommand === 'sadd' || lcaseCommand === 'srem') && args.length > 0 && Array.isArray(args[args.length - 1])) {
	        args = args.slice(0, -1).concat(args[args.length - 1]);
	    }
	
	    // if the value is undefined or null and command is set or setx, need not to send message to redis
	    if (command === 'set' || command === 'setex') {
	        if(args[args.length - 1] === undefined || args[args.length - 1] === null) {
	            var err = new Error('send_command: ' + command + ' value must not be undefined or null');
	            return callback && callback(err);
	        }
	    }
	
	    buffer_args = false;
	    for (i = 0, il = args.length, arg; i < il; i += 1) {
	        if (Buffer.isBuffer(args[i])) {
	            buffer_args = true;
	        }
	    }
	
	    command_obj = new Command(command, args, false, buffer_args, callback);
	
	    if ((!this.ready && !this.send_anyway) || !stream.writable) {
	        if (exports.debug_mode) {
	            if (!stream.writable) {
	                console.log("send command: stream is not writeable.");
	            }
	        }
	
	        if (this.enable_offline_queue) {
	            if (exports.debug_mode) {
	                console.log("Queueing " + command + " for next server connection.");
	            }
	            this.offline_queue.push(command_obj);
	            this.should_buffer = true;
	        } else {
	            var not_writeable_error = new Error('send_command: stream not writeable. enable_offline_queue is false');
	            if (command_obj.callback) {
	                command_obj.callback(not_writeable_error);
	            } else {
	                throw not_writeable_error;
	            }
	        }
	
	        return false;
	    }
	
	    if (command === "subscribe" || command === "psubscribe" || command === "unsubscribe" || command === "punsubscribe") {
	        this.pub_sub_command(command_obj);
	    } else if (command === "monitor") {
	        this.monitoring = true;
	    } else if (command === "quit") {
	        this.closing = true;
	    } else if (this.pub_sub_mode === true) {
	        throw new Error("Connection in subscriber mode, only subscriber commands may be used");
	    }
	    this.command_queue.push(command_obj);
	    this.commands_sent += 1;
	
	    elem_count = args.length + 1;
	
	    // Always use "Multi bulk commands", but if passed any Buffer args, then do multiple writes, one for each arg.
	    // This means that using Buffers in commands is going to be slower, so use Strings if you don't already have a Buffer.
	
	    command_str = "*" + elem_count + "\r\n$" + command.length + "\r\n" + command + "\r\n";
	
	    if (! buffer_args) { // Build up a string and send entire command in one write
	        for (i = 0, il = args.length, arg; i < il; i += 1) {
	            arg = args[i];
	            if (typeof arg !== "string") {
	                arg = String(arg);
	            }
	            command_str += "$" + Buffer.byteLength(arg) + "\r\n" + arg + "\r\n";
	        }
	        if (exports.debug_mode) {
	            console.log("send " + this.host + ":" + this.port + " id " + this.connection_id + ": " + command_str);
	        }
	        buffered_writes += !stream.write(command_str);
	    } else {
	        if (exports.debug_mode) {
	            console.log("send command (" + command_str + ") has Buffer arguments");
	        }
	        buffered_writes += !stream.write(command_str);
	
	        for (i = 0, il = args.length, arg; i < il; i += 1) {
	            arg = args[i];
	            if (!(Buffer.isBuffer(arg) || arg instanceof String)) {
	                arg = String(arg);
	            }
	
	            if (Buffer.isBuffer(arg)) {
	                if (arg.length === 0) {
	                    if (exports.debug_mode) {
	                        console.log("send_command: using empty string for 0 length buffer");
	                    }
	                    buffered_writes += !stream.write("$0\r\n\r\n");
	                } else {
	                    buffered_writes += !stream.write("$" + arg.length + "\r\n");
	                    buffered_writes += !stream.write(arg);
	                    buffered_writes += !stream.write("\r\n");
	                    if (exports.debug_mode) {
	                        console.log("send_command: buffer send " + arg.length + " bytes");
	                    }
	                }
	            } else {
	                if (exports.debug_mode) {
	                    console.log("send_command: string send " + Buffer.byteLength(arg) + " bytes: " + arg);
	                }
	                buffered_writes += !stream.write("$" + Buffer.byteLength(arg) + "\r\n" + arg + "\r\n");
	            }
	        }
	    }
	    if (exports.debug_mode) {
	        console.log("send_command buffered_writes: " + buffered_writes, " should_buffer: " + this.should_buffer);
	    }
	    if (buffered_writes || this.command_queue.getLength() >= this.command_queue_high_water) {
	        this.should_buffer = true;
	    }
	    return !this.should_buffer;
	};
	
	RedisClient.prototype.pub_sub_command = function (command_obj) {
	    var i, key, command, args;
	
	    if (this.pub_sub_mode === false && exports.debug_mode) {
	        console.log("Entering pub/sub mode from " + command_obj.command);
	    }
	    this.pub_sub_mode = true;
	    command_obj.sub_command = true;
	
	    command = command_obj.command;
	    args = command_obj.args;
	    if (command === "subscribe" || command === "psubscribe") {
	        if (command === "subscribe") {
	            key = "sub";
	        } else {
	            key = "psub";
	        }
	        for (i = 0; i < args.length; i++) {
	            this.subscription_set[key + " " + args[i]] = true;
	        }
	    } else {
	        if (command === "unsubscribe") {
	            key = "sub";
	        } else {
	            key = "psub";
	        }
	        for (i = 0; i < args.length; i++) {
	            delete this.subscription_set[key + " " + args[i]];
	        }
	    }
	};
	
	RedisClient.prototype.end = function () {
	    this.stream._events = {};
	    this.connected = false;
	    this.ready = false;
	    this.closing = true;
	    return this.stream.destroySoon();
	};
	
	function Multi(client, args) {
	    this._client = client;
	    this.queue = [["MULTI"]];
	    if (Array.isArray(args)) {
	        this.queue = this.queue.concat(args);
	    }
	}
	
	exports.Multi = Multi;
	
	// take 2 arrays and return the union of their elements
	function set_union(seta, setb) {
	    var obj = {};
	
	    seta.forEach(function (val) {
	        obj[val] = true;
	    });
	    setb.forEach(function (val) {
	        obj[val] = true;
	    });
	    return Object.keys(obj);
	}
	
	// This static list of commands is updated from time to time.  ./lib/commands.js can be updated with generate_commands.js
	commands = set_union(["get", "set", "setnx", "setex", "append", "strlen", "del", "exists", "setbit", "getbit", "setrange", "getrange", "substr",
	    "incr", "decr", "mget", "rpush", "lpush", "rpushx", "lpushx", "linsert", "rpop", "lpop", "brpop", "brpoplpush", "blpop", "llen", "lindex",
	    "lset", "lrange", "ltrim", "lrem", "rpoplpush", "sadd", "srem", "smove", "sismember", "scard", "spop", "srandmember", "sinter", "sinterstore",
	    "sunion", "sunionstore", "sdiff", "sdiffstore", "smembers", "zadd", "zincrby", "zrem", "zremrangebyscore", "zremrangebyrank", "zunionstore",
	    "zinterstore", "zrange", "zrangebyscore", "zrevrangebyscore", "zcount", "zrevrange", "zcard", "zscore", "zrank", "zrevrank", "hset", "hsetnx",
	    "hget", "hmset", "hmget", "hincrby", "hdel", "hlen", "hkeys", "hvals", "hgetall", "hexists", "incrby", "decrby", "getset", "mset", "msetnx",
	    "randomkey", "select", "move", "rename", "renamenx", "expire", "expireat", "keys", "dbsize", "auth", "ping", "echo", "save", "bgsave",
	    "bgrewriteaof", "shutdown", "lastsave", "type", "multi", "exec", "discard", "sync", "flushdb", "flushall", "sort", "info", "monitor", "ttl",
	    "persist", "slaveof", "debug", "config", "subscribe", "unsubscribe", "psubscribe", "punsubscribe", "publish", "watch", "unwatch", "cluster",
	    "restore", "migrate", "dump", "object", "client", "eval", "evalsha"], require("./lib/commands"));
	
	commands.forEach(function (fullCommand) {
	    var command = fullCommand.split(' ')[0];
	
	    RedisClient.prototype[command] = function (args, callback) {
	        if (Array.isArray(args) && typeof callback === "function") {
	            return this.send_command(command, args, callback);
	        } else {
	            return this.send_command(command, to_array(arguments));
	        }
	    };
	    RedisClient.prototype[command.toUpperCase()] = RedisClient.prototype[command];
	
	    Multi.prototype[command] = function () {
	        this.queue.push([command].concat(to_array(arguments)));
	        return this;
	    };
	    Multi.prototype[command.toUpperCase()] = Multi.prototype[command];
	});
	
	// store db in this.select_db to restore it on reconnect
	RedisClient.prototype.select = function (db, callback) {
	    var self = this;
	
	    this.send_command('select', [db], function (err, res) {
	        if (err === null) {
	            self.selected_db = db;
	        }
	        if (typeof(callback) === 'function') {
	            callback(err, res);
	        }
	    });
	};
	RedisClient.prototype.SELECT = RedisClient.prototype.select;
	
	// Stash auth for connect and reconnect.  Send immediately if already connected.
	RedisClient.prototype.auth = function () {
	    var args = to_array(arguments);
	    this.auth_pass = args[0];
	    this.auth_callback = args[1];
	    if (exports.debug_mode) {
	        console.log("Saving auth as " + this.auth_pass);
	    }
	
	    if (this.connected) {
	        this.send_command("auth", args);
	    }
	};
	RedisClient.prototype.AUTH = RedisClient.prototype.auth;
	
	RedisClient.prototype.hmget = function (arg1, arg2, arg3) {
	    if (Array.isArray(arg2) && typeof arg3 === "function") {
	        return this.send_command("hmget", [arg1].concat(arg2), arg3);
	    } else if (Array.isArray(arg1) && typeof arg2 === "function") {
	        return this.send_command("hmget", arg1, arg2);
	    } else {
	        return this.send_command("hmget", to_array(arguments));
	    }
	};
	RedisClient.prototype.HMGET = RedisClient.prototype.hmget;
	
	RedisClient.prototype.hmset = function (args, callback) {
	    var tmp_args, tmp_keys, i, il, key;
	
	    if (Array.isArray(args) && typeof callback === "function") {
	        return this.send_command("hmset", args, callback);
	    }
	
	    args = to_array(arguments);
	    if (typeof args[args.length - 1] === "function") {
	        callback = args[args.length - 1];
	        args.length -= 1;
	    } else {
	        callback = null;
	    }
	
	    if (args.length === 2 && (typeof args[0] === "string" || typeof args[0] === "number") && typeof args[1] === "object") {
	        // User does: client.hmset(key, {key1: val1, key2: val2})
	        // assuming key is a string, i.e. email address
	
	        // if key is a number, i.e. timestamp, convert to string
	        if (typeof args[0] === "number") {
	            args[0] = args[0].toString();
	        }
	
	        tmp_args = [ args[0] ];
	        tmp_keys = Object.keys(args[1]);
	        for (i = 0, il = tmp_keys.length; i < il ; i++) {
	            key = tmp_keys[i];
	            tmp_args.push(key);
	            tmp_args.push(args[1][key]);
	        }
	        args = tmp_args;
	    }
	
	    return this.send_command("hmset", args, callback);
	};
	RedisClient.prototype.HMSET = RedisClient.prototype.hmset;
	
	Multi.prototype.hmset = function () {
	    var args = to_array(arguments), tmp_args;
	    if (args.length >= 2 && typeof args[0] === "string" && typeof args[1] === "object") {
	        tmp_args = [ "hmset", args[0] ];
	        Object.keys(args[1]).map(function (key) {
	            tmp_args.push(key);
	            tmp_args.push(args[1][key]);
	        });
	        if (args[2]) {
	            tmp_args.push(args[2]);
	        }
	        args = tmp_args;
	    } else {
	        args.unshift("hmset");
	    }
	
	    this.queue.push(args);
	    return this;
	};
	Multi.prototype.HMSET = Multi.prototype.hmset;
	
	Multi.prototype.exec = function (callback) {
	    var self = this;
	    var errors = [];
	    // drain queue, callback will catch "QUEUED" or error
	    // TODO - get rid of all of these anonymous functions which are elegant but slow
	    this.queue.forEach(function (args, index) {
	        var command = args[0], obj;
	        if (typeof args[args.length - 1] === "function") {
	            args = args.slice(1, -1);
	        } else {
	            args = args.slice(1);
	        }
	        if (args.length === 1 && Array.isArray(args[0])) {
	            args = args[0];
	        }
	        if (command.toLowerCase() === 'hmset' && typeof args[1] === 'object') {
	            obj = args.pop();
	            Object.keys(obj).forEach(function (key) {
	                args.push(key);
	                args.push(obj[key]);
	            });
	        }
	        this._client.send_command(command, args, function (err, reply) {
	            if (err) {
	                var cur = self.queue[index];
	                if (typeof cur[cur.length - 1] === "function") {
	                    cur[cur.length - 1](err);
	                } else {
	                    errors.push(new Error(err));
	                }
	            }
	        });
	    }, this);
	
	    // TODO - make this callback part of Multi.prototype instead of creating it each time
	    return this._client.send_command("EXEC", [], function (err, replies) {
	        if (err) {
	            if (callback) {
	                errors.push(new Error(err));
	                callback(errors);
	                return;
	            } else {
	                throw new Error(err);
	            }
	        }
	
	        var i, il, reply, args;
	
	        if (replies) {
	            for (i = 1, il = self.queue.length; i < il; i += 1) {
	                reply = replies[i - 1];
	                args = self.queue[i];
	
	                // TODO - confusing and error-prone that hgetall is special cased in two places
	                if (reply && args[0].toLowerCase() === "hgetall") {
	                    replies[i - 1] = reply = reply_to_object(reply);
	                }
	
	                if (typeof args[args.length - 1] === "function") {
	                    args[args.length - 1](null, reply);
	                }
	            }
	        }
	
	        if (callback) {
	            callback(null, replies);
	        }
	    });
	};
	Multi.prototype.EXEC = Multi.prototype.exec;
	
	RedisClient.prototype.multi = function (args) {
	    return new Multi(this, args);
	};
	RedisClient.prototype.MULTI = function (args) {
	    return new Multi(this, args);
	};
	
	
	// stash original eval method
	var eval_orig = RedisClient.prototype.eval;
	// hook eval with an attempt to evalsha for cached scripts
	RedisClient.prototype.eval = RedisClient.prototype.EVAL = function () {
	    var self = this,
	        args = to_array(arguments),
	        callback;
	
	    if (typeof args[args.length - 1] === "function") {
	        callback = args.pop();
	    }
	
	    if (Array.isArray(args[0])) {
	        args = args[0];
	    }
	
	    // replace script source with sha value
	    var source = args[0];
	    args[0] = crypto.createHash("sha1").update(source).digest("hex");
	
	    self.evalsha(args, function (err, reply) {
	        if (err && /NOSCRIPT/.test(err.message)) {
	            args[0] = source;
	            eval_orig.call(self, args, callback);
	
	        } else if (callback) {
	            callback(err, reply);
	        }
	    });
	};
	
	
	exports.createClient = function (port_arg, host_arg, options) {
	    var port = port_arg || default_port,
	        host = host_arg || default_host,
	        redis_client, net_client;
	
	    net_client = net.createConnection(port, host);
	
	    redis_client = new RedisClient(net_client, options);
	
	    redis_client.port = port;
	    redis_client.host = host;
	
	    return redis_client;
	};
	
	exports.print = function (err, reply) {
	    if (err) {
	        console.log("Error: " + err);
	    } else {
	        console.log("Reply: " + reply);
	    }
	};
	

}, 'redis/lib/util.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'redis/lib/util.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'redis/lib/util.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'redis/lib/util.js';
	var __dirname = 'redis/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'redis/lib/util.js'], env: {}};

	/** code **/
	// Support for very old versions of node where the module was called "sys".  At some point, we should abandon this.
	
	var util;
	
	try {
	    util = require("util");
	} catch (err) {
	    util = require("sys");
	}
	
	module.exports = util;
	

}, 'redis/lib/queue.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'redis/lib/queue.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'redis/lib/queue.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'redis/lib/queue.js';
	var __dirname = 'redis/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'redis/lib/queue.js'], env: {}};

	/** code **/
	// Queue class adapted from Tim Caswell's pattern library
	// http://github.com/creationix/pattern/blob/master/lib/pattern/queue.js
	
	function Queue() {
	    this.tail = [];
	    this.head = [];
	    this.offset = 0;
	}
	
	Queue.prototype.shift = function () {
	    if (this.offset === this.head.length) {
	        var tmp = this.head;
	        tmp.length = 0;
	        this.head = this.tail;
	        this.tail = tmp;
	        this.offset = 0;
	        if (this.head.length === 0) {
	            return;
	        }
	    }
	    return this.head[this.offset++]; // sorry, JSLint
	};
	
	Queue.prototype.push = function (item) {
	    return this.tail.push(item);
	};
	
	Queue.prototype.forEach = function (fn, thisv) {
	    var array = this.head.slice(this.offset), i, il;
	
	    array.push.apply(array, this.tail);
	
	    if (thisv) {
	        for (i = 0, il = array.length; i < il; i += 1) {
	            fn.call(thisv, array[i], i, array);
	        }
	    } else {
	        for (i = 0, il = array.length; i < il; i += 1) {
	            fn(array[i], i, array);
	        }
	    }
	
	    return array;
	};
	
	Queue.prototype.getLength = function () {
	    return this.head.length - this.offset + this.tail.length;
	};
	    
	Object.defineProperty(Queue.prototype, "length", {
	    get: function () {
	        return this.getLength();
	    }
	});
	
	
	if (typeof module !== "undefined" && module.exports) {
	    module.exports = Queue;
	}
	

}, 'redis/lib/to_array.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'redis/lib/to_array.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'redis/lib/to_array.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'redis/lib/to_array.js';
	var __dirname = 'redis/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'redis/lib/to_array.js'], env: {}};

	/** code **/
	function to_array(args) {
	    var len = args.length,
	        arr = new Array(len), i;
	
	    for (i = 0; i < len; i += 1) {
	        arr[i] = args[i];
	    }
	
	    return arr;
	}
	
	module.exports = to_array;
	

}, 'redis/lib/parser/hiredis.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'redis/lib/parser/hiredis.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'redis/lib/parser/hiredis.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'redis/lib/parser/hiredis.js';
	var __dirname = 'redis/lib/parser';
	var process = {cwd: function() {return '/';}, argv: ['node', 'redis/lib/parser/hiredis.js'], env: {}};

	/** code **/
	var events = require("events"),
	    util = require("../util"),
	    hiredis = require("hiredis");
	
	exports.debug_mode = false;
	exports.name = "hiredis";
	
	function HiredisReplyParser(options) {
	    this.name = exports.name;
	    this.options = options || {};
	    this.reset();
	    events.EventEmitter.call(this);
	}
	
	util.inherits(HiredisReplyParser, events.EventEmitter);
	
	exports.Parser = HiredisReplyParser;
	
	HiredisReplyParser.prototype.reset = function () {
	    this.reader = new hiredis.Reader({
	        return_buffers: this.options.return_buffers || false
	    });
	};
	
	HiredisReplyParser.prototype.execute = function (data) {
	    var reply;
	    this.reader.feed(data);
	    while (true) {
	        try {
	            reply = this.reader.get();
	        } catch (err) {
	            this.emit("error", err);
	            break;
	        }
	
	        if (reply === undefined) {
	            break;
	        }
	
	        if (reply && reply.constructor === Error) {
	            this.emit("reply error", reply);
	        } else {
	            this.emit("reply", reply);
	        }
	    }
	};
	

}, 'redis/lib/parser/javascript.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'redis/lib/parser/javascript.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'redis/lib/parser/javascript.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'redis/lib/parser/javascript.js';
	var __dirname = 'redis/lib/parser';
	var process = {cwd: function() {return '/';}, argv: ['node', 'redis/lib/parser/javascript.js'], env: {}};

	/** code **/
	var events = require("events"),
	    util   = require("../util");
	
	function Packet(type, size) {
	    this.type = type;
	    this.size = +size;
	}
	
	exports.name = "javascript";
	exports.debug_mode = false;
	
	function ReplyParser(options) {
	    this.name = exports.name;
	    this.options = options || { };
	
	    this._buffer            = null;
	    this._offset            = 0;
	    this._encoding          = "utf-8";
	    this._debug_mode        = options.debug_mode;
	    this._reply_type        = null;
	}
	
	util.inherits(ReplyParser, events.EventEmitter);
	
	exports.Parser = ReplyParser;
	
	function IncompleteReadBuffer(message) {
	    this.name = "IncompleteReadBuffer";
	    this.message = message;
	}
	util.inherits(IncompleteReadBuffer, Error);
	
	// Buffer.toString() is quite slow for small strings
	function small_toString(buf, start, end) {
	    var tmp = "", i;
	
	    for (i = start; i < end; i++) {
	        tmp += String.fromCharCode(buf[i]);
	    }
	
	    return tmp;
	}
	
	ReplyParser.prototype._parseResult = function (type) {
	    var start, end, offset, packetHeader;
	
	    if (type === 43 || type === 45) { // + or -
	        // up to the delimiter
	        end = this._packetEndOffset() - 1;
	        start = this._offset;
	
	        // include the delimiter
	        this._offset = end + 2;
	
	        if (end > this._buffer.length) {
	            this._offset = start;
	            throw new IncompleteReadBuffer("Wait for more data.");
	        }
	
	        if (this.options.return_buffers) {
	            return this._buffer.slice(start, end);
	        } else {
	            if (end - start < 65536) { // completely arbitrary
	                return small_toString(this._buffer, start, end);
	            } else {
	                return this._buffer.toString(this._encoding, start, end);
	            }
	        }
	    } else if (type === 58) { // :
	        // up to the delimiter
	        end = this._packetEndOffset() - 1;
	        start = this._offset;
	
	        // include the delimiter
	        this._offset = end + 2;
	
	        if (end > this._buffer.length) {
	            this._offset = start;
	            throw new IncompleteReadBuffer("Wait for more data.");
	        }
	
	        if (this.options.return_buffers) {
	            return this._buffer.slice(start, end);
	        }
	
	        // return the coerced numeric value
	        return +small_toString(this._buffer, start, end);
	    } else if (type === 36) { // $
	        // set a rewind point, as the packet could be larger than the
	        // buffer in memory
	        offset = this._offset - 1;
	
	        packetHeader = new Packet(type, this.parseHeader());
	
	        // packets with a size of -1 are considered null
	        if (packetHeader.size === -1) {
	            return undefined;
	        }
	
	        end = this._offset + packetHeader.size;
	        start = this._offset;
	
	        // set the offset to after the delimiter
	        this._offset = end + 2;
	
	        if (end > this._buffer.length) {
	            this._offset = offset;
	            throw new IncompleteReadBuffer("Wait for more data.");
	        }
	
	        if (this.options.return_buffers) {
	            return this._buffer.slice(start, end);
	        } else {
	            return this._buffer.toString(this._encoding, start, end);
	        }
	    } else if (type === 42) { // *
	        offset = this._offset;
	        packetHeader = new Packet(type, this.parseHeader());
	
	        if (packetHeader.size < 0) {
	            return null;
	        }
	
	        if (packetHeader.size > this._bytesRemaining()) {
	            this._offset = offset - 1;
	            throw new IncompleteReadBuffer("Wait for more data.");
	        }
	
	        var reply = [ ];
	        var ntype, i, res;
	
	        offset = this._offset - 1;
	
	        for (i = 0; i < packetHeader.size; i++) {
	            ntype = this._buffer[this._offset++];
	
	            if (this._offset > this._buffer.length) {
	                throw new IncompleteReadBuffer("Wait for more data.");
	            }
	            res = this._parseResult(ntype);
	            if (res === undefined) {
	                res = null;
	            }
	            reply.push(res);
	        }
	
	        return reply;
	    }
	};
	
	ReplyParser.prototype.execute = function (buffer) {
	    this.append(buffer);
	
	    var type, ret, offset;
	
	    while (true) {
	        offset = this._offset;
	        try {
	            // at least 4 bytes: :1\r\n
	            if (this._bytesRemaining() < 4) {
	                break;
	            }
	
	            type = this._buffer[this._offset++];
	
	            if (type === 43) { // +
	                ret = this._parseResult(type);
	
	                if (ret === null) {
	                    break;
	                }
	
	                this.send_reply(ret);
	            } else  if (type === 45) { // -
	                ret = this._parseResult(type);
	
	                if (ret === null) {
	                    break;
	                }
	
	                this.send_error(ret);
	            } else if (type === 58) { // :
	                ret = this._parseResult(type);
	
	                if (ret === null) {
	                    break;
	                }
	
	                this.send_reply(ret);
	            } else if (type === 36) { // $
	                ret = this._parseResult(type);
	
	                if (ret === null) {
	                    break;
	                }
	
	                // check the state for what is the result of
	                // a -1, set it back up for a null reply
	                if (ret === undefined) {
	                    ret = null;
	                }
	
	                this.send_reply(ret);
	            } else if (type === 42) { // *
	                // set a rewind point. if a failure occurs,
	                // wait for the next execute()/append() and try again
	                offset = this._offset - 1;
	
	                ret = this._parseResult(type);
	
	                this.send_reply(ret);
	            }
	        } catch (err) {
	            // catch the error (not enough data), rewind, and wait
	            // for the next packet to appear
	            if (! (err instanceof IncompleteReadBuffer)) {
	              throw err;
	            }
	            this._offset = offset;
	            break;
	        }
	    }
	};
	
	ReplyParser.prototype.append = function (newBuffer) {
	    if (!newBuffer) {
	        return;
	    }
	
	    // first run
	    if (this._buffer === null) {
	        this._buffer = newBuffer;
	
	        return;
	    }
	
	    // out of data
	    if (this._offset >= this._buffer.length) {
	        this._buffer = newBuffer;
	        this._offset = 0;
	
	        return;
	    }
	
	    // very large packet
	    // check for concat, if we have it, use it
	    if (Buffer.concat !== undefined) {
	        this._buffer = Buffer.concat([this._buffer.slice(this._offset), newBuffer]);
	    } else {
	        var remaining = this._bytesRemaining(),
	            newLength = remaining + newBuffer.length,
	            tmpBuffer = new Buffer(newLength);
	
	        this._buffer.copy(tmpBuffer, 0, this._offset);
	        newBuffer.copy(tmpBuffer, remaining, 0);
	
	        this._buffer = tmpBuffer;
	    }
	
	    this._offset = 0;
	};
	
	ReplyParser.prototype.parseHeader = function () {
	    var end   = this._packetEndOffset(),
	        value = small_toString(this._buffer, this._offset, end - 1);
	
	    this._offset = end + 1;
	
	    return value;
	};
	
	ReplyParser.prototype._packetEndOffset = function () {
	    var offset = this._offset;
	
	    while (this._buffer[offset] !== 0x0d && this._buffer[offset + 1] !== 0x0a) {
	        offset++;
	
	        if (offset >= this._buffer.length) {
	            throw new IncompleteReadBuffer("didn't see LF after NL reading multi bulk count (" + offset + " => " + this._buffer.length + ", " + this._offset + ")");
	        }
	    }
	
	    offset++;
	    return offset;
	};
	
	ReplyParser.prototype._bytesRemaining = function () {
	    return (this._buffer.length - this._offset) < 0 ? 0 : (this._buffer.length - this._offset);
	};
	
	ReplyParser.prototype.parser_error = function (message) {
	    this.emit("error", message);
	};
	
	ReplyParser.prototype.send_error = function (reply) {
	    this.emit("reply error", reply);
	};
	
	ReplyParser.prototype.send_reply = function (reply) {
	    this.emit("reply", reply);
	};
	

}, 'redis/lib/commands.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'redis/lib/commands.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'redis/lib/commands.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'redis/lib/commands.js';
	var __dirname = 'redis/lib';
	var process = {cwd: function() {return '/';}, argv: ['node', 'redis/lib/commands.js'], env: {}};

	/** code **/
	// This file was generated by ./generate_commands.js on Sun Dec 15 2013 15:58:20 GMT+0000 (GMT)
	module.exports = [
	    "append",
	    "auth",
	    "bgrewriteaof",
	    "bgsave",
	    "bitcount",
	    "bitop",
	    "blpop",
	    "brpop",
	    "brpoplpush",
	    "client kill",
	    "client list",
	    "client getname",
	    "client setname",
	    "config get",
	    "config rewrite",
	    "config set",
	    "config resetstat",
	    "dbsize",
	    "debug object",
	    "debug segfault",
	    "decr",
	    "decrby",
	    "del",
	    "discard",
	    "dump",
	    "echo",
	    "eval",
	    "evalsha",
	    "exec",
	    "exists",
	    "expire",
	    "expireat",
	    "flushall",
	    "flushdb",
	    "get",
	    "getbit",
	    "getrange",
	    "getset",
	    "hdel",
	    "hexists",
	    "hget",
	    "hgetall",
	    "hincrby",
	    "hincrbyfloat",
	    "hkeys",
	    "hlen",
	    "hmget",
	    "hmset",
	    "hset",
	    "hsetnx",
	    "hvals",
	    "incr",
	    "incrby",
	    "incrbyfloat",
	    "info",
	    "keys",
	    "lastsave",
	    "lindex",
	    "linsert",
	    "llen",
	    "lpop",
	    "lpush",
	    "lpushx",
	    "lrange",
	    "lrem",
	    "lset",
	    "ltrim",
	    "mget",
	    "migrate",
	    "monitor",
	    "move",
	    "mset",
	    "msetnx",
	    "multi",
	    "object",
	    "persist",
	    "pexpire",
	    "pexpireat",
	    "ping",
	    "psetex",
	    "psubscribe",
	    "pubsub",
	    "pttl",
	    "publish",
	    "punsubscribe",
	    "quit",
	    "randomkey",
	    "rename",
	    "renamenx",
	    "restore",
	    "rpop",
	    "rpoplpush",
	    "rpush",
	    "rpushx",
	    "sadd",
	    "save",
	    "scard",
	    "script exists",
	    "script flush",
	    "script kill",
	    "script load",
	    "sdiff",
	    "sdiffstore",
	    "select",
	    "set",
	    "setbit",
	    "setex",
	    "setnx",
	    "setrange",
	    "shutdown",
	    "sinter",
	    "sinterstore",
	    "sismember",
	    "slaveof",
	    "slowlog",
	    "smembers",
	    "smove",
	    "sort",
	    "spop",
	    "srandmember",
	    "srem",
	    "strlen",
	    "subscribe",
	    "sunion",
	    "sunionstore",
	    "sync",
	    "time",
	    "ttl",
	    "type",
	    "unsubscribe",
	    "unwatch",
	    "watch",
	    "zadd",
	    "zcard",
	    "zcount",
	    "zincrby",
	    "zinterstore",
	    "zrange",
	    "zrangebyscore",
	    "zrank",
	    "zrem",
	    "zremrangebyrank",
	    "zremrangebyscore",
	    "zrevrange",
	    "zrevrangebyscore",
	    "zrevrank",
	    "zscore",
	    "zunionstore",
	    "scan",
	    "sscan",
	    "hscan",
	    "zscan"
	];
	

}, '/Storage/BrowserLocalStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/Storage/BrowserLocalStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/Storage/BrowserLocalStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/Storage/BrowserLocalStorage.js';
	var __dirname = '/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/Storage/BrowserLocalStorage.js'], env: {}};

	/** code **/
	console.log('BrowserLocalStorage is deprecated, please use BrowserLocalSyncStorage instead.');
	
	module.exports = require('../lib/Storage/Sync/BrowserLocalStorage');

}, '/Storage/BrowserLocalSyncStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/Storage/BrowserLocalSyncStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/Storage/BrowserLocalSyncStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/Storage/BrowserLocalSyncStorage.js';
	var __dirname = '/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/Storage/BrowserLocalSyncStorage.js'], env: {}};

	/** code **/
	module.exports = require('../lib/Storage/Sync/BrowserLocalStorage');

}, '/Storage/DevNullAsyncStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/Storage/DevNullAsyncStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/Storage/DevNullAsyncStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/Storage/DevNullAsyncStorage.js';
	var __dirname = '/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/Storage/DevNullAsyncStorage.js'], env: {}};

	/** code **/
	module.exports = require('../lib/Storage/Async/DevNullStorage');

}, '/Storage/DevNullStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/Storage/DevNullStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/Storage/DevNullStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/Storage/DevNullStorage.js';
	var __dirname = '/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/Storage/DevNullStorage.js'], env: {}};

	/** code **/
	console.log('DevNullStorage is deprecated, use DevNullSyncStorage instead.');
	
	module.exports = require('../lib/Storage/Sync/DevNullStorage');

}, '/Storage/DevNullSyncStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/Storage/DevNullSyncStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/Storage/DevNullSyncStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/Storage/DevNullSyncStorage.js';
	var __dirname = '/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/Storage/DevNullSyncStorage.js'], env: {}};

	/** code **/
	module.exports = require('../lib/Storage/Sync/DevNullStorage');

}, '/Storage/FileAsyncStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/Storage/FileAsyncStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/Storage/FileAsyncStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/Storage/FileAsyncStorage.js';
	var __dirname = '/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/Storage/FileAsyncStorage.js'], env: {}};

	/** code **/
	module.exports = require('../lib/Storage/Async/FileStorage');

}, '/Storage/FileStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/Storage/FileStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/Storage/FileStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/Storage/FileStorage.js';
	var __dirname = '/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/Storage/FileStorage.js'], env: {}};

	/** code **/
	console.log('FileStorage is deprecated, please use FileSyncStorage instead.');
	
	module.exports = require('../lib/Storage/Sync/FileStorage');

}, '/Storage/FileSyncStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/Storage/FileSyncStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/Storage/FileSyncStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/Storage/FileSyncStorage.js';
	var __dirname = '/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/Storage/FileSyncStorage.js'], env: {}};

	/** code **/
	module.exports = require('../lib/Storage/Sync/FileStorage');

}, '/Storage/MemoryAsyncStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/Storage/MemoryAsyncStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/Storage/MemoryAsyncStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/Storage/MemoryAsyncStorage.js';
	var __dirname = '/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/Storage/MemoryAsyncStorage.js'], env: {}};

	/** code **/
	module.exports = require('../lib/Storage/Async/MemoryStorage');

}, '/Storage/MemoryStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/Storage/MemoryStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/Storage/MemoryStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/Storage/MemoryStorage.js';
	var __dirname = '/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/Storage/MemoryStorage.js'], env: {}};

	/** code **/
	console.log('MemoryStorage is deprecated, please use MemorySyncStorage instead.');
	
	module.exports = require('../lib/Storage/Sync/MemoryStorage');

}, '/Storage/MemorySyncStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/Storage/MemorySyncStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/Storage/MemorySyncStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/Storage/MemorySyncStorage.js';
	var __dirname = '/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/Storage/MemorySyncStorage.js'], env: {}};

	/** code **/
	module.exports = require('../lib/Storage/Sync/MemoryStorage');

}, '/Storage/RedisAsyncStorage.js': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/Storage/RedisAsyncStorage.js');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/Storage/RedisAsyncStorage.js';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/Storage/RedisAsyncStorage.js';
	var __dirname = '/Storage';
	var process = {cwd: function() {return '/';}, argv: ['node', '/Storage/RedisAsyncStorage.js'], env: {}};

	/** code **/
	module.exports = require('../lib/Storage/Async/RedisStorage');

}, '/test/browser/tests/Cache.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/browser/tests/Cache.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/browser/tests/Cache.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/browser/tests/Cache.coffee';
	var __dirname = '/test/browser/tests';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/browser/tests/Cache.coffee'], env: {}};

	/** code **/
	(function() {
	  var Cache;
	
	  Cache = require('cache-storage');
	
	  describe('Cache', function() {
	    return describe('#constructor()', function() {
	      return it('should throw an error if storage is not an instance of Cache Storage', function() {
	        return expect(function() {
	          return new Cache(new Array);
	        }).to["throw"](Error);
	      });
	    });
	  });
	
	}).call(this);
	

}, '/test/browser/tests/Storage/Async/DevNullStorage.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/browser/tests/Storage/Async/DevNullStorage.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/browser/tests/Storage/Async/DevNullStorage.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/browser/tests/Storage/Async/DevNullStorage.coffee';
	var __dirname = '/test/browser/tests/Storage/Async';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/browser/tests/Storage/Async/DevNullStorage.coffee'], env: {}};

	/** code **/
	(function() {
	  var Cache, DevNullStorage, cache;
	
	  Cache = require('cache-storage');
	
	  DevNullStorage = require('cache-storage/Storage/DevNullAsyncStorage');
	
	  cache = null;
	
	  describe('DevNullAsyncStorage', function() {
	    return describe('saving/loading', function() {
	      beforeEach(function() {
	        return cache = new Cache(new DevNullStorage, 'test');
	      });
	      it('should not save true', function(done) {
	        return cache.save('true', true, function() {
	          return cache.load('true', function(err, data) {
	            expect(data).to.be["null"];
	            return done();
	          });
	        });
	      });
	      it('should always return null', function(done) {
	        return cache.load('true', function(err, data) {
	          expect(data).to.be["null"];
	          return done();
	        });
	      });
	      it('should not save true and try to delete it', function(done) {
	        return cache.save('true', true, function() {
	          return cache.remove('true', function() {
	            return cache.load('true', function(err, data) {
	              expect(data).to.be["null"];
	              return done();
	            });
	          });
	        });
	      });
	      return it('should not save true to cache from fallback function in load', function(done) {
	        return cache.load('true', function() {
	          return true;
	        }, function(err, data) {
	          expect(data).to.be["true"];
	          return cache.load('true', function(err, data) {
	            expect(data).to.be["null"];
	            return done();
	          });
	        });
	      });
	    });
	  });
	
	}).call(this);
	

}, '/test/browser/tests/Storage/Async/MemoryStorage.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/browser/tests/Storage/Async/MemoryStorage.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/browser/tests/Storage/Async/MemoryStorage.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/browser/tests/Storage/Async/MemoryStorage.coffee';
	var __dirname = '/test/browser/tests/Storage/Async';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/browser/tests/Storage/Async/MemoryStorage.coffee'], env: {}};

	/** code **/
	(function() {
	  var Cache, MemoryStorage, async, cache;
	
	  async = require('async');
	
	  Cache = require('cache-storage');
	
	  MemoryStorage = require('cache-storage/Storage/MemoryAsyncStorage');
	
	  cache = null;
	
	  describe('MemoryAsyncStorage', function() {
	    beforeEach(function() {
	      return cache = new Cache(new MemoryStorage, 'test');
	    });
	    describe('saving/loading', function() {
	      it('should save true and load it', function(done) {
	        return cache.save('true', true, function() {
	          return cache.load('true', function(err, data) {
	            expect(data).to.be["true"];
	            return done();
	          });
	        });
	      });
	      it('should return null if item not exists', function(done) {
	        return cache.load('true', function(err, data) {
	          expect(data).to.be["null"];
	          return done();
	        });
	      });
	      it('should save true and delete it', function(done) {
	        return cache.save('true', true, function() {
	          return cache.remove('true', function() {
	            return cache.load('true', function(err, data) {
	              expect(data).to.be["null"];
	              return done();
	            });
	          });
	        });
	      });
	      return it('should save true to cache from fallback function in load', function(done) {
	        return cache.load('true', function() {
	          return true;
	        }, function(err, data) {
	          expect(data).to.be["true"];
	          return done();
	        });
	      });
	    });
	    return describe('expiration', function() {
	      it('should expire "true" value after file is changed', function(done) {
	        return cache.save('true', true, {
	          files: [__filename]
	        }, function() {
	          return setTimeout(function() {
	            return cache.load('true', function(err, data) {
	              expect(data).to.be["true"];
	              changeFile(__filename);
	              return cache.load('true', function(err, data) {
	                expect(data).to.be["null"];
	                return done();
	              });
	            });
	          }, 100);
	        });
	      });
	      it('should remove all items with tag "article"', function(done) {
	        var data;
	        data = [['one', null, ['article']], ['two', 'two', ['category']], ['three', null, ['article']]];
	        return async.eachSeries(data, function(item, cb) {
	          return cache.save(item[0], item[0], {
	            tags: item[2]
	          }, function() {
	            return cb();
	          });
	        }, function() {
	          return cache.clean({
	            tags: ['article']
	          }, function() {
	            return async.eachSeries(data, function(item, cb) {
	              return cache.load(item[0], function(err, data) {
	                expect(data).to.be.equal(item[1]);
	                return cb();
	              });
	            }, function() {
	              return done();
	            });
	          });
	        });
	      });
	      it('should expire "true" value after 1 second"', function(done) {
	        return cache.save('true', true, {
	          expire: {
	            seconds: 1
	          }
	        }, function() {
	          return setTimeout(function() {
	            return cache.load('true', function(err, data) {
	              expect(data).to.be["null"];
	              return done();
	            });
	          }, 1100);
	        });
	      });
	      it('should expire "true" value after "first" value expire', function(done) {
	        return cache.save('first', 'first', function() {
	          return cache.save('true', true, {
	            items: ['first']
	          }, function() {
	            return cache.remove('first', function() {
	              return cache.load('true', function(err, data) {
	                expect(data).to.be["null"];
	                return done();
	              });
	            });
	          });
	        });
	      });
	      it('should expire all items with priority bellow 50', function(done) {
	        return cache.save('one', 'one', {
	          priority: 100
	        }, function() {
	          return cache.save('two', 'two', {
	            priority: 10
	          }, function() {
	            return cache.clean({
	              priority: 50
	            }, function() {
	              return cache.load('one', function(err, data) {
	                expect(data).to.be.equal('one');
	                return cache.load('two', function(err, data) {
	                  expect(data).to.be["null"];
	                  return done();
	                });
	              });
	            });
	          });
	        });
	      });
	      return it('should remove all items from cache', function(done) {
	        return cache.save('one', 'one', function() {
	          return cache.save('two', 'two', function() {
	            return cache.clean('all', function() {
	              return cache.load('one', function(err, data) {
	                expect(data).to.be["null"];
	                return cache.load('two', function(err, data) {
	                  expect(data).to.be["null"];
	                  return done();
	                });
	              });
	            });
	          });
	        });
	      });
	    });
	  });
	
	}).call(this);
	

}, '/test/browser/tests/Storage/Async/Storage.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/browser/tests/Storage/Async/Storage.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/browser/tests/Storage/Async/Storage.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/browser/tests/Storage/Async/Storage.coffee';
	var __dirname = '/test/browser/tests/Storage/Async';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/browser/tests/Storage/Async/Storage.coffee'], env: {}};

	/** code **/
	(function() {
	  var Cache, Storage, cache, moment, storage;
	
	  Cache = require('cache-storage');
	
	  Storage = require('cache-storage/lib/Storage/Async/Storage');
	
	  moment = require('moment');
	
	  cache = null;
	
	  storage = null;
	
	  describe('AsyncStorage', function() {
	    beforeEach(function() {
	      storage = new Storage;
	      return cache = new Cache(storage);
	    });
	    describe('#verify()', function() {
	      it('should just return true', function(done) {
	        return storage.verify('random variable', function(err, state) {
	          expect(state).to.be["true"];
	          return done();
	        });
	      });
	      it('should return false if meta expired', function(done) {
	        return storage.verify({
	          expire: (new Date).getTime() - 200
	        }, function(err, state) {
	          expect(state).to.be["false"];
	          return done();
	        });
	      });
	      it('should return false if dependent meta expired', function(done) {
	        storage.findMeta = function(key, fn) {
	          return fn(null, {
	            expire: (new Date).getTime() - 200
	          });
	        };
	        return storage.verify({
	          items: ['test']
	        }, function(err, state) {
	          expect(state).to.be["false"];
	          return done();
	        });
	      });
	      return it('should return false if file was changed', function(done) {
	        var files, meta;
	        files = {};
	        files[__filename] = window.require.getStats(__filename).mtime.getTime();
	        meta = {
	          files: files
	        };
	        return setTimeout(function() {
	          return storage.verify(meta, function(err, state) {
	            expect(state).to.be["true"];
	            changeFile(__filename);
	            return storage.verify(meta, function(err, state) {
	              expect(state).to.be["false"];
	              return done();
	            });
	          });
	        }, 100);
	      });
	    });
	    return describe('#parseDependencies()', function() {
	      it('should return empty object for unknown type of dependencies', function(done) {
	        return storage.parseDependencies('random variable', function(err, dependencies) {
	          expect(dependencies).to.be.eql({});
	          return done();
	        });
	      });
	      it('should add priority into dependencies', function(done) {
	        return storage.parseDependencies({
	          priority: 100
	        }, function(err, dependencies) {
	          expect(dependencies).to.be.eql({
	            priority: 100
	          });
	          return done();
	        });
	      });
	      it('should add tags into dependencies', function(done) {
	        return storage.parseDependencies({
	          tags: ['comment', 'article']
	        }, function(err, dependencies) {
	          expect(dependencies).to.be.eql({
	            tags: ['comment', 'article']
	          });
	          return done();
	        });
	      });
	      it('should add dependent item into dependencies', function(done) {
	        return storage.parseDependencies({
	          items: ['first', 'second']
	        }, function(err, dependencies) {
	          expect(dependencies).to.be.eql({
	            items: [cache.generateKey('first'), cache.generateKey('second')]
	          });
	          return done();
	        });
	      });
	      it('should add date from string into dependencies', function(done) {
	        var time;
	        time = '2014-01-14 20:10';
	        return storage.parseDependencies({
	          expire: time
	        }, function(err, dependencies) {
	          expect(dependencies).to.be.eql({
	            expire: moment(time, Cache.TIME_FORMAT).valueOf()
	          });
	          return done();
	        });
	      });
	      return it('should add file into dependencies', function(done) {
	        var files;
	        files = {};
	        files[__filename] = window.require.getStats(__filename).mtime.getTime();
	        return storage.parseDependencies({
	          files: [__filename]
	        }, function(err, dependencies) {
	          expect(dependencies).to.be.eql({
	            files: files
	          });
	          return done();
	        });
	      });
	    });
	  });
	
	}).call(this);
	

}, '/test/browser/tests/Storage/Sync/BrowserLocalStorage.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/browser/tests/Storage/Sync/BrowserLocalStorage.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/browser/tests/Storage/Sync/BrowserLocalStorage.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/browser/tests/Storage/Sync/BrowserLocalStorage.coffee';
	var __dirname = '/test/browser/tests/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/browser/tests/Storage/Sync/BrowserLocalStorage.coffee'], env: {}};

	/** code **/
	(function() {
	  var BrowserLocalStorage, Cache, cache, originalSimqVersion;
	
	  Cache = require('cache-storage');
	
	  BrowserLocalStorage = require('cache-storage/Storage/BrowserLocalSyncStorage');
	
	  cache = null;
	
	  originalSimqVersion = window.require.version;
	
	  describe('BrowserLocalsyncStorage', function() {
	    beforeEach(function() {
	      return cache = new Cache(new BrowserLocalStorage);
	    });
	    afterEach(function() {
	      return localStorage.clear();
	    });
	    describe('saving/loading', function() {
	      it('should save true and load it', function() {
	        cache.save('true', true);
	        return expect(cache.load('true')).to.be["true"];
	      });
	      it('should return null if item not exists', function() {
	        return expect(cache.load('true')).to.be["null"];
	      });
	      it('should save true and delete it', function() {
	        cache.save('true', true);
	        cache.remove('true');
	        return expect(cache.load('true')).to.be["null"];
	      });
	      return it('should save true to cache from fallback function in load', function() {
	        var val;
	        val = cache.load('true', function() {
	          return true;
	        });
	        return expect(val).to.be["true"];
	      });
	    });
	    return describe('expiration', function() {
	      it('should remove all items with tag "article"', function() {
	        cache.save('one', 'one', {
	          tags: ['article']
	        });
	        cache.save('two', 'two', {
	          tags: ['category']
	        });
	        cache.save('three', 'three', {
	          tags: ['article']
	        });
	        cache.clean({
	          tags: ['article']
	        });
	        expect(cache.load('one')).to.be["null"];
	        expect(cache.load('two')).to.be.equal('two');
	        return expect(cache.load('three')).to.be["null"];
	      });
	      it('should expire "true" value after 1 second"', function(done) {
	        cache.save('true', true, {
	          expire: {
	            seconds: 1
	          }
	        });
	        return setTimeout(function() {
	          expect(cache.load('true')).to.be["null"];
	          return done();
	        }, 1100);
	      });
	      it('should expire "true" value after "first" value expire', function() {
	        cache.save('first', 'first');
	        cache.save('true', true, {
	          items: ['first']
	        });
	        cache.remove('first');
	        return expect(cache.load('true')).to.be["null"];
	      });
	      it('should expire all items with priority bellow 50', function() {
	        cache.save('one', 'one', {
	          priority: 100
	        });
	        cache.save('two', 'two', {
	          priority: 10
	        });
	        cache.clean({
	          priority: 50
	        });
	        expect(cache.load('one')).to.be.equal('one');
	        return expect(cache.load('two')).to.be["null"];
	      });
	      it('should remove all items from cache', function() {
	        cache.save('one', 'one');
	        cache.save('two', 'two');
	        cache.clean('all');
	        expect(cache.load('one')).to.be["null"];
	        return expect(cache.load('two')).to.be["null"];
	      });
	      return describe('files', function() {
	        afterEach(function() {
	          window.require.simq = true;
	          return window.require.version = originalSimqVersion;
	        });
	        it('should throw an error for environments other than simq', function() {
	          delete window.require.simq;
	          return expect(function() {
	            return cache.save('true', true, {
	              files: []
	            });
	          }).to["throw"](Error, 'Files meta information can be used in browser only with simq.');
	        });
	        it('should throw an error if simq is old', function() {
	          window.require.version = '5.0.4';
	          return expect(function() {
	            return cache.save('true', true, {
	              files: []
	            });
	          }).to["throw"](Error, 'File method information is supported only with simq@5.1.0 and later.');
	        });
	        it('should throw an error if simq is really very old', function() {
	          delete window.require.version;
	          return expect(function() {
	            return cache.save('true', true, {
	              files: []
	            });
	          }).to["throw"](Error, 'File method information is supported only with simq@5.1.0 and later.');
	        });
	        return it('should expire data after file is changed', function() {
	          cache.save('true', true, {
	            files: [__filename]
	          });
	          changeFile(__filename);
	          return expect(cache.load('true')).to.be["null"];
	        });
	      });
	    });
	  });
	
	}).call(this);
	

}, '/test/browser/tests/Storage/Sync/DevNullStorage.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/browser/tests/Storage/Sync/DevNullStorage.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/browser/tests/Storage/Sync/DevNullStorage.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/browser/tests/Storage/Sync/DevNullStorage.coffee';
	var __dirname = '/test/browser/tests/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/browser/tests/Storage/Sync/DevNullStorage.coffee'], env: {}};

	/** code **/
	(function() {
	  var Cache, DevNullStorage, cache;
	
	  Cache = require('cache-storage');
	
	  DevNullStorage = require('cache-storage/Storage/DevNullSyncStorage');
	
	  cache = null;
	
	  describe('DevNullSyncStorage', function() {
	    beforeEach(function() {
	      return cache = new Cache(new DevNullStorage);
	    });
	    return describe('saving/loading', function() {
	      it('should not save true', function() {
	        cache.save('true', true);
	        return expect(cache.load('true')).to.be["null"];
	      });
	      it('should always return null', function() {
	        return expect(cache.load('true')).to.be["null"];
	      });
	      it('should not save true and try to delete it', function() {
	        cache.save('true', true);
	        cache.remove('true');
	        return expect(cache.load('true')).to.be["null"];
	      });
	      return it('should not save true to cache from fallback function in load', function() {
	        var val;
	        val = cache.load('true', function() {
	          return true;
	        });
	        expect(val).to.be["true"];
	        return expect(cache.load('true')).to.be["null"];
	      });
	    });
	  });
	
	}).call(this);
	

}, '/test/browser/tests/Storage/Sync/FileStorage.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/browser/tests/Storage/Sync/FileStorage.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/browser/tests/Storage/Sync/FileStorage.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/browser/tests/Storage/Sync/FileStorage.coffee';
	var __dirname = '/test/browser/tests/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/browser/tests/Storage/Sync/FileStorage.coffee'], env: {}};

	/** code **/
	(function() {
	  var FileStorage;
	
	  FileStorage = require('cache-storage/Storage/FileSyncStorage');
	
	  describe('FileSyncStorage', function() {
	    return describe('#constructor()', function() {
	      return it('should throw an error on browser', function() {
	        return expect(function() {
	          return new FileStorage;
	        }).to["throw"](Error);
	      });
	    });
	  });
	
	}).call(this);
	

}, '/test/browser/tests/Storage/Sync/MemoryStorage.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/browser/tests/Storage/Sync/MemoryStorage.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/browser/tests/Storage/Sync/MemoryStorage.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/browser/tests/Storage/Sync/MemoryStorage.coffee';
	var __dirname = '/test/browser/tests/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/browser/tests/Storage/Sync/MemoryStorage.coffee'], env: {}};

	/** code **/
	(function() {
	  var Cache, MemoryStorage, cache;
	
	  Cache = require('cache-storage');
	
	  MemoryStorage = require('cache-storage/Storage/MemorySyncStorage');
	
	  cache = null;
	
	  describe('MemorySyncStorage', function() {
	    beforeEach(function() {
	      return cache = new Cache(new MemoryStorage, 'test');
	    });
	    describe('saving/loading', function() {
	      it('should save true and load it', function() {
	        cache.save('true', true);
	        return expect(cache.load('true')).to.be["true"];
	      });
	      it('should return null if item not exists', function() {
	        return expect(cache.load('true')).to.be["null"];
	      });
	      it('should save true and delete it', function() {
	        cache.save('true', true);
	        cache.remove('true');
	        return expect(cache.load('true')).to.be["null"];
	      });
	      return it('should save true to cache from fallback function in load', function() {
	        var val;
	        val = cache.load('true', function() {
	          return true;
	        });
	        return expect(val).to.be["true"];
	      });
	    });
	    return describe('expiration', function() {
	      it('should remove all items with tag "article"', function() {
	        cache.save('one', 'one', {
	          tags: ['article']
	        });
	        cache.save('two', 'two', {
	          tags: ['category']
	        });
	        cache.save('three', 'three', {
	          tags: ['article']
	        });
	        cache.clean({
	          tags: ['article']
	        });
	        expect(cache.load('one')).to.be["null"];
	        expect(cache.load('two')).to.be.equal('two');
	        return expect(cache.load('three')).to.be["null"];
	      });
	      it('should expire "true" value after 1 second"', function(done) {
	        cache.save('true', true, {
	          expire: {
	            seconds: 1
	          }
	        });
	        return setTimeout(function() {
	          expect(cache.load('true')).to.be["null"];
	          return done();
	        }, 1100);
	      });
	      it('should expire "true" value after "first" value expire', function() {
	        cache.save('first', 'first');
	        cache.save('true', true, {
	          items: ['first']
	        });
	        cache.remove('first');
	        return expect(cache.load('true')).to.be["null"];
	      });
	      it('should expire all items with priority bellow 50', function() {
	        cache.save('one', 'one', {
	          priority: 100
	        });
	        cache.save('two', 'two', {
	          priority: 10
	        });
	        cache.clean({
	          priority: 50
	        });
	        expect(cache.load('one')).to.be.equal('one');
	        return expect(cache.load('two')).to.be["null"];
	      });
	      return it('should remove all items from cache', function() {
	        cache.save('one', 'one');
	        cache.save('two', 'two');
	        cache.clean('all');
	        expect(cache.load('one')).to.be["null"];
	        return expect(cache.load('two')).to.be["null"];
	      });
	    });
	  });
	
	}).call(this);
	

}, '/test/browser/tests/Storage/Sync/Storage.coffee': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/test/browser/tests/Storage/Sync/Storage.coffee');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/test/browser/tests/Storage/Sync/Storage.coffee';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/test/browser/tests/Storage/Sync/Storage.coffee';
	var __dirname = '/test/browser/tests/Storage/Sync';
	var process = {cwd: function() {return '/';}, argv: ['node', '/test/browser/tests/Storage/Sync/Storage.coffee'], env: {}};

	/** code **/
	(function() {
	  var Cache, Storage, cache, moment, storage;
	
	  Cache = require('cache-storage');
	
	  Storage = require('cache-storage/lib/Storage/Sync/Storage');
	
	  moment = require('moment');
	
	  cache = null;
	
	  storage = null;
	
	  describe('SyncStorage', function() {
	    beforeEach(function() {
	      storage = new Storage;
	      return cache = new Cache(storage);
	    });
	    describe('#verify()', function() {
	      it('should just return true', function() {
	        return expect(storage.verify('random variable')).to.be["true"];
	      });
	      it('should return false if meta expired', function() {
	        return expect(storage.verify({
	          expire: (new Date).getTime() - 200
	        })).to.be["false"];
	      });
	      it('should return false if dependent meta expired', function() {
	        storage.findMeta = function() {
	          return {
	            expire: (new Date).getTime() - 200
	          };
	        };
	        return expect(storage.verify({
	          items: ['test']
	        })).to.be["false"];
	      });
	      return it('should return false if file was changed', function(done) {
	        var files, meta;
	        files = {};
	        files[__filename] = window.require.getStats(__filename).mtime.getTime();
	        meta = {
	          files: files
	        };
	        return setTimeout(function() {
	          expect(storage.verify(meta)).to.be["true"];
	          changeFile(__filename);
	          expect(storage.verify(meta)).to.be["false"];
	          return done();
	        }, 100);
	      });
	    });
	    return describe('#parseDependencies()', function() {
	      it('should return empty object for unknown type of dependencies', function() {
	        return expect(storage.parseDependencies('random variable')).to.be.eql({});
	      });
	      it('should add priority into dependencies', function() {
	        return expect(storage.parseDependencies({
	          priority: 100
	        })).to.be.eql({
	          priority: 100
	        });
	      });
	      it('should add tags into dependencies', function() {
	        return expect(storage.parseDependencies({
	          tags: ['comment', 'article']
	        })).to.be.eql({
	          tags: ['comment', 'article']
	        });
	      });
	      it('should add dependent item into dependencies', function() {
	        return expect(storage.parseDependencies({
	          items: ['first', 'second']
	        })).to.be.eql({
	          items: [cache.generateKey('first'), cache.generateKey('second')]
	        });
	      });
	      it('should add date from string into dependencies', function() {
	        var time;
	        time = '2014-01-14 20:10';
	        return expect(storage.parseDependencies({
	          expire: time
	        })).to.be.eql({
	          expire: moment(time, Cache.TIME_FORMAT).valueOf()
	        });
	      });
	      return it('should add file into dependencies', function() {
	        var files;
	        files = {};
	        files[__filename] = window.require.getStats(__filename).mtime.getTime();
	        return expect(storage.parseDependencies({
	          files: [__filename]
	        })).to.be.eql({
	          files: files
	        });
	      });
	    });
	  });
	
	}).call(this);
	

}, '/package.json': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, '/package.json');};
	require.resolve = function(name, parent) {if (parent === null) {parent = '/package.json';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = '/package.json';
	var __dirname = '/';
	var process = {cwd: function() {return '/';}, argv: ['node', '/package.json'], env: {}};

	/** code **/
	module.exports = (function() {
	return {
		"name": "cache-storage",
		"description": "Advanced cache storage for node js",
		"version": "1.4.1",
		"author": {
			"name": "David Kudera",
			"email": "sakren@gmail.com"
		},
		"keywords": [
			"cache",
			"caching",
			"storage",
			"memory"
		],
		"repository": {
			"type": "git",
			"url": "git@github.com:sakren/node-cache-storage.git"
		},
		"license": "MIT",
		"engines": {
			"node": ">=0.9"
		},
		"main": "./lib/Cache.js",
		"dependencies": {
			"moment": "~2.5.0",
			"async": "~0.2.9",
			"redis": "~0.10.0"
		},
		"devDependencies": {
			"chai": "~1.8.1",
			"mocha": "~1.17.0",
			"mocha-phantomjs": "~3.3.1",
			"phantomjs": "~1.9.2-6",
			"fs-mock": "~1.0.1"
		},
		"scripts": {
			"test": "npm run test-node && npm run test-browser",
			"build-and-test": "npm run build-tests && npm run test",
			"build-tests": "coffee -co ./test/node/lib ./test/node/src; cd ./test/browser; simq build;",
			"test-node": "mocha ./test/node/index.js --reporter spec",
			"test-browser": "mocha-phantomjs ./test/browser/index.html"
		}
	}
	
	}).call(this);
	

}, 'moment/package.json': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'moment/package.json');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'moment/package.json';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'moment/package.json';
	var __dirname = 'moment';
	var process = {cwd: function() {return '/';}, argv: ['node', 'moment/package.json'], env: {}};

	/** code **/
	module.exports = (function() {
	return {
	  "name": "moment",
	  "version": "2.5.0",
	  "description": "Parse, manipulate, and display dates.",
	  "homepage": "http://momentjs.com",
	  "author": {
	    "name": "Iskren Ivov Chernev",
	    "email": "iskren.chernev@gmail.com",
	    "url": "https://github.com/ichernev"
	  },
	  "contributors": [
	    {
	      "name": "Tim Wood",
	      "email": "washwithcare@gmail.com",
	      "url": "http://timwoodcreates.com/"
	    },
	    {
	      "name": "Rocky Meza",
	      "url": "http://rockymeza.com"
	    },
	    {
	      "name": "Matt Johnson",
	      "email": "mj1856@hotmail.com",
	      "url": "http://codeofmatt.com"
	    },
	    {
	      "name": "Isaac Cambron",
	      "email": "isaac@isaaccambron.com",
	      "url": "http://drunkencoder.net/"
	    }
	  ],
	  "keywords": [
	    "moment",
	    "date",
	    "time",
	    "parse",
	    "format",
	    "validate",
	    "i18n",
	    "l10n",
	    "ender"
	  ],
	  "main": "./moment.js",
	  "engines": {
	    "node": "*"
	  },
	  "repository": {
	    "type": "git",
	    "url": "https://github.com/moment/moment.git"
	  },
	  "bugs": {
	    "url": "https://github.com/moment/moment/issues"
	  },
	  "licenses": [
	    {
	      "type": "MIT"
	    }
	  ],
	  "devDependencies": {
	    "uglify-js": "latest",
	    "grunt": "latest",
	    "nodeunit": "latest",
	    "grunt-contrib-jshint": "latest",
	    "grunt-contrib-nodeunit": "latest",
	    "grunt-contrib-concat": "latest",
	    "grunt-contrib-uglify": "latest",
	    "grunt-contrib-watch": "latest",
	    "grunt-lib-legacyhelpers": "latest"
	  },
	  "scripts": {
	    "test": "grunt"
	  },
	  "ender": "./ender.js",
	  "dojoBuild": "package.js",
	  "jspm": {
	    "files": [
	      "moment.js",
	      "lang"
	    ],
	    "map": {
	      "moment": "./moment"
	    },
	    "buildConfig": {
	      "uglify": true
	    }
	  },
	  "readme": "A lightweight javascript date library for parsing, validating, manipulating, and formatting dates.\n\n# [Documentation](http://momentjs.com/docs/)\n\nUpgrading to 2.0.0\n==================\n\nThere are a number of small backwards incompatible changes with version 2.0.0.\n\n[See them and their descriptions here](https://gist.github.com/timrwood/e72f2eef320ed9e37c51#backwards-incompatible-changes)\n\nChanged language ordinal method to return the number + ordinal instead of just the ordinal.\n\nChanged two digit year parsing cutoff to match strptime.\n\nRemoved `moment#sod` and `moment#eod` in favor of `moment#startOf` and `moment#endOf`.\n\nRemoved `moment.humanizeDuration()` in favor of `moment.duration().humanize()`.\n\nRemoved the lang data objects from the top level namespace.\n\nDuplicate `Date` passed to `moment()` instead of referencing it.\n\nTravis Build Status\n===================\n\nDevelop [![Build Status](https://travis-ci.org/moment/moment.png?branch=develop)](https://travis-ci.org/moment/moment)\n\nMaster [![Build Status](https://travis-ci.org/moment/moment.png?branch=master)](https://travis-ci.org/moment/moment)\n\nChangelog\n=========\n\n### 2.5.0 [See changelog](https://gist.github.com/ichernev/8104451)\n\n* New languages\n  * Luxemburish (lb) [1247](https://github.com/moment/moment/issues/1247)\n  * Serbian (rs) [1319](https://github.com/moment/moment/issues/1319)\n  * Tamil (ta) [1324](https://github.com/moment/moment/issues/1324)\n  * Macedonian (mk) [1337](https://github.com/moment/moment/issues/1337)\n\n* Features\n  * [1311](https://github.com/moment/moment/issues/1311) Add quarter getter and format token `Q`\n  * [1303](https://github.com/moment/moment/issues/1303) strict parsing now respects number of digits per token (fix [1196](https://github.com/moment/moment/issues/1196))\n  * 0d30bb7 add jspm support\n  * [1347](https://github.com/moment/moment/issues/1347) improve zone parsing\n  * [1362](https://github.com/moment/moment/issues/1362) support merideam parsing in Korean\n\n* 22 bugfixes\n\n### 2.4.0\n\n* **Deprecate** globally exported moment, will be removed in next major\n* New languages\n  * Farose (fo) [#1206](https://github.com/moment/moment/issues/1206)\n  * Tagalog/Filipino (tl-ph) [#1197](https://github.com/moment/moment/issues/1197)\n  * Welsh (cy) [#1215](https://github.com/moment/moment/issues/1215)\n* Bugfixes\n  * properly handle Z at the end of iso RegExp [#1187](https://github.com/moment/moment/issues/1187)\n  * chinese meridian time improvements [#1076](https://github.com/moment/moment/issues/1076)\n  * fix language tests [#1177](https://github.com/moment/moment/issues/1177)\n  * remove some failing tests (that should have never existed :))\n    [#1185](https://github.com/moment/moment/issues/1185)\n    [#1183](https://github.com/moment/moment/issues/1183)\n  * handle russian noun cases in weird cases [#1195](https://github.com/moment/moment/issues/1195)\n\n### 2.3.1\n\nRemoved a trailing comma [1169] and fixed a bug with `months`, `weekdays` getters [1171].\n\n### 2.3.0 [See changelog](https://gist.github.com/ichernev/6864354)\n\nChanged isValid, added strict parsing.\nWeek tokens parsing.\n\n### 2.2.1\n\nFixed bug in string prototype test.\nUpdated authors and contributors.\n\n### 2.2.0 [See changelog](https://gist.github.com/ichernev/00f837a9baf46a3565e4)\n\nAdded bower support.\n\nLanguage files now use UMD.\n\nCreating moment defaults to current date/month/year.\n\nAdded a bundle of moment and all language files.\n\n### 2.1.0 [See changelog](https://gist.github.com/timrwood/b8c2d90d528eddb53ab5)\n\nAdded better week support.\n\nAdded ability to set offset with `moment#zone`.\n\nAdded ability to set month or weekday from a string.\n\nAdded `moment#min` and `moment#max`\n\n### 2.0.0 [See changelog](https://gist.github.com/timrwood/e72f2eef320ed9e37c51)\n\nAdded short form localized tokens.\n\nAdded ability to define language a string should be parsed in.\n\nAdded support for reversed add/subtract arguments.\n\nAdded support for `endOf('week')` and `startOf('week')`.\n\nFixed the logic for `moment#diff(Moment, 'months')` and `moment#diff(Moment, 'years')`\n\n`moment#diff` now floors instead of rounds.\n\nNormalized `moment#toString`.\n\nAdded `isSame`, `isAfter`, and `isBefore` methods.\n\nAdded better week support.\n\nAdded `moment#toJSON`\n\nBugfix: Fixed parsing of first century dates\n\nBugfix: Parsing 10Sep2001 should work as expected\n\nBugfix: Fixed wierdness with `moment.utc()` parsing.\n\nChanged language ordinal method to return the number + ordinal instead of just the ordinal.\n\nChanged two digit year parsing cutoff to match strptime.\n\nRemoved `moment#sod` and `moment#eod` in favor of `moment#startOf` and `moment#endOf`.\n\nRemoved `moment.humanizeDuration()` in favor of `moment.duration().humanize()`.\n\nRemoved the lang data objects from the top level namespace.\n\nDuplicate `Date` passed to `moment()` instead of referencing it.\n\n### 1.7.2 [See discussion](https://github.com/timrwood/moment/issues/456)\n\nBugfixes\n\n### 1.7.1 [See discussion](https://github.com/timrwood/moment/issues/384)\n\nBugfixes\n\n### 1.7.0 [See discussion](https://github.com/timrwood/moment/issues/288)\n\nAdded `moment.fn.endOf()` and `moment.fn.startOf()`.\n\nAdded validation via `moment.fn.isValid()`.\n\nMade formatting method 3x faster. http://jsperf.com/momentjs-cached-format-functions\n\nAdd support for month/weekday callbacks in `moment.fn.format()`\n\nAdded instance specific languages.\n\nAdded two letter weekday abbreviations with the formatting token `dd`.\n\nVarious language updates.\n\nVarious bugfixes.\n\n### 1.6.0 [See discussion](https://github.com/timrwood/moment/pull/268)\n\nAdded Durations.\n\nRevamped parser to support parsing non-separated strings (YYYYMMDD vs YYYY-MM-DD).\n\nAdded support for millisecond parsing and formatting tokens (S SS SSS)\n\nAdded a getter for `moment.lang()`\n\nVarious bugfixes.\n\nThere are a few things deprecated in the 1.6.0 release.\n\n1. The format tokens `z` and `zz` (timezone abbreviations like EST CST MST etc) will no longer be supported. Due to inconsistent browser support, we are unable to consistently produce this value. See [this issue](https://github.com/timrwood/moment/issues/162) for more background.\n\n2. The method `moment.fn.native` is deprecated in favor of `moment.fn.toDate`. There continue to be issues with Google Closure Compiler throwing errors when using `native`, even in valid instances.\n\n3. The way to customize am/pm strings is being changed. This would only affect you if you created a custom language file. For more information, see [this issue](https://github.com/timrwood/moment/pull/222).\n\n### 1.5.0 [See milestone](https://github.com/timrwood/moment/issues?milestone=10&page=1&state=closed)\n\nAdded UTC mode.\n\nAdded automatic ISO8601 parsing.\n\nVarious bugfixes.\n\n### 1.4.0 [See milestone](https://github.com/timrwood/moment/issues?milestone=8&state=closed)\n\nAdded `moment.fn.toDate` as a replacement for `moment.fn.native`.\n\nAdded `moment.fn.sod` and `moment.fn.eod` to get the start and end of day.\n\nVarious bugfixes.\n\n### 1.3.0 [See milestone](https://github.com/timrwood/moment/issues?milestone=7&state=closed)\n\nAdded support for parsing month names in the current language.\n\nAdded escape blocks for parsing tokens.\n\nAdded `moment.fn.calendar` to format strings like 'Today 2:30 PM', 'Tomorrow 1:25 AM', and 'Last Sunday 4:30 AM'.\n\nAdded `moment.fn.day` as a setter.\n\nVarious bugfixes\n\n### 1.2.0 [See milestone](https://github.com/timrwood/moment/issues?milestone=4&state=closed)\n\nAdded timezones to parser and formatter.\n\nAdded `moment.fn.isDST`.\n\nAdded `moment.fn.zone` to get the timezone offset in minutes.\n\n### 1.1.2 [See milestone](https://github.com/timrwood/moment/issues?milestone=6&state=closed)\n\nVarious bugfixes\n\n### 1.1.1 [See milestone](https://github.com/timrwood/moment/issues?milestone=5&state=closed)\n\nAdded time specific diffs (months, days, hours, etc)\n\n### 1.1.0\n\nAdded `moment.fn.format` localized masks. 'L LL LLL LLLL' [issue 29](https://github.com/timrwood/moment/pull/29)\n\nFixed [issue 31](https://github.com/timrwood/moment/pull/31).\n\n### 1.0.1\n\nAdded `moment.version` to get the current version.\n\nRemoved `window !== undefined` when checking if module exists to support browserify. [issue 25](https://github.com/timrwood/moment/pull/25)\n\n### 1.0.0\n\nAdded convenience methods for getting and setting date parts.\n\nAdded better support for `moment.add()`.\n\nAdded better lang support in NodeJS.\n\nRenamed library from underscore.date to Moment.js\n\n### 0.6.1\n\nAdded Portuguese, Italian, and French language support\n\n### 0.6.0\n\nAdded _date.lang() support.\nAdded support for passing multiple formats to try to parse a date. _date(\"07-10-1986\", [\"MM-DD-YYYY\", \"YYYY-MM-DD\"]);\nMade parse from string and single format 25% faster.\n\n### 0.5.2\n\nBugfix for [issue 8](https://github.com/timrwood/underscore.date/pull/8) and [issue 9](https://github.com/timrwood/underscore.date/pull/9).\n\n### 0.5.1\n\nBugfix for [issue 5](https://github.com/timrwood/underscore.date/pull/5).\n\n### 0.5.0\n\nDropped the redundant `_date.date()` in favor of `_date()`.\nRemoved `_date.now()`, as it is a duplicate of `_date()` with no parameters.\nRemoved `_date.isLeapYear(yearNumber)`. Use `_date([yearNumber]).isLeapYear()` instead.\nExposed customization options through the `_date.relativeTime`, `_date.weekdays`, `_date.weekdaysShort`, `_date.months`, `_date.monthsShort`, and `_date.ordinal` variables instead of the `_date.customize()` function.\n\n### 0.4.1\n\nAdded date input formats for input strings.\n\n### 0.4.0\n\nAdded underscore.date to npm. Removed dependencies on underscore.\n\n### 0.3.2\n\nAdded `'z'` and `'zz'` to `_.date().format()`. Cleaned up some redundant code to trim off some bytes.\n\n### 0.3.1\n\nCleaned up the namespace. Moved all date manipulation and display functions to the _.date() object.\n\n### 0.3.0\n\nSwitched to the Underscore methodology of not mucking with the native objects' prototypes.\nMade chaining possible.\n\n### 0.2.1\n\nChanged date names to be a more pseudo standardized 'dddd, MMMM Do YYYY, h:mm:ss a'.\nAdded `Date.prototype` functions `add`, `subtract`, `isdst`, and `isleapyear`.\n\n### 0.2.0\n\nChanged function names to be more concise.\nChanged date format from php date format to custom format.\n\n### 0.1.0\n\nInitial release\n\nLicense\n=======\n\nMoment.js is freely distributable under the terms of the MIT license.\n",
	  "readmeFilename": "readme.md",
	  "_id": "moment@2.5.0",
	  "dist": {
	    "shasum": "d3d6346eb8144969a23f01727ec4c06578ec145a"
	  },
	  "_from": "moment@~2.5.0",
	  "_resolved": "https://registry.npmjs.org/moment/-/moment-2.5.0.tgz"
	}
	
	}).call(this);
	

}, 'async/package.json': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'async/package.json');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'async/package.json';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'async/package.json';
	var __dirname = 'async';
	var process = {cwd: function() {return '/';}, argv: ['node', 'async/package.json'], env: {}};

	/** code **/
	module.exports = (function() {
	return {
	  "name": "async",
	  "description": "Higher-order functions and common patterns for asynchronous code",
	  "main": "./lib/async",
	  "author": {
	    "name": "Caolan McMahon"
	  },
	  "version": "0.2.9",
	  "repository": {
	    "type": "git",
	    "url": "https://github.com/caolan/async.git"
	  },
	  "bugs": {
	    "url": "https://github.com/caolan/async/issues"
	  },
	  "licenses": [
	    {
	      "type": "MIT",
	      "url": "https://github.com/caolan/async/raw/master/LICENSE"
	    }
	  ],
	  "devDependencies": {
	    "nodeunit": ">0.0.0",
	    "uglify-js": "1.2.x",
	    "nodelint": ">0.0.0"
	  },
	  "jam": {
	    "main": "lib/async.js",
	    "include": [
	      "lib/async.js",
	      "README.md",
	      "LICENSE"
	    ]
	  },
	  "scripts": {
	    "test": "nodeunit test/test-async.js"
	  },
	  "readme": "# Async.js\n\nAsync is a utility module which provides straight-forward, powerful functions\nfor working with asynchronous JavaScript. Although originally designed for\nuse with [node.js](http://nodejs.org), it can also be used directly in the\nbrowser. Also supports [component](https://github.com/component/component).\n\nAsync provides around 20 functions that include the usual 'functional'\nsuspects (map, reduce, filter, each…) as well as some common patterns\nfor asynchronous control flow (parallel, series, waterfall…). All these\nfunctions assume you follow the node.js convention of providing a single\ncallback as the last argument of your async function.\n\n\n## Quick Examples\n\n```javascript\nasync.map(['file1','file2','file3'], fs.stat, function(err, results){\n    // results is now an array of stats for each file\n});\n\nasync.filter(['file1','file2','file3'], fs.exists, function(results){\n    // results now equals an array of the existing files\n});\n\nasync.parallel([\n    function(){ ... },\n    function(){ ... }\n], callback);\n\nasync.series([\n    function(){ ... },\n    function(){ ... }\n]);\n```\n\nThere are many more functions available so take a look at the docs below for a\nfull list. This module aims to be comprehensive, so if you feel anything is\nmissing please create a GitHub issue for it.\n\n## Common Pitfalls\n\n### Binding a context to an iterator\n\nThis section is really about bind, not about async. If you are wondering how to\nmake async execute your iterators in a given context, or are confused as to why\na method of another library isn't working as an iterator, study this example:\n\n```js\n// Here is a simple object with an (unnecessarily roundabout) squaring method\nvar AsyncSquaringLibrary = {\n  squareExponent: 2,\n  square: function(number, callback){ \n    var result = Math.pow(number, this.squareExponent);\n    setTimeout(function(){\n      callback(null, result);\n    }, 200);\n  }\n};\n\nasync.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){\n  // result is [NaN, NaN, NaN]\n  // This fails because the `this.squareExponent` expression in the square\n  // function is not evaluated in the context of AsyncSquaringLibrary, and is\n  // therefore undefined.\n});\n\nasync.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){\n  // result is [1, 4, 9]\n  // With the help of bind we can attach a context to the iterator before\n  // passing it to async. Now the square function will be executed in its \n  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`\n  // will be as expected.\n});\n```\n\n## Download\n\nThe source is available for download from\n[GitHub](http://github.com/caolan/async).\nAlternatively, you can install using Node Package Manager (npm):\n\n    npm install async\n\n__Development:__ [async.js](https://github.com/caolan/async/raw/master/lib/async.js) - 29.6kb Uncompressed\n\n## In the Browser\n\nSo far it's been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. Usage:\n\n```html\n<script type=\"text/javascript\" src=\"async.js\"></script>\n<script type=\"text/javascript\">\n\n    async.map(data, asyncProcess, function(err, results){\n        alert(results);\n    });\n\n</script>\n```\n\n## Documentation\n\n### Collections\n\n* [each](#each)\n* [map](#map)\n* [filter](#filter)\n* [reject](#reject)\n* [reduce](#reduce)\n* [detect](#detect)\n* [sortBy](#sortBy)\n* [some](#some)\n* [every](#every)\n* [concat](#concat)\n\n### Control Flow\n\n* [series](#series)\n* [parallel](#parallel)\n* [whilst](#whilst)\n* [doWhilst](#doWhilst)\n* [until](#until)\n* [doUntil](#doUntil)\n* [forever](#forever)\n* [waterfall](#waterfall)\n* [compose](#compose)\n* [applyEach](#applyEach)\n* [queue](#queue)\n* [cargo](#cargo)\n* [auto](#auto)\n* [iterator](#iterator)\n* [apply](#apply)\n* [nextTick](#nextTick)\n* [times](#times)\n* [timesSeries](#timesSeries)\n\n### Utils\n\n* [memoize](#memoize)\n* [unmemoize](#unmemoize)\n* [log](#log)\n* [dir](#dir)\n* [noConflict](#noConflict)\n\n\n## Collections\n\n<a name=\"forEach\" />\n<a name=\"each\" />\n### each(arr, iterator, callback)\n\nApplies an iterator function to each item in an array, in parallel.\nThe iterator is called with an item from the list and a callback for when it\nhas finished. If the iterator passes an error to this callback, the main\ncallback for the each function is immediately called with the error.\n\nNote, that since this function applies the iterator to each item in parallel\nthere is no guarantee that the iterator functions will complete in order.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* iterator(item, callback) - A function to apply to each item in the array.\n  The iterator is passed a callback(err) which must be called once it has \n  completed. If no error has occured, the callback should be run without \n  arguments or with an explicit null argument.\n* callback(err) - A callback which is called after all the iterator functions\n  have finished, or an error has occurred.\n\n__Example__\n\n```js\n// assuming openFiles is an array of file names and saveFile is a function\n// to save the modified contents of that file:\n\nasync.each(openFiles, saveFile, function(err){\n    // if any of the saves produced an error, err would equal that error\n});\n```\n\n---------------------------------------\n\n<a name=\"forEachSeries\" />\n<a name=\"eachSeries\" />\n### eachSeries(arr, iterator, callback)\n\nThe same as each only the iterator is applied to each item in the array in\nseries. The next iterator is only called once the current one has completed\nprocessing. This means the iterator functions will complete in order.\n\n\n---------------------------------------\n\n<a name=\"forEachLimit\" />\n<a name=\"eachLimit\" />\n### eachLimit(arr, limit, iterator, callback)\n\nThe same as each only no more than \"limit\" iterators will be simultaneously \nrunning at any time.\n\nNote that the items are not processed in batches, so there is no guarantee that\n the first \"limit\" iterator functions will complete before any others are \nstarted.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* limit - The maximum number of iterators to run at any time.\n* iterator(item, callback) - A function to apply to each item in the array.\n  The iterator is passed a callback(err) which must be called once it has \n  completed. If no error has occured, the callback should be run without \n  arguments or with an explicit null argument.\n* callback(err) - A callback which is called after all the iterator functions\n  have finished, or an error has occurred.\n\n__Example__\n\n```js\n// Assume documents is an array of JSON objects and requestApi is a\n// function that interacts with a rate-limited REST api.\n\nasync.eachLimit(documents, 20, requestApi, function(err){\n    // if any of the saves produced an error, err would equal that error\n});\n```\n\n---------------------------------------\n\n<a name=\"map\" />\n### map(arr, iterator, callback)\n\nProduces a new array of values by mapping each value in the given array through\nthe iterator function. The iterator is called with an item from the array and a\ncallback for when it has finished processing. The callback takes 2 arguments, \nan error and the transformed item from the array. If the iterator passes an\nerror to this callback, the main callback for the map function is immediately\ncalled with the error.\n\nNote, that since this function applies the iterator to each item in parallel\nthere is no guarantee that the iterator functions will complete in order, however\nthe results array will be in the same order as the original array.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* iterator(item, callback) - A function to apply to each item in the array.\n  The iterator is passed a callback(err, transformed) which must be called once \n  it has completed with an error (which can be null) and a transformed item.\n* callback(err, results) - A callback which is called after all the iterator\n  functions have finished, or an error has occurred. Results is an array of the\n  transformed items from the original array.\n\n__Example__\n\n```js\nasync.map(['file1','file2','file3'], fs.stat, function(err, results){\n    // results is now an array of stats for each file\n});\n```\n\n---------------------------------------\n\n<a name=\"mapSeries\" />\n### mapSeries(arr, iterator, callback)\n\nThe same as map only the iterator is applied to each item in the array in\nseries. The next iterator is only called once the current one has completed\nprocessing. The results array will be in the same order as the original.\n\n\n---------------------------------------\n\n<a name=\"mapLimit\" />\n### mapLimit(arr, limit, iterator, callback)\n\nThe same as map only no more than \"limit\" iterators will be simultaneously \nrunning at any time.\n\nNote that the items are not processed in batches, so there is no guarantee that\n the first \"limit\" iterator functions will complete before any others are \nstarted.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* limit - The maximum number of iterators to run at any time.\n* iterator(item, callback) - A function to apply to each item in the array.\n  The iterator is passed a callback(err, transformed) which must be called once \n  it has completed with an error (which can be null) and a transformed item.\n* callback(err, results) - A callback which is called after all the iterator\n  functions have finished, or an error has occurred. Results is an array of the\n  transformed items from the original array.\n\n__Example__\n\n```js\nasync.map(['file1','file2','file3'], 1, fs.stat, function(err, results){\n    // results is now an array of stats for each file\n});\n```\n\n---------------------------------------\n\n<a name=\"filter\" />\n### filter(arr, iterator, callback)\n\n__Alias:__ select\n\nReturns a new array of all the values which pass an async truth test.\n_The callback for each iterator call only accepts a single argument of true or\nfalse, it does not accept an error argument first!_ This is in-line with the\nway node libraries work with truth tests like fs.exists. This operation is\nperformed in parallel, but the results array will be in the same order as the\noriginal.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* iterator(item, callback) - A truth test to apply to each item in the array.\n  The iterator is passed a callback(truthValue) which must be called with a \n  boolean argument once it has completed.\n* callback(results) - A callback which is called after all the iterator\n  functions have finished.\n\n__Example__\n\n```js\nasync.filter(['file1','file2','file3'], fs.exists, function(results){\n    // results now equals an array of the existing files\n});\n```\n\n---------------------------------------\n\n<a name=\"filterSeries\" />\n### filterSeries(arr, iterator, callback)\n\n__alias:__ selectSeries\n\nThe same as filter only the iterator is applied to each item in the array in\nseries. The next iterator is only called once the current one has completed\nprocessing. The results array will be in the same order as the original.\n\n---------------------------------------\n\n<a name=\"reject\" />\n### reject(arr, iterator, callback)\n\nThe opposite of filter. Removes values that pass an async truth test.\n\n---------------------------------------\n\n<a name=\"rejectSeries\" />\n### rejectSeries(arr, iterator, callback)\n\nThe same as reject, only the iterator is applied to each item in the array\nin series.\n\n\n---------------------------------------\n\n<a name=\"reduce\" />\n### reduce(arr, memo, iterator, callback)\n\n__aliases:__ inject, foldl\n\nReduces a list of values into a single value using an async iterator to return\neach successive step. Memo is the initial state of the reduction. This\nfunction only operates in series. For performance reasons, it may make sense to\nsplit a call to this function into a parallel map, then use the normal\nArray.prototype.reduce on the results. This function is for situations where\neach step in the reduction needs to be async, if you can get the data before\nreducing it then it's probably a good idea to do so.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* memo - The initial state of the reduction.\n* iterator(memo, item, callback) - A function applied to each item in the\n  array to produce the next step in the reduction. The iterator is passed a\n  callback(err, reduction) which accepts an optional error as its first \n  argument, and the state of the reduction as the second. If an error is \n  passed to the callback, the reduction is stopped and the main callback is \n  immediately called with the error.\n* callback(err, result) - A callback which is called after all the iterator\n  functions have finished. Result is the reduced value.\n\n__Example__\n\n```js\nasync.reduce([1,2,3], 0, function(memo, item, callback){\n    // pointless async:\n    process.nextTick(function(){\n        callback(null, memo + item)\n    });\n}, function(err, result){\n    // result is now equal to the last value of memo, which is 6\n});\n```\n\n---------------------------------------\n\n<a name=\"reduceRight\" />\n### reduceRight(arr, memo, iterator, callback)\n\n__Alias:__ foldr\n\nSame as reduce, only operates on the items in the array in reverse order.\n\n\n---------------------------------------\n\n<a name=\"detect\" />\n### detect(arr, iterator, callback)\n\nReturns the first value in a list that passes an async truth test. The\niterator is applied in parallel, meaning the first iterator to return true will\nfire the detect callback with that result. That means the result might not be\nthe first item in the original array (in terms of order) that passes the test.\n\nIf order within the original array is important then look at detectSeries.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* iterator(item, callback) - A truth test to apply to each item in the array.\n  The iterator is passed a callback(truthValue) which must be called with a \n  boolean argument once it has completed.\n* callback(result) - A callback which is called as soon as any iterator returns\n  true, or after all the iterator functions have finished. Result will be\n  the first item in the array that passes the truth test (iterator) or the\n  value undefined if none passed.\n\n__Example__\n\n```js\nasync.detect(['file1','file2','file3'], fs.exists, function(result){\n    // result now equals the first file in the list that exists\n});\n```\n\n---------------------------------------\n\n<a name=\"detectSeries\" />\n### detectSeries(arr, iterator, callback)\n\nThe same as detect, only the iterator is applied to each item in the array\nin series. This means the result is always the first in the original array (in\nterms of array order) that passes the truth test.\n\n\n---------------------------------------\n\n<a name=\"sortBy\" />\n### sortBy(arr, iterator, callback)\n\nSorts a list by the results of running each value through an async iterator.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* iterator(item, callback) - A function to apply to each item in the array.\n  The iterator is passed a callback(err, sortValue) which must be called once it\n  has completed with an error (which can be null) and a value to use as the sort\n  criteria.\n* callback(err, results) - A callback which is called after all the iterator\n  functions have finished, or an error has occurred. Results is the items from\n  the original array sorted by the values returned by the iterator calls.\n\n__Example__\n\n```js\nasync.sortBy(['file1','file2','file3'], function(file, callback){\n    fs.stat(file, function(err, stats){\n        callback(err, stats.mtime);\n    });\n}, function(err, results){\n    // results is now the original array of files sorted by\n    // modified date\n});\n```\n\n---------------------------------------\n\n<a name=\"some\" />\n### some(arr, iterator, callback)\n\n__Alias:__ any\n\nReturns true if at least one element in the array satisfies an async test.\n_The callback for each iterator call only accepts a single argument of true or\nfalse, it does not accept an error argument first!_ This is in-line with the\nway node libraries work with truth tests like fs.exists. Once any iterator\ncall returns true, the main callback is immediately called.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* iterator(item, callback) - A truth test to apply to each item in the array.\n  The iterator is passed a callback(truthValue) which must be called with a \n  boolean argument once it has completed.\n* callback(result) - A callback which is called as soon as any iterator returns\n  true, or after all the iterator functions have finished. Result will be\n  either true or false depending on the values of the async tests.\n\n__Example__\n\n```js\nasync.some(['file1','file2','file3'], fs.exists, function(result){\n    // if result is true then at least one of the files exists\n});\n```\n\n---------------------------------------\n\n<a name=\"every\" />\n### every(arr, iterator, callback)\n\n__Alias:__ all\n\nReturns true if every element in the array satisfies an async test.\n_The callback for each iterator call only accepts a single argument of true or\nfalse, it does not accept an error argument first!_ This is in-line with the\nway node libraries work with truth tests like fs.exists.\n\n__Arguments__\n\n* arr - An array to iterate over.\n* iterator(item, callback) - A truth test to apply to each item in the array.\n  The iterator is passed a callback(truthValue) which must be called with a \n  boolean argument once it has completed.\n* callback(result) - A callback which is called after all the iterator\n  functions have finished. Result will be either true or false depending on\n  the values of the async tests.\n\n__Example__\n\n```js\nasync.every(['file1','file2','file3'], fs.exists, function(result){\n    // if result is true then every file exists\n});\n```\n\n---------------------------------------\n\n<a name=\"concat\" />\n### concat(arr, iterator, callback)\n\nApplies an iterator to each item in a list, concatenating the results. Returns the\nconcatenated list. The iterators are called in parallel, and the results are\nconcatenated as they return. There is no guarantee that the results array will\nbe returned in the original order of the arguments passed to the iterator function.\n\n__Arguments__\n\n* arr - An array to iterate over\n* iterator(item, callback) - A function to apply to each item in the array.\n  The iterator is passed a callback(err, results) which must be called once it \n  has completed with an error (which can be null) and an array of results.\n* callback(err, results) - A callback which is called after all the iterator\n  functions have finished, or an error has occurred. Results is an array containing\n  the concatenated results of the iterator function.\n\n__Example__\n\n```js\nasync.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){\n    // files is now a list of filenames that exist in the 3 directories\n});\n```\n\n---------------------------------------\n\n<a name=\"concatSeries\" />\n### concatSeries(arr, iterator, callback)\n\nSame as async.concat, but executes in series instead of parallel.\n\n\n## Control Flow\n\n<a name=\"series\" />\n### series(tasks, [callback])\n\nRun an array of functions in series, each one running once the previous\nfunction has completed. If any functions in the series pass an error to its\ncallback, no more functions are run and the callback for the series is\nimmediately called with the value of the error. Once the tasks have completed,\nthe results are passed to the final callback as an array.\n\nIt is also possible to use an object instead of an array. Each property will be\nrun as a function and the results will be passed to the final callback as an object\ninstead of an array. This can be a more readable way of handling results from\nasync.series.\n\n\n__Arguments__\n\n* tasks - An array or object containing functions to run, each function is passed\n  a callback(err, result) it must call on completion with an error (which can\n  be null) and an optional result value.\n* callback(err, results) - An optional callback to run once all the functions\n  have completed. This function gets a results array (or object) containing all \n  the result arguments passed to the task callbacks.\n\n__Example__\n\n```js\nasync.series([\n    function(callback){\n        // do some stuff ...\n        callback(null, 'one');\n    },\n    function(callback){\n        // do some more stuff ...\n        callback(null, 'two');\n    }\n],\n// optional callback\nfunction(err, results){\n    // results is now equal to ['one', 'two']\n});\n\n\n// an example using an object instead of an array\nasync.series({\n    one: function(callback){\n        setTimeout(function(){\n            callback(null, 1);\n        }, 200);\n    },\n    two: function(callback){\n        setTimeout(function(){\n            callback(null, 2);\n        }, 100);\n    }\n},\nfunction(err, results) {\n    // results is now equal to: {one: 1, two: 2}\n});\n```\n\n---------------------------------------\n\n<a name=\"parallel\" />\n### parallel(tasks, [callback])\n\nRun an array of functions in parallel, without waiting until the previous\nfunction has completed. If any of the functions pass an error to its\ncallback, the main callback is immediately called with the value of the error.\nOnce the tasks have completed, the results are passed to the final callback as an\narray.\n\nIt is also possible to use an object instead of an array. Each property will be\nrun as a function and the results will be passed to the final callback as an object\ninstead of an array. This can be a more readable way of handling results from\nasync.parallel.\n\n\n__Arguments__\n\n* tasks - An array or object containing functions to run, each function is passed \n  a callback(err, result) it must call on completion with an error (which can\n  be null) and an optional result value.\n* callback(err, results) - An optional callback to run once all the functions\n  have completed. This function gets a results array (or object) containing all \n  the result arguments passed to the task callbacks.\n\n__Example__\n\n```js\nasync.parallel([\n    function(callback){\n        setTimeout(function(){\n            callback(null, 'one');\n        }, 200);\n    },\n    function(callback){\n        setTimeout(function(){\n            callback(null, 'two');\n        }, 100);\n    }\n],\n// optional callback\nfunction(err, results){\n    // the results array will equal ['one','two'] even though\n    // the second function had a shorter timeout.\n});\n\n\n// an example using an object instead of an array\nasync.parallel({\n    one: function(callback){\n        setTimeout(function(){\n            callback(null, 1);\n        }, 200);\n    },\n    two: function(callback){\n        setTimeout(function(){\n            callback(null, 2);\n        }, 100);\n    }\n},\nfunction(err, results) {\n    // results is now equals to: {one: 1, two: 2}\n});\n```\n\n---------------------------------------\n\n<a name=\"parallel\" />\n### parallelLimit(tasks, limit, [callback])\n\nThe same as parallel only the tasks are executed in parallel with a maximum of \"limit\" \ntasks executing at any time.\n\nNote that the tasks are not executed in batches, so there is no guarantee that \nthe first \"limit\" tasks will complete before any others are started.\n\n__Arguments__\n\n* tasks - An array or object containing functions to run, each function is passed \n  a callback(err, result) it must call on completion with an error (which can\n  be null) and an optional result value.\n* limit - The maximum number of tasks to run at any time.\n* callback(err, results) - An optional callback to run once all the functions\n  have completed. This function gets a results array (or object) containing all \n  the result arguments passed to the task callbacks.\n\n---------------------------------------\n\n<a name=\"whilst\" />\n### whilst(test, fn, callback)\n\nRepeatedly call fn, while test returns true. Calls the callback when stopped,\nor an error occurs.\n\n__Arguments__\n\n* test() - synchronous truth test to perform before each execution of fn.\n* fn(callback) - A function to call each time the test passes. The function is\n  passed a callback(err) which must be called once it has completed with an \n  optional error argument.\n* callback(err) - A callback which is called after the test fails and repeated\n  execution of fn has stopped.\n\n__Example__\n\n```js\nvar count = 0;\n\nasync.whilst(\n    function () { return count < 5; },\n    function (callback) {\n        count++;\n        setTimeout(callback, 1000);\n    },\n    function (err) {\n        // 5 seconds have passed\n    }\n);\n```\n\n---------------------------------------\n\n<a name=\"doWhilst\" />\n### doWhilst(fn, test, callback)\n\nThe post check version of whilst. To reflect the difference in the order of operations `test` and `fn` arguments are switched. `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n\n---------------------------------------\n\n<a name=\"until\" />\n### until(test, fn, callback)\n\nRepeatedly call fn, until test returns true. Calls the callback when stopped,\nor an error occurs.\n\nThe inverse of async.whilst.\n\n---------------------------------------\n\n<a name=\"doUntil\" />\n### doUntil(fn, test, callback)\n\nLike doWhilst except the test is inverted. Note the argument ordering differs from `until`.\n\n---------------------------------------\n\n<a name=\"forever\" />\n### forever(fn, callback)\n\nCalls the asynchronous function 'fn' repeatedly, in series, indefinitely.\nIf an error is passed to fn's callback then 'callback' is called with the\nerror, otherwise it will never be called.\n\n---------------------------------------\n\n<a name=\"waterfall\" />\n### waterfall(tasks, [callback])\n\nRuns an array of functions in series, each passing their results to the next in\nthe array. However, if any of the functions pass an error to the callback, the\nnext function is not executed and the main callback is immediately called with\nthe error.\n\n__Arguments__\n\n* tasks - An array of functions to run, each function is passed a \n  callback(err, result1, result2, ...) it must call on completion. The first\n  argument is an error (which can be null) and any further arguments will be \n  passed as arguments in order to the next task.\n* callback(err, [results]) - An optional callback to run once all the functions\n  have completed. This will be passed the results of the last task's callback.\n\n\n\n__Example__\n\n```js\nasync.waterfall([\n    function(callback){\n        callback(null, 'one', 'two');\n    },\n    function(arg1, arg2, callback){\n        callback(null, 'three');\n    },\n    function(arg1, callback){\n        // arg1 now equals 'three'\n        callback(null, 'done');\n    }\n], function (err, result) {\n   // result now equals 'done'    \n});\n```\n\n---------------------------------------\n<a name=\"compose\" />\n### compose(fn1, fn2...)\n\nCreates a function which is a composition of the passed asynchronous\nfunctions. Each function consumes the return value of the function that\nfollows. Composing functions f(), g() and h() would produce the result of\nf(g(h())), only this version uses callbacks to obtain the return values.\n\nEach function is executed with the `this` binding of the composed function.\n\n__Arguments__\n\n* functions... - the asynchronous functions to compose\n\n\n__Example__\n\n```js\nfunction add1(n, callback) {\n    setTimeout(function () {\n        callback(null, n + 1);\n    }, 10);\n}\n\nfunction mul3(n, callback) {\n    setTimeout(function () {\n        callback(null, n * 3);\n    }, 10);\n}\n\nvar add1mul3 = async.compose(mul3, add1);\n\nadd1mul3(4, function (err, result) {\n   // result now equals 15\n});\n```\n\n---------------------------------------\n<a name=\"applyEach\" />\n### applyEach(fns, args..., callback)\n\nApplies the provided arguments to each function in the array, calling the\ncallback after all functions have completed. If you only provide the first\nargument then it will return a function which lets you pass in the\narguments as if it were a single function call.\n\n__Arguments__\n\n* fns - the asynchronous functions to all call with the same arguments\n* args... - any number of separate arguments to pass to the function\n* callback - the final argument should be the callback, called when all\n  functions have completed processing\n\n\n__Example__\n\n```js\nasync.applyEach([enableSearch, updateSchema], 'bucket', callback);\n\n// partial application example:\nasync.each(\n    buckets,\n    async.applyEach([enableSearch, updateSchema]),\n    callback\n);\n```\n\n---------------------------------------\n\n<a name=\"applyEachSeries\" />\n### applyEachSeries(arr, iterator, callback)\n\nThe same as applyEach only the functions are applied in series.\n\n---------------------------------------\n\n<a name=\"queue\" />\n### queue(worker, concurrency)\n\nCreates a queue object with the specified concurrency. Tasks added to the\nqueue will be processed in parallel (up to the concurrency limit). If all\nworkers are in progress, the task is queued until one is available. Once\na worker has completed a task, the task's callback is called.\n\n__Arguments__\n\n* worker(task, callback) - An asynchronous function for processing a queued\n  task, which must call its callback(err) argument when finished, with an \n  optional error as an argument.\n* concurrency - An integer for determining how many worker functions should be\n  run in parallel.\n\n__Queue objects__\n\nThe queue object returned by this function has the following properties and\nmethods:\n\n* length() - a function returning the number of items waiting to be processed.\n* concurrency - an integer for determining how many worker functions should be\n  run in parallel. This property can be changed after a queue is created to\n  alter the concurrency on-the-fly.\n* push(task, [callback]) - add a new task to the queue, the callback is called\n  once the worker has finished processing the task.\n  instead of a single task, an array of tasks can be submitted. the respective callback is used for every task in the list.\n* unshift(task, [callback]) - add a new task to the front of the queue.\n* saturated - a callback that is called when the queue length hits the concurrency and further tasks will be queued\n* empty - a callback that is called when the last item from the queue is given to a worker\n* drain - a callback that is called when the last item from the queue has returned from the worker\n\n__Example__\n\n```js\n// create a queue object with concurrency 2\n\nvar q = async.queue(function (task, callback) {\n    console.log('hello ' + task.name);\n    callback();\n}, 2);\n\n\n// assign a callback\nq.drain = function() {\n    console.log('all items have been processed');\n}\n\n// add some items to the queue\n\nq.push({name: 'foo'}, function (err) {\n    console.log('finished processing foo');\n});\nq.push({name: 'bar'}, function (err) {\n    console.log('finished processing bar');\n});\n\n// add some items to the queue (batch-wise)\n\nq.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {\n    console.log('finished processing bar');\n});\n\n// add some items to the front of the queue\n\nq.unshift({name: 'bar'}, function (err) {\n    console.log('finished processing bar');\n});\n```\n\n---------------------------------------\n\n<a name=\"cargo\" />\n### cargo(worker, [payload])\n\nCreates a cargo object with the specified payload. Tasks added to the\ncargo will be processed altogether (up to the payload limit). If the\nworker is in progress, the task is queued until it is available. Once\nthe worker has completed some tasks, each callback of those tasks is called.\n\n__Arguments__\n\n* worker(tasks, callback) - An asynchronous function for processing an array of\n  queued tasks, which must call its callback(err) argument when finished, with \n  an optional error as an argument.\n* payload - An optional integer for determining how many tasks should be\n  processed per round; if omitted, the default is unlimited.\n\n__Cargo objects__\n\nThe cargo object returned by this function has the following properties and\nmethods:\n\n* length() - a function returning the number of items waiting to be processed.\n* payload - an integer for determining how many tasks should be\n  process per round. This property can be changed after a cargo is created to\n  alter the payload on-the-fly.\n* push(task, [callback]) - add a new task to the queue, the callback is called\n  once the worker has finished processing the task.\n  instead of a single task, an array of tasks can be submitted. the respective callback is used for every task in the list.\n* saturated - a callback that is called when the queue length hits the concurrency and further tasks will be queued\n* empty - a callback that is called when the last item from the queue is given to a worker\n* drain - a callback that is called when the last item from the queue has returned from the worker\n\n__Example__\n\n```js\n// create a cargo object with payload 2\n\nvar cargo = async.cargo(function (tasks, callback) {\n    for(var i=0; i<tasks.length; i++){\n      console.log('hello ' + tasks[i].name);\n    }\n    callback();\n}, 2);\n\n\n// add some items\n\ncargo.push({name: 'foo'}, function (err) {\n    console.log('finished processing foo');\n});\ncargo.push({name: 'bar'}, function (err) {\n    console.log('finished processing bar');\n});\ncargo.push({name: 'baz'}, function (err) {\n    console.log('finished processing baz');\n});\n```\n\n---------------------------------------\n\n<a name=\"auto\" />\n### auto(tasks, [callback])\n\nDetermines the best order for running functions based on their requirements.\nEach function can optionally depend on other functions being completed first,\nand each function is run as soon as its requirements are satisfied. If any of\nthe functions pass an error to their callback, that function will not complete\n(so any other functions depending on it will not run) and the main callback\nwill be called immediately with the error. Functions also receive an object\ncontaining the results of functions which have completed so far.\n\nNote, all functions are called with a results object as a second argument, \nso it is unsafe to pass functions in the tasks object which cannot handle the\nextra argument. For example, this snippet of code:\n\n```js\nasync.auto({\n  readData: async.apply(fs.readFile, 'data.txt', 'utf-8');\n}, callback);\n```\n\nwill have the effect of calling readFile with the results object as the last\nargument, which will fail:\n\n```js\nfs.readFile('data.txt', 'utf-8', cb, {});\n```\n\nInstead, wrap the call to readFile in a function which does not forward the \nresults object:\n\n```js\nasync.auto({\n  readData: function(cb, results){\n    fs.readFile('data.txt', 'utf-8', cb);\n  }\n}, callback);\n```\n\n__Arguments__\n\n* tasks - An object literal containing named functions or an array of\n  requirements, with the function itself the last item in the array. The key\n  used for each function or array is used when specifying requirements. The \n  function receives two arguments: (1) a callback(err, result) which must be \n  called when finished, passing an error (which can be null) and the result of \n  the function's execution, and (2) a results object, containing the results of\n  the previously executed functions.\n* callback(err, results) - An optional callback which is called when all the\n  tasks have been completed. The callback will receive an error as an argument\n  if any tasks pass an error to their callback. Results will always be passed\n\tbut if an error occurred, no other tasks will be performed, and the results\n\tobject will only contain partial results.\n  \n\n__Example__\n\n```js\nasync.auto({\n    get_data: function(callback){\n        // async code to get some data\n    },\n    make_folder: function(callback){\n        // async code to create a directory to store a file in\n        // this is run at the same time as getting the data\n    },\n    write_file: ['get_data', 'make_folder', function(callback){\n        // once there is some data and the directory exists,\n        // write the data to a file in the directory\n        callback(null, filename);\n    }],\n    email_link: ['write_file', function(callback, results){\n        // once the file is written let's email a link to it...\n        // results.write_file contains the filename returned by write_file.\n    }]\n});\n```\n\nThis is a fairly trivial example, but to do this using the basic parallel and\nseries functions would look like this:\n\n```js\nasync.parallel([\n    function(callback){\n        // async code to get some data\n    },\n    function(callback){\n        // async code to create a directory to store a file in\n        // this is run at the same time as getting the data\n    }\n],\nfunction(err, results){\n    async.series([\n        function(callback){\n            // once there is some data and the directory exists,\n            // write the data to a file in the directory\n        },\n        function(callback){\n            // once the file is written let's email a link to it...\n        }\n    ]);\n});\n```\n\nFor a complicated series of async tasks using the auto function makes adding\nnew tasks much easier and makes the code more readable.\n\n\n---------------------------------------\n\n<a name=\"iterator\" />\n### iterator(tasks)\n\nCreates an iterator function which calls the next function in the array,\nreturning a continuation to call the next one after that. It's also possible to\n'peek' the next iterator by doing iterator.next().\n\nThis function is used internally by the async module but can be useful when\nyou want to manually control the flow of functions in series.\n\n__Arguments__\n\n* tasks - An array of functions to run.\n\n__Example__\n\n```js\nvar iterator = async.iterator([\n    function(){ sys.p('one'); },\n    function(){ sys.p('two'); },\n    function(){ sys.p('three'); }\n]);\n\nnode> var iterator2 = iterator();\n'one'\nnode> var iterator3 = iterator2();\n'two'\nnode> iterator3();\n'three'\nnode> var nextfn = iterator2.next();\nnode> nextfn();\n'three'\n```\n\n---------------------------------------\n\n<a name=\"apply\" />\n### apply(function, arguments..)\n\nCreates a continuation function with some arguments already applied, a useful\nshorthand when combined with other control flow functions. Any arguments\npassed to the returned function are added to the arguments originally passed\nto apply.\n\n__Arguments__\n\n* function - The function you want to eventually apply all arguments to.\n* arguments... - Any number of arguments to automatically apply when the\n  continuation is called.\n\n__Example__\n\n```js\n// using apply\n\nasync.parallel([\n    async.apply(fs.writeFile, 'testfile1', 'test1'),\n    async.apply(fs.writeFile, 'testfile2', 'test2'),\n]);\n\n\n// the same process without using apply\n\nasync.parallel([\n    function(callback){\n        fs.writeFile('testfile1', 'test1', callback);\n    },\n    function(callback){\n        fs.writeFile('testfile2', 'test2', callback);\n    }\n]);\n```\n\nIt's possible to pass any number of additional arguments when calling the\ncontinuation:\n\n```js\nnode> var fn = async.apply(sys.puts, 'one');\nnode> fn('two', 'three');\none\ntwo\nthree\n```\n\n---------------------------------------\n\n<a name=\"nextTick\" />\n### nextTick(callback)\n\nCalls the callback on a later loop around the event loop. In node.js this just\ncalls process.nextTick, in the browser it falls back to setImmediate(callback)\nif available, otherwise setTimeout(callback, 0), which means other higher priority\nevents may precede the execution of the callback.\n\nThis is used internally for browser-compatibility purposes.\n\n__Arguments__\n\n* callback - The function to call on a later loop around the event loop.\n\n__Example__\n\n```js\nvar call_order = [];\nasync.nextTick(function(){\n    call_order.push('two');\n    // call_order now equals ['one','two']\n});\ncall_order.push('one')\n```\n\n<a name=\"times\" />\n### times(n, callback)\n\nCalls the callback n times and accumulates results in the same manner\nyou would use with async.map.\n\n__Arguments__\n\n* n - The number of times to run the function.\n* callback - The function to call n times.\n\n__Example__\n\n```js\n// Pretend this is some complicated async factory\nvar createUser = function(id, callback) {\n  callback(null, {\n    id: 'user' + id\n  })\n}\n// generate 5 users\nasync.times(5, function(n, next){\n    createUser(n, function(err, user) {\n      next(err, user)\n    })\n}, function(err, users) {\n  // we should now have 5 users\n});\n```\n\n<a name=\"timesSeries\" />\n### timesSeries(n, callback)\n\nThe same as times only the iterator is applied to each item in the array in\nseries. The next iterator is only called once the current one has completed\nprocessing. The results array will be in the same order as the original.\n\n\n## Utils\n\n<a name=\"memoize\" />\n### memoize(fn, [hasher])\n\nCaches the results of an async function. When creating a hash to store function\nresults against, the callback is omitted from the hash and an optional hash\nfunction can be used.\n\nThe cache of results is exposed as the `memo` property of the function returned\nby `memoize`.\n\n__Arguments__\n\n* fn - the function you to proxy and cache results from.\n* hasher - an optional function for generating a custom hash for storing\n  results, it has all the arguments applied to it apart from the callback, and\n  must be synchronous.\n\n__Example__\n\n```js\nvar slow_fn = function (name, callback) {\n    // do something\n    callback(null, result);\n};\nvar fn = async.memoize(slow_fn);\n\n// fn can now be used as if it were slow_fn\nfn('some name', function () {\n    // callback\n});\n```\n\n<a name=\"unmemoize\" />\n### unmemoize(fn)\n\nUndoes a memoized function, reverting it to the original, unmemoized\nform. Comes handy in tests.\n\n__Arguments__\n\n* fn - the memoized function\n\n<a name=\"log\" />\n### log(function, arguments)\n\nLogs the result of an async function to the console. Only works in node.js or\nin browsers that support console.log and console.error (such as FF and Chrome).\nIf multiple arguments are returned from the async function, console.log is\ncalled on each argument in order.\n\n__Arguments__\n\n* function - The function you want to eventually apply all arguments to.\n* arguments... - Any number of arguments to apply to the function.\n\n__Example__\n\n```js\nvar hello = function(name, callback){\n    setTimeout(function(){\n        callback(null, 'hello ' + name);\n    }, 1000);\n};\n```\n```js\nnode> async.log(hello, 'world');\n'hello world'\n```\n\n---------------------------------------\n\n<a name=\"dir\" />\n### dir(function, arguments)\n\nLogs the result of an async function to the console using console.dir to\ndisplay the properties of the resulting object. Only works in node.js or\nin browsers that support console.dir and console.error (such as FF and Chrome).\nIf multiple arguments are returned from the async function, console.dir is\ncalled on each argument in order.\n\n__Arguments__\n\n* function - The function you want to eventually apply all arguments to.\n* arguments... - Any number of arguments to apply to the function.\n\n__Example__\n\n```js\nvar hello = function(name, callback){\n    setTimeout(function(){\n        callback(null, {hello: name});\n    }, 1000);\n};\n```\n```js\nnode> async.dir(hello, 'world');\n{hello: 'world'}\n```\n\n---------------------------------------\n\n<a name=\"noConflict\" />\n### noConflict()\n\nChanges the value of async back to its original value, returning a reference to the\nasync object.\n",
	  "readmeFilename": "README.md",
	  "homepage": "https://github.com/caolan/async",
	  "_id": "async@0.2.9",
	  "_from": "async@~0.2.9"
	}
	
	}).call(this);
	

}, 'redis/package.json': function(exports, module) {

	/** node globals **/
	var require = function(name) {return window.require(name, 'redis/package.json');};
	require.resolve = function(name, parent) {if (parent === null) {parent = 'redis/package.json';} return window.require.resolve(name, parent);};
	require.define = function(bundle) {window.require.define(bundle);};
	require.cache = window.require.cache;
	var __filename = 'redis/package.json';
	var __dirname = 'redis';
	var process = {cwd: function() {return '/';}, argv: ['node', 'redis/package.json'], env: {}};

	/** code **/
	module.exports = (function() {
	return {
	  "name": "redis",
	  "version": "0.10.0",
	  "description": "Redis client library",
	  "keywords": [
	    "redis",
	    "database"
	  ],
	  "author": {
	    "name": "Matt Ranney",
	    "email": "mjr@ranney.com"
	  },
	  "main": "./index.js",
	  "scripts": {
	    "test": "node ./test.js"
	  },
	  "devDependencies": {
	    "metrics": ">=0.1.5",
	    "colors": "~0.6.0-1",
	    "underscore": "~1.4.4"
	  },
	  "repository": {
	    "type": "git",
	    "url": "git://github.com/mranney/node_redis.git"
	  },
	  "readme": "redis - a node.js redis client\n===========================\n\nThis is a complete Redis client for node.js.  It supports all Redis commands, including many recently added commands like EVAL from\nexperimental Redis server branches.\n\n\nInstall with:\n\n    npm install redis\n\nPieter Noordhuis has provided a binding to the official `hiredis` C library, which is non-blocking and fast.  To use `hiredis`, do:\n\n    npm install hiredis redis\n\nIf `hiredis` is installed, `node_redis` will use it by default.  Otherwise, a pure JavaScript parser will be used.\n\nIf you use `hiredis`, be sure to rebuild it whenever you upgrade your version of node.  There are mysterious failures that can\nhappen between node and native code modules after a node upgrade.\n\n\n## Usage\n\nSimple example, included as `examples/simple.js`:\n\n```js\n    var redis = require(\"redis\"),\n        client = redis.createClient();\n\n    // if you'd like to select database 3, instead of 0 (default), call\n    // client.select(3, function() { /* ... */ });\n\n    client.on(\"error\", function (err) {\n        console.log(\"Error \" + err);\n    });\n\n    client.set(\"string key\", \"string val\", redis.print);\n    client.hset(\"hash key\", \"hashtest 1\", \"some value\", redis.print);\n    client.hset([\"hash key\", \"hashtest 2\", \"some other value\"], redis.print);\n    client.hkeys(\"hash key\", function (err, replies) {\n        console.log(replies.length + \" replies:\");\n        replies.forEach(function (reply, i) {\n            console.log(\"    \" + i + \": \" + reply);\n        });\n        client.quit();\n    });\n```\n\nThis will display:\n\n    mjr:~/work/node_redis (master)$ node example.js\n    Reply: OK\n    Reply: 0\n    Reply: 0\n    2 replies:\n        0: hashtest 1\n        1: hashtest 2\n    mjr:~/work/node_redis (master)$\n\n\n## Performance\n\nHere are typical results of `multi_bench.js` which is similar to `redis-benchmark` from the Redis distribution.\nIt uses 50 concurrent connections with no pipelining.\n\nJavaScript parser:\n\n    PING: 20000 ops 42283.30 ops/sec 0/5/1.182\n    SET: 20000 ops 32948.93 ops/sec 1/7/1.515\n    GET: 20000 ops 28694.40 ops/sec 0/9/1.740\n    INCR: 20000 ops 39370.08 ops/sec 0/8/1.269\n    LPUSH: 20000 ops 36429.87 ops/sec 0/8/1.370\n    LRANGE (10 elements): 20000 ops 9891.20 ops/sec 1/9/5.048\n    LRANGE (100 elements): 20000 ops 1384.56 ops/sec 10/91/36.072\n\nhiredis parser:\n\n    PING: 20000 ops 46189.38 ops/sec 1/4/1.082\n    SET: 20000 ops 41237.11 ops/sec 0/6/1.210\n    GET: 20000 ops 39682.54 ops/sec 1/7/1.257\n    INCR: 20000 ops 40080.16 ops/sec 0/8/1.242\n    LPUSH: 20000 ops 41152.26 ops/sec 0/3/1.212\n    LRANGE (10 elements): 20000 ops 36563.07 ops/sec 1/8/1.363\n    LRANGE (100 elements): 20000 ops 21834.06 ops/sec 0/9/2.287\n\nThe performance of `node_redis` improves dramatically with pipelining, which happens automatically in most normal programs.\n\n\n### Sending Commands\n\nEach Redis command is exposed as a function on the `client` object.\nAll functions take either an `args` Array plus optional `callback` Function or\na variable number of individual arguments followed by an optional callback.\nHere is an example of passing an array of arguments and a callback:\n\n    client.mset([\"test keys 1\", \"test val 1\", \"test keys 2\", \"test val 2\"], function (err, res) {});\n\nHere is that same call in the second style:\n\n    client.mset(\"test keys 1\", \"test val 1\", \"test keys 2\", \"test val 2\", function (err, res) {});\n\nNote that in either form the `callback` is optional:\n\n    client.set(\"some key\", \"some val\");\n    client.set([\"some other key\", \"some val\"]);\n\nIf the key is missing, reply will be null (probably):\n\n    client.get(\"missingkey\", function(err, reply) {\n        // reply is null when the key is missing\n        console.log(reply);\n    });\n\nFor a list of Redis commands, see [Redis Command Reference](http://redis.io/commands)\n\nThe commands can be specified in uppercase or lowercase for convenience.  `client.get()` is the same as `client.GET()`.\n\nMinimal parsing is done on the replies.  Commands that return a single line reply return JavaScript Strings,\ninteger replies return JavaScript Numbers, \"bulk\" replies return node Buffers, and \"multi bulk\" replies return a\nJavaScript Array of node Buffers.  `HGETALL` returns an Object with Buffers keyed by the hash keys.\n\n# API\n\n## Connection Events\n\n`client` will emit some events about the state of the connection to the Redis server.\n\n### \"ready\"\n\n`client` will emit `ready` a connection is established to the Redis server and the server reports\nthat it is ready to receive commands.  Commands issued before the `ready` event are queued,\nthen replayed just before this event is emitted.\n\n### \"connect\"\n\n`client` will emit `connect` at the same time as it emits `ready` unless `client.options.no_ready_check`\nis set.  If this options is set, `connect` will be emitted when the stream is connected, and then\nyou are free to try to send commands.\n\n### \"error\"\n\n`client` will emit `error` when encountering an error connecting to the Redis server.\n\nNote that \"error\" is a special event type in node.  If there are no listeners for an\n\"error\" event, node will exit.  This is usually what you want, but it can lead to some\ncryptic error messages like this:\n\n    mjr:~/work/node_redis (master)$ node example.js\n\n    node.js:50\n        throw e;\n        ^\n    Error: ECONNREFUSED, Connection refused\n        at IOWatcher.callback (net:870:22)\n        at node.js:607:9\n\nNot very useful in diagnosing the problem, but if your program isn't ready to handle this,\nit is probably the right thing to just exit.\n\n`client` will also emit `error` if an exception is thrown inside of `node_redis` for whatever reason.\nIt would be nice to distinguish these two cases.\n\n### \"end\"\n\n`client` will emit `end` when an established Redis server connection has closed.\n\n### \"drain\"\n\n`client` will emit `drain` when the TCP connection to the Redis server has been buffering, but is now\nwritable.  This event can be used to stream commands in to Redis and adapt to backpressure.  Right now,\nyou need to check `client.command_queue.length` to decide when to reduce your send rate.  Then you can\nresume sending when you get `drain`.\n\n### \"idle\"\n\n`client` will emit `idle` when there are no outstanding commands that are awaiting a response.\n\n## redis.createClient(port, host, options)\n\nCreate a new client connection.  `port` defaults to `6379` and `host` defaults\nto `127.0.0.1`.  If you have `redis-server` running on the same computer as node, then the defaults for\nport and host are probably fine.  `options` in an object with the following possible properties:\n\n* `parser`: which Redis protocol reply parser to use.  Defaults to `hiredis` if that module is installed.\nThis may also be set to `javascript`.\n* `return_buffers`: defaults to `false`.  If set to `true`, then all replies will be sent to callbacks as node Buffer\nobjects instead of JavaScript Strings.\n* `detect_buffers`: default to `false`. If set to `true`, then replies will be sent to callbacks as node Buffer objects\nif any of the input arguments to the original command were Buffer objects.\nThis option lets you switch between Buffers and Strings on a per-command basis, whereas `return_buffers` applies to\nevery command on a client.\n* `socket_nodelay`: defaults to `true`. Whether to call setNoDelay() on the TCP stream, which disables the\nNagle algorithm on the underlying socket.  Setting this option to `false` can result in additional throughput at the\ncost of more latency.  Most applications will want this set to `true`.\n* `no_ready_check`: defaults to `false`. When a connection is established to the Redis server, the server might still\nbe loading the database from disk.  While loading, the server not respond to any commands.  To work around this,\n`node_redis` has a \"ready check\" which sends the `INFO` command to the server.  The response from the `INFO` command\nindicates whether the server is ready for more commands.  When ready, `node_redis` emits a `ready` event.\nSetting `no_ready_check` to `true` will inhibit this check.\n* `enable_offline_queue`: defaults to `true`. By default, if there is no active\nconnection to the redis server, commands are added to a queue and are executed\nonce the connection has been established. Setting `enable_offline_queue` to\n`false` will disable this feature and the callback will be execute immediately\nwith an error, or an error will be thrown if no callback is specified.\n* `retry_max_delay`: defaults to `null`. By default every time the client tries to connect and fails time before\nreconnection (delay) almost doubles. This delay normally grows infinitely, but setting `retry_max_delay` limits delay\nto maximum value, provided in milliseconds.\n* `connect_timeout` defaults to `false`. By default client will try reconnecting until connected. Setting `connect_timeout`\nlimits total time for client to reconnect. Value is provided in milliseconds and is counted once the disconnect occured.\n* `max_attempts` defaults to `null`. By default client will try reconnecting until connected. Setting `max_attempts`\nlimits total amount of reconnects.\n* `auth_pass` defaults to `null`. By default client will try connecting without auth. If set, client will run redis auth command on connect.\n\n```js\n    var redis = require(\"redis\"),\n        client = redis.createClient(null, null, {detect_buffers: true});\n\n    client.set(\"foo_rand000000000000\", \"OK\");\n\n    // This will return a JavaScript String\n    client.get(\"foo_rand000000000000\", function (err, reply) {\n        console.log(reply.toString()); // Will print `OK`\n    });\n\n    // This will return a Buffer since original key is specified as a Buffer\n    client.get(new Buffer(\"foo_rand000000000000\"), function (err, reply) {\n        console.log(reply.toString()); // Will print `<Buffer 4f 4b>`\n    });\n    client.end();\n```\n\n`createClient()` returns a `RedisClient` object that is named `client` in all of the examples here.\n\n### Unix Domain Socket\n\nYou can also create a connection to Redis server via the unix domain socket if the server\nhas it enabled:\n\n```js\nvar redis = require(\"redis\");\nvar client = redis.createClient(\"/tmp/redis.sock\");\n```\n\nSample `redis.conf` configuration to enable unix domain socket listening:\n\n```conf\nunixsocket /tmp/redis.sock\nunixsocketperm 755\n```\n\nSee [issue #204](https://github.com/mranney/node_redis/issues/204) for more information.\n\n## client.auth(password, callback)\n\nWhen connecting to Redis servers that require authentication, the `AUTH` command must be sent as the\nfirst command after connecting.  This can be tricky to coordinate with reconnections, the ready check,\netc.  To make this easier, `client.auth()` stashes `password` and will send it after each connection,\nincluding reconnections.  `callback` is invoked only once, after the response to the very first\n`AUTH` command sent.\nNOTE: Your call to `client.auth()` should not be inside the ready handler. If\nyou are doing this wrong, `client` will emit an error that looks\nsomething like this `Error: Ready check failed: ERR operation not permitted`.\n\n## client.end()\n\nForcibly close the connection to the Redis server.  Note that this does not wait until all replies have been parsed.\nIf you want to exit cleanly, call `client.quit()` to send the `QUIT` command after you have handled all replies.\n\nThis example closes the connection to the Redis server before the replies have been read.  You probably don't\nwant to do this:\n\n```js\n    var redis = require(\"redis\"),\n        client = redis.createClient();\n\n    client.set(\"foo_rand000000000000\", \"some fantastic value\");\n    client.get(\"foo_rand000000000000\", function (err, reply) {\n        console.log(reply.toString());\n    });\n    client.end();\n```\n\n`client.end()` is useful for timeout cases where something is stuck or taking too long and you want\nto start over.\n\n## client.unref()\n\nCall `unref()` on the underlying socket connection to the Redis server, allowing the program to exit once no more commands are pending.\n\nThis is an **experimental** feature, and only supports a subset of the Redis protocol. Any commands where client state is saved on the Redis server, e.g. `*SUBSCRIBE` or the blocking `BL*` commands will *NOT* work with `.unref()`.\n\n```js\nvar redis = require(\"redis\")\nvar client = redis.createClient()\n\n/*\n    Calling unref() will allow this program to exit immediately after the get command finishes. Otherwise the client would hang as long as the client-server connection is alive.\n*/\nclient.unref()\nclient.get(\"foo\", function (err, value){\n    if (err) throw(err)\n    console.log(value)\n})\n```\n\n## Friendlier hash commands\n\nMost Redis commands take a single String or an Array of Strings as arguments, and replies are sent back as a single String or an Array of Strings.\nWhen dealing with hash values, there are a couple of useful exceptions to this.\n\n### client.hgetall(hash)\n\nThe reply from an HGETALL command will be converted into a JavaScript Object by `node_redis`.  That way you can interact\nwith the responses using JavaScript syntax.\n\nExample:\n\n    client.hmset(\"hosts\", \"mjr\", \"1\", \"another\", \"23\", \"home\", \"1234\");\n    client.hgetall(\"hosts\", function (err, obj) {\n        console.dir(obj);\n    });\n\nOutput:\n\n    { mjr: '1', another: '23', home: '1234' }\n\n### client.hmset(hash, obj, [callback])\n\nMultiple values in a hash can be set by supplying an object:\n\n    client.HMSET(key2, {\n        \"0123456789\": \"abcdefghij\", // NOTE: key and value will be coerced to strings\n        \"some manner of key\": \"a type of value\"\n    });\n\nThe properties and values of this Object will be set as keys and values in the Redis hash.\n\n### client.hmset(hash, key1, val1, ... keyn, valn, [callback])\n\nMultiple values may also be set by supplying a list:\n\n    client.HMSET(key1, \"0123456789\", \"abcdefghij\", \"some manner of key\", \"a type of value\");\n\n\n## Publish / Subscribe\n\nHere is a simple example of the API for publish / subscribe.  This program opens two\nclient connections, subscribes to a channel on one of them, and publishes to that\nchannel on the other:\n\n```js\n    var redis = require(\"redis\"),\n        client1 = redis.createClient(), client2 = redis.createClient(),\n        msg_count = 0;\n\n    client1.on(\"subscribe\", function (channel, count) {\n        client2.publish(\"a nice channel\", \"I am sending a message.\");\n        client2.publish(\"a nice channel\", \"I am sending a second message.\");\n        client2.publish(\"a nice channel\", \"I am sending my last message.\");\n    });\n\n    client1.on(\"message\", function (channel, message) {\n        console.log(\"client1 channel \" + channel + \": \" + message);\n        msg_count += 1;\n        if (msg_count === 3) {\n            client1.unsubscribe();\n            client1.end();\n            client2.end();\n        }\n    });\n\n    client1.incr(\"did a thing\");\n    client1.subscribe(\"a nice channel\");\n```\n\nWhen a client issues a `SUBSCRIBE` or `PSUBSCRIBE`, that connection is put into a \"subscriber\" mode.\nAt that point, only commands that modify the subscription set are valid.  When the subscription\nset is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just open another connection.\n\n## Subscriber Events\n\nIf a client has subscriptions active, it may emit these events:\n\n### \"message\" (channel, message)\n\nClient will emit `message` for every message received that matches an active subscription.\nListeners are passed the channel name as `channel` and the message Buffer as `message`.\n\n### \"pmessage\" (pattern, channel, message)\n\nClient will emit `pmessage` for every message received that matches an active subscription pattern.\nListeners are passed the original pattern used with `PSUBSCRIBE` as `pattern`, the sending channel\nname as `channel`, and the message Buffer as `message`.\n\n### \"subscribe\" (channel, count)\n\nClient will emit `subscribe` in response to a `SUBSCRIBE` command.  Listeners are passed the\nchannel name as `channel` and the new count of subscriptions for this client as `count`.\n\n### \"psubscribe\" (pattern, count)\n\nClient will emit `psubscribe` in response to a `PSUBSCRIBE` command.  Listeners are passed the\noriginal pattern as `pattern`, and the new count of subscriptions for this client as `count`.\n\n### \"unsubscribe\" (channel, count)\n\nClient will emit `unsubscribe` in response to a `UNSUBSCRIBE` command.  Listeners are passed the\nchannel name as `channel` and the new count of subscriptions for this client as `count`.  When\n`count` is 0, this client has left subscriber mode and no more subscriber events will be emitted.\n\n### \"punsubscribe\" (pattern, count)\n\nClient will emit `punsubscribe` in response to a `PUNSUBSCRIBE` command.  Listeners are passed the\nchannel name as `channel` and the new count of subscriptions for this client as `count`.  When\n`count` is 0, this client has left subscriber mode and no more subscriber events will be emitted.\n\n## client.multi([commands])\n\n`MULTI` commands are queued up until an `EXEC` is issued, and then all commands are run atomically by\nRedis.  The interface in `node_redis` is to return an individual `Multi` object by calling `client.multi()`.\n\n```js\n    var redis  = require(\"./index\"),\n        client = redis.createClient(), set_size = 20;\n\n    client.sadd(\"bigset\", \"a member\");\n    client.sadd(\"bigset\", \"another member\");\n\n    while (set_size > 0) {\n        client.sadd(\"bigset\", \"member \" + set_size);\n        set_size -= 1;\n    }\n\n    // multi chain with an individual callback\n    client.multi()\n        .scard(\"bigset\")\n        .smembers(\"bigset\")\n        .keys(\"*\", function (err, replies) {\n            // NOTE: code in this callback is NOT atomic\n            // this only happens after the the .exec call finishes.\n            client.mget(replies, redis.print);\n        })\n        .dbsize()\n        .exec(function (err, replies) {\n            console.log(\"MULTI got \" + replies.length + \" replies\");\n            replies.forEach(function (reply, index) {\n                console.log(\"Reply \" + index + \": \" + reply.toString());\n            });\n        });\n```\n\n### Multi.exec( callback )\n\n`client.multi()` is a constructor that returns a `Multi` object.  `Multi` objects share all of the\nsame command methods as `client` objects do.  Commands are queued up inside the `Multi` object\nuntil `Multi.exec()` is invoked.\n\nThe `callback` of `.exec()` will get invoked with two arguments:\n\n* `err` **type:** `null | Array` err is either null or an array of Error Objects corresponding the the sequence the commands where chained. The last item of the array will always be an `EXECABORT` type of error originating from the `.exec()` itself.\n* `results` **type:** `null | Array` results is an array of responses corresponding the the sequence the commands where chained.\n\nYou can either chain together `MULTI` commands as in the above example, or you can queue individual\ncommands while still sending regular client command as in this example:\n\n```js\n    var redis  = require(\"redis\"),\n        client = redis.createClient(), multi;\n\n    // start a separate multi command queue\n    multi = client.multi();\n    multi.incr(\"incr thing\", redis.print);\n    multi.incr(\"incr other thing\", redis.print);\n\n    // runs immediately\n    client.mset(\"incr thing\", 100, \"incr other thing\", 1, redis.print);\n\n    // drains multi queue and runs atomically\n    multi.exec(function (err, replies) {\n        console.log(replies); // 101, 2\n    });\n\n    // you can re-run the same transaction if you like\n    multi.exec(function (err, replies) {\n        console.log(replies); // 102, 3\n        client.quit();\n    });\n```\n\nIn addition to adding commands to the `MULTI` queue individually, you can also pass an array\nof commands and arguments to the constructor:\n\n```js\n    var redis  = require(\"redis\"),\n        client = redis.createClient(), multi;\n\n    client.multi([\n        [\"mget\", \"multifoo\", \"multibar\", redis.print],\n        [\"incr\", \"multifoo\"],\n        [\"incr\", \"multibar\"]\n    ]).exec(function (err, replies) {\n        console.log(replies);\n    });\n```\n\n\n## Monitor mode\n\nRedis supports the `MONITOR` command, which lets you see all commands received by the Redis server\nacross all client connections, including from other client libraries and other computers.\n\nAfter you send the `MONITOR` command, no other commands are valid on that connection.  `node_redis`\nwill emit a `monitor` event for every new monitor message that comes across.  The callback for the\n`monitor` event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```js\n    var client  = require(\"redis\").createClient(),\n        util = require(\"util\");\n\n    client.monitor(function (err, res) {\n        console.log(\"Entering monitoring mode.\");\n    });\n\n    client.on(\"monitor\", function (time, args) {\n        console.log(time + \": \" + util.inspect(args));\n    });\n```\n\n# Extras\n\nSome other things you might like to know about.\n\n## client.server_info\n\nAfter the ready probe completes, the results from the INFO command are saved in the `client.server_info`\nobject.\n\nThe `versions` key contains an array of the elements of the version string for easy comparison.\n\n    > client.server_info.redis_version\n    '2.3.0'\n    > client.server_info.versions\n    [ 2, 3, 0 ]\n\n## redis.print()\n\nA handy callback function for displaying return values when testing.  Example:\n\n```js\n    var redis = require(\"redis\"),\n        client = redis.createClient();\n\n    client.on(\"connect\", function () {\n        client.set(\"foo_rand000000000000\", \"some fantastic value\", redis.print);\n        client.get(\"foo_rand000000000000\", redis.print);\n    });\n```\n\nThis will print:\n\n    Reply: OK\n    Reply: some fantastic value\n\nNote that this program will not exit cleanly because the client is still connected.\n\n## redis.debug_mode\n\nBoolean to enable debug mode and protocol tracing.\n\n```js\n    var redis = require(\"redis\"),\n        client = redis.createClient();\n\n    redis.debug_mode = true;\n\n    client.on(\"connect\", function () {\n        client.set(\"foo_rand000000000000\", \"some fantastic value\");\n    });\n```\n\nThis will display:\n\n    mjr:~/work/node_redis (master)$ node ~/example.js\n    send command: *3\n    $3\n    SET\n    $20\n    foo_rand000000000000\n    $20\n    some fantastic value\n\n    on_data: +OK\n\n`send command` is data sent into Redis and `on_data` is data received from Redis.\n\n## Multi-word commands\n\nTo execute redis multi-word commands like `SCRIPT LOAD` or `CLIENT LIST` pass\nthe second word as first parameter:\n\n    client.script('load', 'return 1');\n    client.multi().script('load', 'return 1').exec(...);\n    client.multi([['script', 'load', 'return 1']]).exec(...);\n\n## client.send_command(command_name, args, callback)\n\nUsed internally to send commands to Redis.  For convenience, nearly all commands that are published on the Redis\nWiki have been added to the `client` object.  However, if I missed any, or if new commands are introduced before\nthis library is updated, you can use `send_command()` to send arbitrary commands to Redis.\n\nAll commands are sent as multi-bulk commands.  `args` can either be an Array of arguments, or omitted.\n\n## client.connected\n\nBoolean tracking the state of the connection to the Redis server.\n\n## client.command_queue.length\n\nThe number of commands that have been sent to the Redis server but not yet replied to.  You can use this to\nenforce some kind of maximum queue depth for commands while connected.\n\nDon't mess with `client.command_queue` though unless you really know what you are doing.\n\n## client.offline_queue.length\n\nThe number of commands that have been queued up for a future connection.  You can use this to enforce\nsome kind of maximum queue depth for pre-connection commands.\n\n## client.retry_delay\n\nCurrent delay in milliseconds before a connection retry will be attempted.  This starts at `250`.\n\n## client.retry_backoff\n\nMultiplier for future retry timeouts.  This should be larger than 1 to add more time between retries.\nDefaults to 1.7.  The default initial connection retry is 250, so the second retry will be 425, followed by 723.5, etc.\n\n### Commands with Optional and Keyword arguments\n\nThis applies to anything that uses an optional `[WITHSCORES]` or `[LIMIT offset count]` in the [redis.io/commands](http://redis.io/commands) documentation.\n\nExample:\n```js\nvar args = [ 'myzset', 1, 'one', 2, 'two', 3, 'three', 99, 'ninety-nine' ];\nclient.zadd(args, function (err, response) {\n    if (err) throw err;\n    console.log('added '+response+' items.');\n\n    // -Infinity and +Infinity also work\n    var args1 = [ 'myzset', '+inf', '-inf' ];\n    client.zrevrangebyscore(args1, function (err, response) {\n        if (err) throw err;\n        console.log('example1', response);\n        // write your code here\n    });\n\n    var max = 3, min = 1, offset = 1, count = 2;\n    var args2 = [ 'myzset', max, min, 'WITHSCORES', 'LIMIT', offset, count ];\n    client.zrevrangebyscore(args2, function (err, response) {\n        if (err) throw err;\n        console.log('example2', response);\n        // write your code here\n    });\n});\n```\n\n## TODO\n\nBetter tests for auth, disconnect/reconnect, and all combinations thereof.\n\nStream large set/get values into and out of Redis.  Otherwise the entire value must be in node's memory.\n\nPerformance can be better for very large values.\n\nI think there are more performance improvements left in there for smaller values, especially for large lists of small values.\n\n## How to Contribute\n- open a pull request and then wait for feedback (if\n  [DTrejo](http://github.com/dtrejo) does not get back to you within 2 days,\n  comment again with indignation!)\n\n## Contributors\nSome people have have added features and fixed bugs in `node_redis` other than me.\n\nOrdered by date of first contribution.\n[Auto-generated](http://github.com/dtrejo/node-authors) on Wed Jul 25 2012 19:14:59 GMT-0700 (PDT).\n\n- [Matt Ranney aka `mranney`](https://github.com/mranney)\n- [Tim-Smart aka `tim-smart`](https://github.com/tim-smart)\n- [Tj Holowaychuk aka `visionmedia`](https://github.com/visionmedia)\n- [rick aka `technoweenie`](https://github.com/technoweenie)\n- [Orion Henry aka `orionz`](https://github.com/orionz)\n- [Aivo Paas aka `aivopaas`](https://github.com/aivopaas)\n- [Hank Sims aka `hanksims`](https://github.com/hanksims)\n- [Paul Carey aka `paulcarey`](https://github.com/paulcarey)\n- [Pieter Noordhuis aka `pietern`](https://github.com/pietern)\n- [nithesh aka `nithesh`](https://github.com/nithesh)\n- [Andy Ray aka `andy2ray`](https://github.com/andy2ray)\n- [unknown aka `unknowdna`](https://github.com/unknowdna)\n- [Dave Hoover aka `redsquirrel`](https://github.com/redsquirrel)\n- [Vladimir Dronnikov aka `dvv`](https://github.com/dvv)\n- [Umair Siddique aka `umairsiddique`](https://github.com/umairsiddique)\n- [Louis-Philippe Perron aka `lp`](https://github.com/lp)\n- [Mark Dawson aka `markdaws`](https://github.com/markdaws)\n- [Ian Babrou aka `bobrik`](https://github.com/bobrik)\n- [Felix Geisendörfer aka `felixge`](https://github.com/felixge)\n- [Jean-Hugues Pinson aka `undefined`](https://github.com/undefined)\n- [Maksim Lin aka `maks`](https://github.com/maks)\n- [Owen Smith aka `orls`](https://github.com/orls)\n- [Zachary Scott aka `zzak`](https://github.com/zzak)\n- [TEHEK Firefox aka `TEHEK`](https://github.com/TEHEK)\n- [Isaac Z. Schlueter aka `isaacs`](https://github.com/isaacs)\n- [David Trejo aka `DTrejo`](https://github.com/DTrejo)\n- [Brian Noguchi aka `bnoguchi`](https://github.com/bnoguchi)\n- [Philip Tellis aka `bluesmoon`](https://github.com/bluesmoon)\n- [Marcus Westin aka `marcuswestin2`](https://github.com/marcuswestin2)\n- [Jed Schmidt aka `jed`](https://github.com/jed)\n- [Dave Peticolas aka `jdavisp3`](https://github.com/jdavisp3)\n- [Trae Robrock aka `trobrock`](https://github.com/trobrock)\n- [Shankar Karuppiah aka `shankar0306`](https://github.com/shankar0306)\n- [Ignacio Burgueño aka `ignacio`](https://github.com/ignacio)\n\nThanks.\n\n## LICENSE - \"MIT License\"\n\nCopyright (c) 2010 Matthew Ranney, http://ranney.com/\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\n![spacer](http://ranney.com/1px.gif)\n",
	  "readmeFilename": "README.md",
	  "bugs": {
	    "url": "https://github.com/mranney/node_redis/issues"
	  },
	  "homepage": "https://github.com/mranney/node_redis",
	  "_id": "redis@0.10.0",
	  "dist": {
	    "shasum": "76864475f71a745cbc3bbb27d794a6d01a96505c"
	  },
	  "_from": "redis@~0.10.0",
	  "_resolved": "https://registry.npmjs.org/redis/-/redis-0.10.0.tgz"
	}
	
	}).call(this);
	

}, 'cache-storage': function(exports, module) { module.exports = window.require('/lib/Cache'); }
, 'cache-storage/lib/Storage/Sync/Storage': function(exports, module) { module.exports = window.require('/lib/Storage/Sync/Storage'); }
, 'cache-storage/lib/Storage/Async/Storage': function(exports, module) { module.exports = window.require('/lib/Storage/Async/Storage'); }
, 'cache-storage/Storage/BrowserLocalSyncStorage': function(exports, module) { module.exports = window.require('/Storage/BrowserLocalSyncStorage'); }
, 'cache-storage/Storage/DevNullSyncStorage': function(exports, module) { module.exports = window.require('/Storage/DevNullSyncStorage'); }
, 'cache-storage/Storage/FileSyncStorage': function(exports, module) { module.exports = window.require('/Storage/FileSyncStorage'); }
, 'cache-storage/Storage/MemorySyncStorage': function(exports, module) { module.exports = window.require('/Storage/MemorySyncStorage'); }
, 'cache-storage/Storage/Storage': function(exports, module) { module.exports = window.require('/Storage/Storage'); }
, 'cache-storage/Storage/DevNullAsyncStorage': function(exports, module) { module.exports = window.require('/Storage/DevNullAsyncStorage'); }
, 'cache-storage/Storage/MemoryAsyncStorage': function(exports, module) { module.exports = window.require('/Storage/MemoryAsyncStorage'); }
, 'moment': function(exports, module) { module.exports = window.require('moment/moment.js'); }
, 'fs-mock': function(exports, module) { module.exports = window.require('fs-mock/lib/fs.js'); }
, 'escape-regexp': function(exports, module) { module.exports = window.require('escape-regexp/index.js'); }
, 'async': function(exports, module) { module.exports = window.require('async/lib/async.js'); }
, 'redis': function(exports, module) { module.exports = window.require('redis/index.js'); }

});
require.__setStats({"/lib/Storage/Sync/BrowserLocalStorage.js":{"atime":1389805806000,"mtime":1389804881000,"ctime":1389804881000},"/lib/Storage/Sync/Storage.js":{"atime":1389805806000,"mtime":1389804956000,"ctime":1389804956000},"/lib/Storage/Storage.js":{"atime":1389799819000,"mtime":1389799818000,"ctime":1389799818000},"moment/moment.js":{"atime":1389726647000,"mtime":1387832828000,"ctime":1389389769000},"/lib/Cache.js":{"atime":1389806757000,"mtime":1389806670000,"ctime":1389806670000},"fs-mock/lib/fs.js":{"atime":1389796776000,"mtime":1389273046000,"ctime":1389391420000},"fs-mock/lib/Stats.js":{"atime":1389796777000,"mtime":1389269301000,"ctime":1389391420000},"fs-mock/lib/Errors.js":{"atime":1389796777000,"mtime":1389269301000,"ctime":1389391420000},"fs-mock/lib/FSWatcher.js":{"atime":1389796777000,"mtime":1389269301000,"ctime":1389391420000},"escape-regexp/index.js":{"atime":1389796777000,"mtime":1345153109000,"ctime":1389391421000},"/lib/Storage/Async/DevNullStorage.js":{"atime":1389807678000,"mtime":1389807676000,"ctime":1389807676000},"/lib/Storage/Async/Storage.js":{"atime":1389806757000,"mtime":1389806460000,"ctime":1389806460000},"async/lib/async.js":{"atime":1389796776000,"mtime":1369727354000,"ctime":1389710356000},"/lib/Storage/Sync/DevNullStorage.js":{"atime":1389805806000,"mtime":1389804904000,"ctime":1389804904000},"/lib/Storage/Async/FileStorage.js":{"atime":1389805806000,"mtime":1389805082000,"ctime":1389805082000},"/lib/Storage/Sync/FileStorage.js":{"atime":1389805806000,"mtime":1389804920000,"ctime":1389804920000},"/lib/Storage/Async/MemoryStorage.js":{"atime":1389805806000,"mtime":1389805095000,"ctime":1389805095000},"/lib/Storage/Sync/MemoryStorage.js":{"atime":1389805806000,"mtime":1389804941000,"ctime":1389804941000},"/lib/Storage/Async/RedisStorage.js":{"atime":1389805806000,"mtime":1389805342000,"ctime":1389805342000},"redis/index.js":{"atime":1389786853000,"mtime":1387652552000,"ctime":1389786795000},"redis/lib/util.js":{"atime":1389786853000,"mtime":1363147062000,"ctime":1389786795000},"redis/lib/queue.js":{"atime":1389786853000,"mtime":1363195944000,"ctime":1389786795000},"redis/lib/to_array.js":{"atime":1389786853000,"mtime":1363147062000,"ctime":1389786795000},"redis/lib/parser/hiredis.js":{"atime":1389786853000,"mtime":1363195944000,"ctime":1389786795000},"redis/lib/parser/javascript.js":{"atime":1389786853000,"mtime":1385231603000,"ctime":1389786795000},"redis/lib/commands.js":{"atime":1389786853000,"mtime":1387650093000,"ctime":1389786795000},"/Storage/BrowserLocalStorage.js":{"atime":1389743491000,"mtime":1389743489000,"ctime":1389743489000},"/Storage/BrowserLocalSyncStorage.js":{"atime":1389743491000,"mtime":1389743489000,"ctime":1389743489000},"/Storage/DevNullAsyncStorage.js":{"atime":1389743491000,"mtime":1389743489000,"ctime":1389743489000},"/Storage/DevNullStorage.js":{"atime":1389743491000,"mtime":1389743489000,"ctime":1389743489000},"/Storage/DevNullSyncStorage.js":{"atime":1389743491000,"mtime":1389743489000,"ctime":1389743489000},"/Storage/FileAsyncStorage.js":{"atime":1389743491000,"mtime":1389743489000,"ctime":1389743489000},"/Storage/FileStorage.js":{"atime":1389743491000,"mtime":1389743489000,"ctime":1389743489000},"/Storage/FileSyncStorage.js":{"atime":1389743491000,"mtime":1389743489000,"ctime":1389743489000},"/Storage/MemoryAsyncStorage.js":{"atime":1389743491000,"mtime":1389743489000,"ctime":1389743489000},"/Storage/MemoryStorage.js":{"atime":1389743491000,"mtime":1389743489000,"ctime":1389743489000},"/Storage/MemorySyncStorage.js":{"atime":1389743491000,"mtime":1389743489000,"ctime":1389743489000},"/Storage/RedisAsyncStorage.js":{"atime":1389799819000,"mtime":1389799818000,"ctime":1389799818000},"/test/browser/tests/Cache.coffee":{"atime":1389796778000,"mtime":1383999743000,"ctime":1389463648000},"/test/browser/tests/Storage/Async/DevNullStorage.coffee":{"atime":1389743491000,"mtime":1389743489000,"ctime":1389743489000},"/test/browser/tests/Storage/Async/MemoryStorage.coffee":{"atime":1389799819000,"mtime":1389799818000,"ctime":1389799818000},"/test/browser/tests/Storage/Async/Storage.coffee":{"atime":1389807829000,"mtime":1389807822000,"ctime":1389807822000},"/test/browser/tests/Storage/Sync/BrowserLocalStorage.coffee":{"atime":1389743491000,"mtime":1389743489000,"ctime":1389743489000},"/test/browser/tests/Storage/Sync/DevNullStorage.coffee":{"atime":1389743491000,"mtime":1389743489000,"ctime":1389743489000},"/test/browser/tests/Storage/Sync/FileStorage.coffee":{"atime":1389743491000,"mtime":1389743489000,"ctime":1389743489000},"/test/browser/tests/Storage/Sync/MemoryStorage.coffee":{"atime":1389743491000,"mtime":1389743489000,"ctime":1389743489000},"/test/browser/tests/Storage/Sync/Storage.coffee":{"atime":1389785279000,"mtime":1389785279000,"ctime":1389785279000},"/package.json":{"atime":1389799819000,"mtime":1389799818000,"ctime":1389799818000},"moment/package.json":{"atime":1389796776000,"mtime":1389389769000,"ctime":1389389769000},"async/package.json":{"atime":1389796776000,"mtime":1389710356000,"ctime":1389710356000},"redis/package.json":{"atime":1389786853000,"mtime":1389786795000,"ctime":1389786795000}});
require.version = '5.5.1';

/** run section **/

/** /test/browser/tests/Cache **/
require('/test/browser/tests/Cache');

/** /test/browser/tests/Storage/Sync/Storage **/
require('/test/browser/tests/Storage/Sync/Storage');

/** /test/browser/tests/Storage/Async/Storage **/
require('/test/browser/tests/Storage/Async/Storage');

/** /test/browser/tests/Storage/Sync/BrowserLocalStorage **/
require('/test/browser/tests/Storage/Sync/BrowserLocalStorage');

/** /test/browser/tests/Storage/Sync/FileStorage **/
require('/test/browser/tests/Storage/Sync/FileStorage');

/** /test/browser/tests/Storage/Sync/DevNullStorage **/
require('/test/browser/tests/Storage/Sync/DevNullStorage');

/** /test/browser/tests/Storage/Sync/MemoryStorage **/
require('/test/browser/tests/Storage/Sync/MemoryStorage');

/** /test/browser/tests/Storage/Async/DevNullStorage **/
require('/test/browser/tests/Storage/Async/DevNullStorage');

/** /test/browser/tests/Storage/Async/MemoryStorage **/
require('/test/browser/tests/Storage/Async/MemoryStorage');