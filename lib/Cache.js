// Generated by CoffeeScript 1.6.3
(function() {
  var Cache, crypto, fs, moment, path;

  crypto = require('crypto');

  path = require('path');

  moment = require('moment');

  fs = require('fs');

  Cache = (function() {
    Cache.FILES = 'files';

    Cache.TAGS = 'tags';

    Cache.EXPIRE = 'expire';

    Cache.ITEMS = 'items';

    Cache.PRIORITY = 'priority';

    Cache.ALL = 'all';

    Cache.TIME_FORMAT = 'YYYY-MM-DD HH:mm';

    Cache.prototype.storage = null;

    Cache.prototype.namespace = null;

    function Cache(storage, namespace) {
      this.storage = storage;
      this.namespace = namespace;
      this.storage.cache = this;
    }

    Cache.prototype.generateKey = function(key) {
      return crypto.createHash('sha1').update(key).digest('hex');
    };

    Cache.prototype.parseDependencies = function(dependencies) {
      var file, files, i, item, result, time, typefn, _i, _j, _len, _len1, _ref, _ref1;
      typefn = Object.prototype.toString;
      result = {};
      if (typefn.call(dependencies) === '[object Object]') {
        if (typeof dependencies[Cache.FILES] !== 'undefined') {
          files = {};
          _ref = dependencies[Cache.FILES];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            file = _ref[_i];
            file = path.resolve(file);
            files[file] = (new Date(fs.statSync(file).mtime)).getTime();
          }
          result[Cache.FILES] = files;
        }
        if (typeof dependencies[Cache.EXPIRE] !== 'undefined') {
          switch (typefn.call(dependencies[Cache.EXPIRE])) {
            case '[object String]':
              time = moment(dependencies[Cache.EXPIRE], Cache.TIME_FORMAT);
              break;
            case '[object Object]':
              time = moment().add(dependencies[Cache.EXPIRE]);
              break;
            default:
              throw new Error('Expire format is not valid');
          }
          result[Cache.EXPIRE] = time.valueOf();
        }
        if (typeof dependencies[Cache.ITEMS] !== 'undefined') {
          result[Cache.ITEMS] = [];
          _ref1 = dependencies[Cache.ITEMS];
          for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
            item = _ref1[i];
            result[Cache.ITEMS].push(this.generateKey(item));
          }
        }
        if (typeof dependencies[Cache.PRIORITY] !== 'undefined') {
          result[Cache.PRIORITY] = dependencies[Cache.PRIORITY];
        }
        if (typeof dependencies[Cache.TAGS] !== 'undefined') {
          result[Cache.TAGS] = dependencies[Cache.TAGS];
        }
      }
      return result;
    };

    Cache.prototype.load = function(key, fallback) {
      var data;
      if (fallback == null) {
        fallback = null;
      }
      data = this.storage.read(this.generateKey(key));
      if (data === null && fallback !== null) {
        return this.save(key, fallback);
      }
      return data;
    };

    Cache.prototype.save = function(key, data, dependencies) {
      if (dependencies == null) {
        dependencies = {};
      }
      key = this.generateKey(key);
      if (Object.prototype.toString.call(data) === '[object Function]') {
        data = data();
      }
      if (data === null) {
        this.storage.remove(key);
      } else {
        this.storage.write(key, data, this.parseDependencies(dependencies));
      }
      return data;
    };

    Cache.prototype.remove = function(key) {
      return this.save(key, null);
    };

    Cache.prototype.clean = function(conditions) {
      this.storage.clean(conditions);
      return this;
    };

    return Cache;

  })();

  module.exports = Cache;

}).call(this);
