// Generated by CoffeeScript 1.6.3
(function() {
  var Cache, Storage, fs, isWindow, moment, path;

  isWindow = typeof window === 'undefined' ? false : true;

  if (!isWindow) {
    fs = require('fs');
    path = require('path');
  }

  moment = require('moment');

  Cache = require('../Cache');

  Storage = (function() {
    Storage.prototype.cache = null;

    Storage.prototype.data = null;

    Storage.prototype.meta = null;

    function Storage() {
      if (typeof this.getData === 'undefined' || typeof this.writeData === 'undefined') {
        throw new Error('Cache storage: you have to implement methods getData and writeData.');
      }
    }

    Storage.prototype.read = function(key) {
      var data;
      data = this.getData();
      if (typeof data[key] === 'undefined') {
        return null;
      } else {
        if (this.verify(this.findMeta(key))) {
          return data[key];
        } else {
          this.remove(key);
          return null;
        }
      }
    };

    Storage.prototype.write = function(key, data, dependencies) {
      var all, meta;
      if (dependencies == null) {
        dependencies = {};
      }
      all = this.getData();
      all[key] = data;
      meta = this.getMeta();
      meta[key] = dependencies;
      this.writeData(all, meta);
      return this;
    };

    Storage.prototype.remove = function(key) {
      var data, meta;
      data = this.getData();
      meta = this.getMeta();
      if (typeof data[key] !== 'undefined') {
        delete data[key];
        delete meta[key];
      }
      this.writeData(data, meta);
      return this;
    };

    Storage.prototype.clean = function(conditions) {
      var key, tag, type, typeFn, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      typeFn = Object.prototype.toString;
      type = typeFn.call(conditions);
      if (conditions === Cache.ALL) {
        this.writeData({}, {});
      } else if (type === '[object Object]') {
        if (typeof conditions[Cache.TAGS] !== 'undefined') {
          if (typeFn(conditions[Cache.TAGS]) === '[object String]') {
            conditions[Cache.TAGS] = [conditions[Cache.TAGS]];
          }
          _ref = conditions[Cache.TAGS];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            tag = _ref[_i];
            _ref1 = this.findKeysByTag(tag);
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              key = _ref1[_j];
              this.remove(key);
            }
          }
        }
        if (typeof conditions[Cache.PRIORITY] !== 'undefined') {
          _ref2 = this.findKeysByPriority(conditions[Cache.PRIORITY]);
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            key = _ref2[_k];
            this.remove(key);
          }
        }
      }
      return this;
    };

    Storage.prototype.getMeta = function() {
      if (this.meta === null) {
        this.getData();
      }
      return this.meta;
    };

    Storage.prototype.findMeta = function(key) {
      var meta;
      meta = this.getMeta();
      if (typeof meta[key] !== 'undefined') {
        return meta[key];
      } else {
        return null;
      }
    };

    Storage.prototype.findKeysByTag = function(tag) {
      var key, meta, metas, result;
      metas = this.getMeta();
      result = [];
      for (key in metas) {
        meta = metas[key];
        if (typeof meta[Cache.TAGS] !== 'undefined' && meta[Cache.TAGS].indexOf(tag) !== -1) {
          result.push(key);
        }
      }
      return result;
    };

    Storage.prototype.findKeysByPriority = function(priority) {
      var key, meta, metas, result;
      metas = this.getMeta();
      result = [];
      for (key in metas) {
        meta = metas[key];
        if (typeof meta[Cache.PRIORITY] !== 'undefined' && meta[Cache.PRIORITY] <= priority) {
          result.push(key);
        }
      }
      return result;
    };

    Storage.prototype.verify = function(meta) {
      var file, item, time, typefn, _i, _len, _ref, _ref1;
      typefn = Object.prototype.toString;
      if (typefn.call(meta) === '[object Object]') {
        if (typeof meta[Cache.FILES] !== 'undefined') {
          if (isWindow) {
            throw new Error('Files meta information is not supported in browser');
          }
          _ref = meta[Cache.FILES];
          for (file in _ref) {
            time = _ref[file];
            if ((new Date(fs.statSync(file).mtime)).getTime() !== time) {
              return false;
            }
          }
        }
        if (typeof meta[Cache.EXPIRE] !== 'undefined') {
          if (moment().valueOf() >= meta[Cache.EXPIRE]) {
            return false;
          }
        }
        if (typeof meta[Cache.ITEMS] !== 'undefined') {
          _ref1 = meta[Cache.ITEMS];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            item = _ref1[_i];
            item = this.findMeta(item);
            if ((item === null) || (item !== null && this.verify(item) === false)) {
              return false;
            }
          }
        }
      }
      return true;
    };

    Storage.prototype.parseDependencies = function(dependencies) {
      var file, files, i, item, result, time, typefn, _i, _j, _len, _len1, _ref, _ref1;
      typefn = Object.prototype.toString;
      result = {};
      if (typefn.call(dependencies) === '[object Object]') {
        if (typeof dependencies[Cache.FILES] !== 'undefined') {
          if (isWindow) {
            throw new Error('Files meta information is not supported in browser');
          }
          files = {};
          _ref = dependencies[Cache.FILES];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            file = _ref[_i];
            file = path.resolve(file);
            files[file] = (new Date(fs.statSync(file).mtime)).getTime();
          }
          result[Cache.FILES] = files;
        }
        if (typeof dependencies[Cache.EXPIRE] !== 'undefined') {
          switch (typefn.call(dependencies[Cache.EXPIRE])) {
            case '[object String]':
              time = moment(dependencies[Cache.EXPIRE], Cache.TIME_FORMAT);
              break;
            case '[object Object]':
              time = moment().add(dependencies[Cache.EXPIRE]);
              break;
            default:
              throw new Error('Expire format is not valid');
          }
          result[Cache.EXPIRE] = time.valueOf();
        }
        if (typeof dependencies[Cache.ITEMS] !== 'undefined') {
          result[Cache.ITEMS] = [];
          _ref1 = dependencies[Cache.ITEMS];
          for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
            item = _ref1[i];
            result[Cache.ITEMS].push(this.cache.generateKey(item));
          }
        }
        if (typeof dependencies[Cache.PRIORITY] !== 'undefined') {
          result[Cache.PRIORITY] = dependencies[Cache.PRIORITY];
        }
        if (typeof dependencies[Cache.TAGS] !== 'undefined') {
          result[Cache.TAGS] = dependencies[Cache.TAGS];
        }
      }
      return result;
    };

    return Storage;

  })();

  module.exports = Storage;

}).call(this);
